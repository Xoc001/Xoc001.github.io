[{"id":"1ec064dab4601a68b47e5aba81d18d63","title":"Go语言入门","content":"Go语言开发\n程序基本结构一：\n\ngo文件的后缀是.go\n\npackage main : 表示该hello.go文件所的包是main，在go中，每个文件都必须属于一个包。\n\nimport “fmt”  : 表示引入一个包，包名 fmt，引入该包后，就可以使用fmt包的函数。\n\nfunc main(){\n}\nfunc 是一个关键字，表示一个函数。\nmain是函数名，是一个主函数。\n\nfmt.Println(“hello”) 表示调用fmt包的Println函数 输出hello。\n\n\n二：通过 go build 文件名.go命令对该go文件编译，生成.exe文件。\n三：运行文件名.exe文件。\n\n四：通过  go run 命令可以直接运行hello.go程序。\n执行流程分析\n如果是对源码编译后，再执行的流程。\n\n对源码直接go run 的运行流程\n\n两种执行流程方式的区别\n\n\n\nGo语言开发注意事项\nGo语言常用转义字符\n\\t：表示一个制表符，可以用来排版\n\\n：换行符\n\\\\：一个\\\n\\“ :一个”\n\\r : 一个回车\n\nDos命令\n删除目录及下面的文件，不询问\n\n删除目录及下面的文件，询问\n\n\n变量\n指定变量类型，声明后若不赋值，使用默认值\n根据值自行判定变量类型(类型推导)\n省略var  , 使用:= 等价于var nume string   name = &quot;tom&quot;\n多变量声明\n\n\n\n全局变量：定义在main方法外\n\n&#x2F;&#x2F;定义全局变量\nvar n1 &#x3D; 100\nvar n2 &#x3D; 200\nvar n3 &#x3D; 300\n&#x2F;&#x2F;上面的声明方式，可以改成一次性声明\nvar(\n    n4 &#x3D; 100\n    n5 &#x3D; &quot;hello&quot;\n)\n\n\n该区域的数据值可以在同一类型范围内不断变化\n变量在同一个作用域内不能重名\n变量&#x3D;变量名+值+数据类型\n默认值 int为0，string为空串\n\n变量的数据类型\n\n在程序中查看某个变量的字节大小和数据类型。\nfunc main() &#123;\n\tvar i int\n\ti&#x3D;100\n\tfmt.Printf(&quot;i变量的类型 %T \\n&quot;,i)\n\tvar j int64 &#x3D;10\n\tfmt.Printf(&quot;j变量的类型 %T,j所占的字节大小 %d&quot;,i,unsafe.Sizeof(j))\n&#125;\n\n\n浮点型\n浮点数在机器中存放形式为：浮点数&#x3D;符号位+指数位+尾数位\n浮点数都是有符号的。\n尾数部分可能丢失，造成精度损失。\n字符类型Go中没有专门的字符类型，需要保存到byte中\n字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。也就是说对于传统的字符串是由字符组成的，而Go的字符串不同，它是由字节组成的。\n\n\n\n如果保存的字符存在于ASCII表中，则可以直接保存到byte\n如果保存的字符的码值大于255，这时需要使用int类型保存\n需要按照字符的方式输出，需要格式化输出，使用fmt.Printf(&quot;%c&quot;,c1)\n\n\n布尔类型\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;unsafe&quot;\n)\n\nfunc main() &#123;\n\tvar flag bool &#x3D; true\n\tfmt.Println(flag)\n\t&#x2F;&#x2F;查看所占存储空间\n\tfmt.Println(&quot;所占存储空间&quot;,unsafe.Sizeof(flag))\n&#125;\n\n\n\n\n字符串类型\n字符串一旦赋值，就不能修改。字符串在Go中是不可变的。\n字符串的两种表示形式\n双引号，会识别转义字符\n反引号&#96;&#96;，以字符串的原生形式输出，包括换行和特殊字符，可以实现防止攻击、输出源代码的效果\n\n\n\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;unsafe&quot;\n)\n\nfunc main() &#123;\n\tvar str1 string &#x3D; &quot;hello&quot;\n\tfmt.Println(str1)\n\tfmt.Println(&quot;str1的存储大小&quot;,unsafe.Sizeof(str1))\n\n\tvar str2 string &#x3D;&quot;abc\\nabce&quot;\n\tfmt.Println(str2)\n\tvar str3 string &#x3D; &#96;package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;unsafe&quot;\n)\n\nfunc main() &#123;\n\tvar str1 string &#x3D; &quot;hello&quot;\n\tfmt.Println(str1)\n\tfmt.Println(&quot;str1的存储大小&quot;,unsafe.Sizeof(str1))\n\n\tvar str2 string &#x3D;&quot;abc\\nabce&quot;\n\tfmt.Println(str2)\n\tvar str3 string &#x3D; &quot;&quot;\n&#125;\n&#96;\n\tfmt.Println(str3)\n\n\t&#x2F;&#x2F;字符串的拼接\n\tvar str4 &#x3D; &quot;Hello&quot; + &quot;world&quot;\n\tfmt.Println(str4)\n\t&#x2F;&#x2F;连续换行拼接，需要将+号写在上一行的结尾\n\tvar str5 &#x3D; &quot;Hello&quot; +&quot; world&quot; +&quot;Hello&quot; +\n\t\t&quot; world&quot; + &quot;Hello&quot; +&quot; world&quot; +\n\t\t&quot;Hello&quot; +&quot; world&quot;\n\tfmt.Println(str5)\n\n\t&#x2F;&#x2F;&#x2F;基本数据类型的默认值\n\tvar a int\n\tvar b float32\n\tvar c float64\n\tvar flag bool\n\tvar name string\n\t&#x2F;&#x2F;格式化输出\n\tfmt.Printf(&quot;a&#x3D;%d,b&#x3D;%f,c&#x3D;%v,flag&#x3D;%v,name&#x3D;%v&quot;,a,b,c,flag,name)\n&#125;\n\n\n基本数据类型的转换\nGo在不同类型之间的赋值需要显式转换。不能自动转换\n\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\tvar i int32 &#x3D; 100\n\tvar n1 float32 &#x3D; float32(i)\n\tvar n2 int8 &#x3D; int8(i)\n\tvar n3 int64 &#x3D; int64(i)\n\n\tfmt.Printf(&quot;n1&#x3D;%f,n2&#x3D;%d,n3&#x3D;%d&quot;,n1,n2,n3)\n&#125;\n\n\n\n注意事项\n\n基本数据类型和String的转换\n方法1：使用fmt.Sprintf()函数\n\n方式2：使用strconv包的函数。\nfunc FormatBool(b bool) string\nfunc FormatInt(i int64, base int) string\nfunc FormatUint(i uint64, base int) string\nfunc FormatFloat(f float64, fmt byte, prec, bitSize int) string\n\n\n\n\n相关代码\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;strconv&quot;\n)\n\nfunc main() &#123;\n\tvar n1 int &#x3D;100\n\tvar n2 float64 &#x3D;23.123\n\tvar flag bool &#x3D;true\n\tvar b byte &#x3D;&#39;a&#39;\n\tvar str string\n\n\t&#x2F;&#x2F;第一种方法，使用fmt包中的函数\n\tstr &#x3D; fmt.Sprintf(&quot;%d&quot;,n1)\n\tfmt.Printf(&quot;str type %T str&#x3D;%q\\n&quot;,str,str)\n\n\tstr &#x3D; fmt.Sprintf(&quot;%f&quot;,n2)\n\tfmt.Printf(&quot;str type %T str&#x3D;%q\\n&quot;,str,str)\n\n\tstr &#x3D; fmt.Sprintf(&quot;%t&quot;,flag)\n\tfmt.Printf(&quot;str type %T str&#x3D;%q\\n&quot;,str,str)\n\n\tstr &#x3D; fmt.Sprintf(&quot;%c&quot;,b)\n\tfmt.Printf(&quot;str type %T str&#x3D;%q\\n&quot;,str,str)\n\n\t&#x2F;&#x2F;第二种方法，使用strconv包中的函数\n\tvar num1 int &#x3D; 99\n\tvar num2 float64 &#x3D; 32.1212\n\tvar flag2 bool &#x3D;true\n\n\tstr &#x3D; strconv.FormatInt(int64(num1),10)\n\tfmt.Printf(&quot;str type %T str&#x3D;%q\\n&quot;,str,str)\n\n\tstr &#x3D; strconv.FormatFloat(num2,&#39;f&#39;,10,64)\n\tfmt.Printf(&quot;str type %T str&#x3D;%q\\n&quot;,str,str)\n\n\tstr &#x3D; strconv.FormatBool(flag2)\n\tfmt.Printf(&quot;str type %T str&#x3D;%q\\n&quot;,str,str)\n&#125;\n\n\n\nString类型转基本数据类型\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;strconv&quot;\n)\n\nfunc main() &#123;\n\t&#x2F;&#x2F;String 转int\n\tvar str string &#x3D;&quot;123747&quot;\n\tvar n1 int64\n\tn1,_ &#x3D; strconv.ParseInt(str,10,64)\n\tfmt.Printf(&quot;n1 type&#x3D; %T n1&#x3D;%d \\n&quot;,n1,n1)\n\n\t&#x2F;&#x2F;String 转float\n\tvar str1 string &#x3D; &quot;123.4567&quot;\n\tvar n2 float64\n\tn2,_ &#x3D; strconv.ParseFloat(str1,64)\n\tfmt.Printf(&quot;n2 type&#x3D;%T n2&#x3D;%f\\n&quot;,n2,n2)\n\n\t&#x2F;&#x2F;String 转 bool\n\tvar str2 string &#x3D;&quot;true&quot;\n\tvar flag bool\n\tflag,_ &#x3D; strconv.ParseBool(str2)\n\tfmt.Printf(&quot;flag type&#x3D;%T flag&#x3D;%t&quot;,flag,flag)\n&#125;\n\n\n\n要确保String类型可以转成有效数据。无效数据直接转换成0，或者默认值。bool-&gt;false\n\n指针\n基本数据类型，变量存的就是值，也叫值类型\n获取变量的地址，用&amp;\n指针类型，指针变量存的是一个地址，这个地址指向的空间存的才是值。\n获取指针类型所指向的值，使用*\n\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\tvar n1 int &#x3D; 100\n\t&#x2F;&#x2F;使用&amp;取地址\n\tfmt.Printf(&quot;n1的地址为:%v \\n&quot;,&amp;n1)\n\t&#x2F;&#x2F;将n1变量的地址赋值给ptr指针变量\n\tvar ptr * int &#x3D; &amp;n1\n\t&#x2F;&#x2F;输出ptr指针变量中的内容\n\tfmt.Printf(&quot;ptr的地址为:%v \\n&quot;,ptr)\n\t&#x2F;&#x2F;输出ptr指针内容所对应地址的值。\n\tfmt.Printf(&quot;ptr指针指向的值为：%d&quot;,*ptr)\n&#125;\n\n\n\n值类型和引用类型\n值类型：基本数据类型，数组和结构体struct\n引用类型：指针、slice切片、map、管道chan、interface等都是引用类型\n\n\n\n值类型：变量直接存储值、内存通常在栈中分配。\n引用类型: 变量存储得是一个地址，这个地址对应的空间才真正存储数据(值)，内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，会被GC回收\n\n\n标识符命名规范\n\n\n代码示例\n\npackage main\n\nimport (\n\t&quot;GoProject&#x2F;src&#x2F;Study03&#x2F;demo13&#x2F;model&quot;\n\t&quot;fmt&quot;\n)\nfunc main() &#123;\n\tfmt.Println(model.HeroName)\n&#125;\n\n\npackage model\n\nvar HeroName string &#x3D;&quot;adfadf&quot;\n\n\n预定义标识符 \n运算符\n\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 除法运算符。说明：如果运算的数都是整数，那么除后，去掉小数部分，保留整数部分\n\tfmt.Println(10 &#x2F; 4)\n\n\t&#x2F;&#x2F;如果希望有小数部分，需要使用浮点数参与运算。\n\tfmt.Println(10.0 &#x2F; 4)\n\n\t&#x2F;&#x2F; 演示取余运算的使用\n\t&#x2F;&#x2F; a % b &#x3D; a - a &#x2F; b * b\n\tfmt.Println(10 % 3)   &#x2F;&#x2F;1\n\tfmt.Println(-10 % 3)  &#x2F;&#x2F; -1\n\tfmt.Println(10 % -3)  &#x2F;&#x2F;1\n\tfmt.Println(-10 % -3) &#x2F;&#x2F;-1\n\n\tvar i int &#x3D; 10\n\ti++\n\tfmt.Println(&quot;i&#x3D;&quot;,i)\n\ti--\n\tfmt.Println(&quot;i&#x3D;&quot;,i)\n\n&#125;\n\n\n运算符使用的注意事项\n关系运算符 \n\n逻辑运算符\n\n赋值运算符\n运算符的优先级\n特别说明Go语言明确不支持三元运算符。\n&#x2F;&#x2F;n &#x3D; i &gt; j? i:j\nif i&gt;j&#123;\n    n &#x3D; i\n&#125; else&#123;\n    n &#x3D; j\n&#125;\n\n\n\n键盘输入语句\n\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main()&#123;\n\tvar name string\n\tvar age int\n\tvar salary float32\n\tvar isPass bool\n\n\t&#x2F;&#x2F;Sacnln()函数使用。\n\t\n\tfmt.Println(&quot;请输入姓名&quot;)\n\t&#x2F;&#x2F;输入地址，将内容给name变量\n\tfmt.Scanln(&amp;name)\n\t\n\tfmt.Println(&quot;请输入年龄&quot;)\n\tfmt.Scanln(&amp;age)\n\t\n\tfmt.Println(&quot;请输入薪水&quot;)\n\tfmt.Scanln(&amp;salary)\n\t\n\tfmt.Println(&quot;请输入是否通过&quot;)\n\tfmt.Scanln(&amp;isPass)\n\t\n\tfmt.Printf(&quot;结果：name&#x3D;%v,age&#x3D;%v,salary&#x3D;%v,isPass&#x3D;%v&quot;,name,age,salary,isPass)\n\n\t&#x2F;&#x2F;方式二，指定格式输入\n\tfmt.Println(&quot;请输入你的姓名，年龄，薪水，是否通过，使用空格隔开&quot;)\n\tfmt.Scanf(&quot;%s %d %f %t&quot;,&amp;name,&amp;age,&amp;salary,&amp;isPass)\n\tfmt.Printf(&quot;结果：name&#x3D;%v,age&#x3D;%v,salary&#x3D;%v,isPass&#x3D;%v&quot;,name,age,salary,isPass)\n&#125;\n\n\n\n\n进制\n\n程序流程控制\n顺序控制\n\n分支控制\n\n单分支\n\n\n  package main\n  \n  import &quot;fmt&quot;\n  \n  func main() &#123;\n  \tvar age int\n  \tfmt.Println(&quot;请输入年龄&quot;)\n  \tfmt.Scanln(&amp;age)\n  \tif age&gt;18&#123;\n  \t\tfmt.Println(&quot;你的年龄大于18&quot;)\n  \t&#125;\n  &#125;\n  \n  &#96;&#96;&#96;&#96;\n\n* ![image-20220117202209104](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Xoc001&#x2F;photo&#x2F;image-20220117202209104.png)\n\n* ![image-20220117202901541](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Xoc001&#x2F;photo&#x2F;image-20220117202901541.png)\n\n  &#96;&#96;&#96;GO\n  package main\n  \n  import &quot;fmt&quot;\n  \n  func main() &#123;\n  \tif age:&#x3D;20;age&gt;18&#123;\n  \t\tfmt.Println(&quot;年龄大于18&quot;)\n  \t&#125;\n  &#125;\n  \n\n\n双分支\n\n\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\tvar age int\n\tfmt.Println(&quot;请输入年龄&quot;)\n\tfmt.Scanln(&amp;age)\n\tif age&gt;18&#123;\n\t\tfmt.Println(&quot;大于18&quot;)\n\t&#125; else&#123;\n\t\tfmt.Println(&quot;小于18&quot;)\n\t&#125;\n&#125;\n\n\n\n多分支\n\n\n\n\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\tvar b bool &#x3D; true\n\tif b &#x3D;&#x3D; false &#123;\n\t\tfmt.Println(&quot;a&quot;)\n\t&#125; else if b &#123;\n\t\tfmt.Println(&quot;b&quot;)\n\t&#125; else if !b &#123;\n\t\tfmt.Println(&quot;c&quot;)\n\t&#125; else &#123;\n\t\tfmt.Println(&quot;d&quot;)\n\t&#125;\n&#125;\n\n\n\n\n\n循环控制\n\n\nSwitch分支基本介绍\n基本语法\n流程图\n使用细节\ncase&#x2F; which后是一个表达式(即：常量值、变量、一个有返回值的函数都可以)\nfunc main() &#123;\n\tvar key int32 &#x3D;20\n\t&#x2F;&#x2F;使用返回值的函数\n\tswitch test(key) &#123;\n\tcase 10:\n\t\tfmt.Println(&quot;10&quot;)\n\tcase 20:\n\t\tfmt.Println(&quot;20&quot;)\n\tcase 30:\n\t\tfmt.Println(&quot;30&quot;)\n\tdefault:\n\t\tfmt.Println(&quot;abc&quot;)\n\t&#125;\n&#125;\n\ncase后的各个表达式的数据类型，必须要和switch的表达书数据类型一致\n\ncase后面可以带多个表达式，使用逗号间隔。\nfunc main() &#123;\n\tvar key int32 &#x3D;15\n\t&#x2F;&#x2F;使用返回值的函数\n\tswitch key &#123;\n\tcase 10,15,20:\n\t\tfmt.Println(&quot;10&quot;)\n\tcase 30:\n\t\tfmt.Println(&quot;20&quot;)\n\tcase 40:\n\t\tfmt.Println(&quot;30&quot;)\n\tdefault:\n\t\tfmt.Println(&quot;abc&quot;)\n\t&#125;\n&#125;\n\ncase后面的表达式如果是常量值(字面量)，则要求不能重复\n\ncase后面不需要带break，程序匹配到一个case后就会执行对应的代码块，然后退出switch。如果匹配不到则执行switch\n\ndefault语句不是必须的\n\nswitch 后可以不带表达式，类似if–else分支方式来使用\nfunc main() &#123;\n\tvar age int &#x3D;10\n\t&#x2F;&#x2F;switch后面不带表达式，if---else使用\n\tswitch &#123;\n\tcase age&#x3D;&#x3D;10:\n\t\tfmt.Println(&quot;10&quot;)\n\t\tfallthrough\n\tcase age&gt;10 &amp;&amp;age&lt;&#x3D;20:\n\t\tfmt.Println(&quot;20&quot;)\n\tcase age&gt;20&amp;&amp;age&lt;&#x3D;30:\n\t\tfmt.Println(&quot;30&quot;)\n\tdefault:\n\t\tfmt.Println(&quot;aabc&quot;)\n\t&#125;\n&#125;\n\nswitch 后也可以直接声明&#x2F;定义一个变量，分号结束。不推荐\nfunc main() &#123;\n\t&#x2F;&#x2F;使用返回值的函数\n\tswitch m:&#x3D;20; &#123;\n\tcase m&#x3D;&#x3D;10,m&#x3D;&#x3D;20:\n\t\tfmt.Println(&quot;10&quot;)\n\tcase m&#x3D;&#x3D;30:\n\t\tfmt.Println(&quot;20&quot;)\n\tcase m&#x3D;&#x3D;40:\n\t\tfmt.Println(&quot;30&quot;)\n\tdefault:\n\t\tfmt.Println(&quot;abc&quot;)\n\t&#125;\n    &#x2F;&#x2F;运行结果10\n&#125;\n\nswitch 穿透 fallthrough，如果在case语句块后增加fallthrough，则会继续执行下一个case，也叫switch穿透。\nfunc main() &#123;\n\t&#x2F;&#x2F;使用返回值的函数\n\tswitch m:&#x3D;20; &#123;\n\tcase m&#x3D;&#x3D;10,m&#x3D;&#x3D;20:\n\t\tfmt.Println(&quot;10&quot;)\n\t\tfallthrough\n\tcase m&#x3D;&#x3D;30:\n\t\tfmt.Println(&quot;20&quot;)\n\t\tfallthrough\n\tcase m&#x3D;&#x3D;40:\n\t\tfmt.Println(&quot;30&quot;)\n\tdefault:\n\t\tfmt.Println(&quot;abc&quot;)\n\t&#125;\n    &#x2F;&#x2F;运行结果\n    &#x2F;&#x2F;10\n    &#x2F;&#x2F;20\n    &#x2F;&#x2F;30\n&#125;\n\nType Switch ：switch语句可以用于type-switch 来判断某个interface变量中实际指向的变量类型。\n\n\nswitch和if的比较\n如果判断的具体数值不多，而且符合整数、浮点数、字符、字符串这集中类型。建议使用switch，简洁高效\n其他情况：对区间判断和结果为bool类型的判断，使用if，if的适用范围更广泛。\n\nfor循环控制基本语法\n\n\n\nwhile和do-while的实现Go语言中没有while和do-while语法。通过for循环来实现其使用效果\nwhile实现\n&#x2F;&#x2F;while语法实现\nvar i int &#x3D; 1\nfor&#123;\n    if i&gt;10&#123;\n        break\n    &#125;\n    fmt.Println(i)\n    i++\n&#125;\n\n\n\ndo-while实现\n&#x2F;&#x2F;do-while语法实现\nvar j int &#x3D;1\nfor&#123;\n    fmt.Println(j)\n    j++\n    if j&gt;10&#123;\n        break\n    &#125;\n&#125;\n\n\n\n多层循环控制\n打印空心菱形\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\tvar totalLevel int &#x3D; 4\n\n\tfor i :&#x3D; 1; i &lt;&#x3D; totalLevel; i++ &#123;\n\t\tfor k :&#x3D; 1; k &lt;&#x3D; totalLevel-i; k++ &#123;\n\t\t\tfmt.Printf(&quot; &quot;)\n\t\t&#125;\n\t\tfor j :&#x3D; 1; j &lt;&#x3D; i*2-1; j++ &#123;\n\t\t\t&#x2F;&#x2F;空心金字塔\n\t\t\tif j &#x3D;&#x3D; 1 || j &#x3D;&#x3D; 2*i-1&#123;\n\t\t\t\tfmt.Printf(&quot;*&quot;)\n\t\t\t&#125;else&#123;\n\t\t\t\tfmt.Printf(&quot; &quot;)\n\t\t\t&#125;\n\t\t&#125;\n\t\tfmt.Println()\n\t&#125;\n\n\t&#x2F;&#x2F;菱形打印\n\tfor i :&#x3D; totalLevel-1; i &gt;&#x3D; 1; i-- &#123;\n\t\tfor k :&#x3D; 1; k &lt;&#x3D; totalLevel-i; k++ &#123;\n\t\t\tfmt.Printf(&quot; &quot;)\n\t\t&#125;\n\t\tfor j :&#x3D; 1; j &lt;&#x3D; i*2-1; j++ &#123;\n\t\t\t&#x2F;&#x2F;空心金字塔\n\t\t\tif j &#x3D;&#x3D; 1 || j &#x3D;&#x3D; 2*i-1 &#123;\n\t\t\t\tfmt.Printf(&quot;*&quot;)\n\t\t\t&#125;else&#123;\n\t\t\t\tfmt.Printf(&quot; &quot;)\n\t\t\t&#125;\n\n\t\t&#125;\n\t\tfmt.Println()\n\t&#125;\n&#125;\n\n\n\n\n九九乘法表\nfor i:&#x3D;1;i&lt;&#x3D;9;i++&#123;\n    for j:&#x3D;1;j&lt;&#x3D;i;j++&#123;\n        fmt.Printf(&quot;%d * %d &#x3D; %d  &quot;,j,i,j*i)\n    &#125;\n    fmt.Println()\n&#125;\n\n\n\nbreak 语法break语句用于终止某个语句块的执行，用于中断当前for循环或跳出switch语句。\n\n\nbreak 语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层的语句块。\nbreak默认会跳出最近的for循环\nbreak 后面可以指定标签，跳出标签对应的for循环\n\n\ncontinue语句\ncontinue语句用于结束本次循环，继续执行下一次循环。\ncontinue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环，这个和break标签的使用规则一样。\n\n\ngoto语句","slug":"Go语言开发","date":"2022-02-11T04:11:01.854Z","categories_index":"","tags_index":"Go","author_index":"Xoc001"}]