[{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Go语言开发\n程序基本结构一：\n\ngo文件的后缀是.go\n\npackage main : 表示该hello.go文件所的包是main，在go中，每个文件都必须属于一个包。\n\nimport “fmt”  : 表示引入一个包，包名 fmt，引入该包后，就可以使用fmt包的函数。\n\nfunc main(){\n}\nfunc 是一个关键字，表示一个函数。\nmain是函数名，是一个主函数。\n\nfmt.Println(“hello”) 表示调用fmt包的Println函数 输出hello。\n\n\n二：通过 go build 文件名.go命令对该go文件编译，生成.exe文件。\n三：运行文件名.exe文件。\n\n四：通过  go run 命令可以直接运行hello.go程序。\n执行流程分析\n如果是对源码编译后，再执行的流程。\n\n对源码直接go run 的运行流程\n\n两种执行流程方式的区别\n\n\n\nGo语言开发注意事项\nGo语言常用转义字符\n\\t：表示一个制表符，可以用来排版\n\\n：换行符\n\\\\：一个\\\n\\“ :一个”\n\\r : 一个回车\n\nDos命令\n删除目录及下面的文件，不询问\n\n删除目录及下面的文件，询问\n\n\n变量\n指定变量类型，声明后若不赋值，使用默认值\n根据值自行判定变量类型(类型推导)\n省略var  , 使用:= 等价于var nume string   name = &quot;tom&quot;\n多变量声明\n\n\n\n全局变量：定义在main方法外\n\n&#x2F;&#x2F;定义全局变量\nvar n1 &#x3D; 100\nvar n2 &#x3D; 200\nvar n3 &#x3D; 300\n&#x2F;&#x2F;上面的声明方式，可以改成一次性声明\nvar(\n    n4 &#x3D; 100\n    n5 &#x3D; &quot;hello&quot;\n)\n\n\n该区域的数据值可以在同一类型范围内不断变化\n变量在同一个作用域内不能重名\n变量&#x3D;变量名+值+数据类型\n默认值 int为0，string为空串\n\n变量的数据类型\n\n在程序中查看某个变量的字节大小和数据类型。\nfunc main() &#123;\n\tvar i int\n\ti&#x3D;100\n\tfmt.Printf(&quot;i变量的类型 %T \\n&quot;,i)\n\tvar j int64 &#x3D;10\n\tfmt.Printf(&quot;j变量的类型 %T,j所占的字节大小 %d&quot;,i,unsafe.Sizeof(j))\n&#125;\n\n\n浮点型\n浮点数在机器中存放形式为：浮点数&#x3D;符号位+指数位+尾数位\n浮点数都是有符号的。\n尾数部分可能丢失，造成精度损失。\n字符类型Go中没有专门的字符类型，需要保存到byte中\n字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。也就是说对于传统的字符串是由字符组成的，而Go的字符串不同，它是由字节组成的。\n\n\n\n如果保存的字符存在于ASCII表中，则可以直接保存到byte\n如果保存的字符的码值大于255，这时需要使用int类型保存\n需要按照字符的方式输出，需要格式化输出，使用fmt.Printf(&quot;%c&quot;,c1)\n\n\n布尔类型\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;unsafe&quot;\n)\n\nfunc main() &#123;\n\tvar flag bool &#x3D; true\n\tfmt.Println(flag)\n\t&#x2F;&#x2F;查看所占存储空间\n\tfmt.Println(&quot;所占存储空间&quot;,unsafe.Sizeof(flag))\n&#125;\n\n\n\n\n字符串类型\n字符串一旦赋值，就不能修改。字符串在Go中是不可变的。\n字符串的两种表示形式\n双引号，会识别转义字符\n反引号&#96;&#96;，以字符串的原生形式输出，包括换行和特殊字符，可以实现防止攻击、输出源代码的效果\n\n\n\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;unsafe&quot;\n)\n\nfunc main() &#123;\n\tvar str1 string &#x3D; &quot;hello&quot;\n\tfmt.Println(str1)\n\tfmt.Println(&quot;str1的存储大小&quot;,unsafe.Sizeof(str1))\n\n\tvar str2 string &#x3D;&quot;abc\\nabce&quot;\n\tfmt.Println(str2)\n\tvar str3 string &#x3D; &#96;package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;unsafe&quot;\n)\n\nfunc main() &#123;\n\tvar str1 string &#x3D; &quot;hello&quot;\n\tfmt.Println(str1)\n\tfmt.Println(&quot;str1的存储大小&quot;,unsafe.Sizeof(str1))\n\n\tvar str2 string &#x3D;&quot;abc\\nabce&quot;\n\tfmt.Println(str2)\n\tvar str3 string &#x3D; &quot;&quot;\n&#125;\n&#96;\n\tfmt.Println(str3)\n\n\t&#x2F;&#x2F;字符串的拼接\n\tvar str4 &#x3D; &quot;Hello&quot; + &quot;world&quot;\n\tfmt.Println(str4)\n\t&#x2F;&#x2F;连续换行拼接，需要将+号写在上一行的结尾\n\tvar str5 &#x3D; &quot;Hello&quot; +&quot; world&quot; +&quot;Hello&quot; +\n\t\t&quot; world&quot; + &quot;Hello&quot; +&quot; world&quot; +\n\t\t&quot;Hello&quot; +&quot; world&quot;\n\tfmt.Println(str5)\n\n\t&#x2F;&#x2F;&#x2F;基本数据类型的默认值\n\tvar a int\n\tvar b float32\n\tvar c float64\n\tvar flag bool\n\tvar name string\n\t&#x2F;&#x2F;格式化输出\n\tfmt.Printf(&quot;a&#x3D;%d,b&#x3D;%f,c&#x3D;%v,flag&#x3D;%v,name&#x3D;%v&quot;,a,b,c,flag,name)\n&#125;\n\n\n基本数据类型的转换\nGo在不同类型之间的赋值需要显式转换。不能自动转换\n\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\tvar i int32 &#x3D; 100\n\tvar n1 float32 &#x3D; float32(i)\n\tvar n2 int8 &#x3D; int8(i)\n\tvar n3 int64 &#x3D; int64(i)\n\n\tfmt.Printf(&quot;n1&#x3D;%f,n2&#x3D;%d,n3&#x3D;%d&quot;,n1,n2,n3)\n&#125;\n\n\n\n注意事项\n\n基本数据类型和String的转换\n方法1：使用fmt.Sprintf()函数\n\n方式2：使用strconv包的函数。\nfunc FormatBool(b bool) string\nfunc FormatInt(i int64, base int) string\nfunc FormatUint(i uint64, base int) string\nfunc FormatFloat(f float64, fmt byte, prec, bitSize int) string\n\n\n\n\n相关代码\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;strconv&quot;\n)\n\nfunc main() &#123;\n\tvar n1 int &#x3D;100\n\tvar n2 float64 &#x3D;23.123\n\tvar flag bool &#x3D;true\n\tvar b byte &#x3D;&#39;a&#39;\n\tvar str string\n\n\t&#x2F;&#x2F;第一种方法，使用fmt包中的函数\n\tstr &#x3D; fmt.Sprintf(&quot;%d&quot;,n1)\n\tfmt.Printf(&quot;str type %T str&#x3D;%q\\n&quot;,str,str)\n\n\tstr &#x3D; fmt.Sprintf(&quot;%f&quot;,n2)\n\tfmt.Printf(&quot;str type %T str&#x3D;%q\\n&quot;,str,str)\n\n\tstr &#x3D; fmt.Sprintf(&quot;%t&quot;,flag)\n\tfmt.Printf(&quot;str type %T str&#x3D;%q\\n&quot;,str,str)\n\n\tstr &#x3D; fmt.Sprintf(&quot;%c&quot;,b)\n\tfmt.Printf(&quot;str type %T str&#x3D;%q\\n&quot;,str,str)\n\n\t&#x2F;&#x2F;第二种方法，使用strconv包中的函数\n\tvar num1 int &#x3D; 99\n\tvar num2 float64 &#x3D; 32.1212\n\tvar flag2 bool &#x3D;true\n\n\tstr &#x3D; strconv.FormatInt(int64(num1),10)\n\tfmt.Printf(&quot;str type %T str&#x3D;%q\\n&quot;,str,str)\n\n\tstr &#x3D; strconv.FormatFloat(num2,&#39;f&#39;,10,64)\n\tfmt.Printf(&quot;str type %T str&#x3D;%q\\n&quot;,str,str)\n\n\tstr &#x3D; strconv.FormatBool(flag2)\n\tfmt.Printf(&quot;str type %T str&#x3D;%q\\n&quot;,str,str)\n&#125;\n\n\n\nString类型转基本数据类型\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;strconv&quot;\n)\n\nfunc main() &#123;\n\t&#x2F;&#x2F;String 转int\n\tvar str string &#x3D;&quot;123747&quot;\n\tvar n1 int64\n\tn1,_ &#x3D; strconv.ParseInt(str,10,64)\n\tfmt.Printf(&quot;n1 type&#x3D; %T n1&#x3D;%d \\n&quot;,n1,n1)\n\n\t&#x2F;&#x2F;String 转float\n\tvar str1 string &#x3D; &quot;123.4567&quot;\n\tvar n2 float64\n\tn2,_ &#x3D; strconv.ParseFloat(str1,64)\n\tfmt.Printf(&quot;n2 type&#x3D;%T n2&#x3D;%f\\n&quot;,n2,n2)\n\n\t&#x2F;&#x2F;String 转 bool\n\tvar str2 string &#x3D;&quot;true&quot;\n\tvar flag bool\n\tflag,_ &#x3D; strconv.ParseBool(str2)\n\tfmt.Printf(&quot;flag type&#x3D;%T flag&#x3D;%t&quot;,flag,flag)\n&#125;\n\n\n\n要确保String类型可以转成有效数据。无效数据直接转换成0，或者默认值。bool-&gt;false\n\n指针\n基本数据类型，变量存的就是值，也叫值类型\n获取变量的地址，用&amp;\n指针类型，指针变量存的是一个地址，这个地址指向的空间存的才是值。\n获取指针类型所指向的值，使用*\n\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\tvar n1 int &#x3D; 100\n\t&#x2F;&#x2F;使用&amp;取地址\n\tfmt.Printf(&quot;n1的地址为:%v \\n&quot;,&amp;n1)\n\t&#x2F;&#x2F;将n1变量的地址赋值给ptr指针变量\n\tvar ptr * int &#x3D; &amp;n1\n\t&#x2F;&#x2F;输出ptr指针变量中的内容\n\tfmt.Printf(&quot;ptr的地址为:%v \\n&quot;,ptr)\n\t&#x2F;&#x2F;输出ptr指针内容所对应地址的值。\n\tfmt.Printf(&quot;ptr指针指向的值为：%d&quot;,*ptr)\n&#125;\n\n\n\n值类型和引用类型\n值类型：基本数据类型，数组和结构体struct\n引用类型：指针、slice切片、map、管道chan、interface等都是引用类型\n\n\n\n值类型：变量直接存储值、内存通常在栈中分配。\n引用类型: 变量存储得是一个地址，这个地址对应的空间才真正存储数据(值)，内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，会被GC回收\n\n\n标识符命名规范\n\n\n代码示例\n\npackage main\n\nimport (\n\t&quot;GoProject&#x2F;src&#x2F;Study03&#x2F;demo13&#x2F;model&quot;\n\t&quot;fmt&quot;\n)\nfunc main() &#123;\n\tfmt.Println(model.HeroName)\n&#125;\n\n\npackage model\n\nvar HeroName string &#x3D;&quot;adfadf&quot;\n\n\n预定义标识符 \n运算符\n\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 除法运算符。说明：如果运算的数都是整数，那么除后，去掉小数部分，保留整数部分\n\tfmt.Println(10 &#x2F; 4)\n\n\t&#x2F;&#x2F;如果希望有小数部分，需要使用浮点数参与运算。\n\tfmt.Println(10.0 &#x2F; 4)\n\n\t&#x2F;&#x2F; 演示取余运算的使用\n\t&#x2F;&#x2F; a % b &#x3D; a - a &#x2F; b * b\n\tfmt.Println(10 % 3)   &#x2F;&#x2F;1\n\tfmt.Println(-10 % 3)  &#x2F;&#x2F; -1\n\tfmt.Println(10 % -3)  &#x2F;&#x2F;1\n\tfmt.Println(-10 % -3) &#x2F;&#x2F;-1\n\n\tvar i int &#x3D; 10\n\ti++\n\tfmt.Println(&quot;i&#x3D;&quot;,i)\n\ti--\n\tfmt.Println(&quot;i&#x3D;&quot;,i)\n\n&#125;\n\n\n运算符使用的注意事项\n关系运算符 \n\n逻辑运算符\n\n赋值运算符\n运算符的优先级\n特别说明Go语言明确不支持三元运算符。\n&#x2F;&#x2F;n &#x3D; i &gt; j? i:j\nif i&gt;j&#123;\n    n &#x3D; i\n&#125; else&#123;\n    n &#x3D; j\n&#125;\n\n\n\n键盘输入语句\n\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main()&#123;\n\tvar name string\n\tvar age int\n\tvar salary float32\n\tvar isPass bool\n\n\t&#x2F;&#x2F;Sacnln()函数使用。\n\t\n\tfmt.Println(&quot;请输入姓名&quot;)\n\t&#x2F;&#x2F;输入地址，将内容给name变量\n\tfmt.Scanln(&amp;name)\n\t\n\tfmt.Println(&quot;请输入年龄&quot;)\n\tfmt.Scanln(&amp;age)\n\t\n\tfmt.Println(&quot;请输入薪水&quot;)\n\tfmt.Scanln(&amp;salary)\n\t\n\tfmt.Println(&quot;请输入是否通过&quot;)\n\tfmt.Scanln(&amp;isPass)\n\t\n\tfmt.Printf(&quot;结果：name&#x3D;%v,age&#x3D;%v,salary&#x3D;%v,isPass&#x3D;%v&quot;,name,age,salary,isPass)\n\n\t&#x2F;&#x2F;方式二，指定格式输入\n\tfmt.Println(&quot;请输入你的姓名，年龄，薪水，是否通过，使用空格隔开&quot;)\n\tfmt.Scanf(&quot;%s %d %f %t&quot;,&amp;name,&amp;age,&amp;salary,&amp;isPass)\n\tfmt.Printf(&quot;结果：name&#x3D;%v,age&#x3D;%v,salary&#x3D;%v,isPass&#x3D;%v&quot;,name,age,salary,isPass)\n&#125;\n\n\n\n\n进制\n\n程序流程控制\n顺序控制\n\n分支控制\n\n单分支\n\n\n\n&#96;&#96;&#96;&#96;gopackage main\nimport “fmt”\nfunc main() {var age intfmt.Println(“请输入年龄”)fmt.Scanln(&amp;age)if age&gt;18{    fmt.Println(“你的年龄大于18”)}}\n\n    * ![image-20220117202209104](Go语言开发.assets&#x2F;image-20220117202209104.png)\n\n    * ![image-20220117202901541](Go语言开发.assets&#x2F;image-20220117202901541.png)\n\n    * &#96;&#96;&#96;GO\n      package main\n      \n      import &quot;fmt&quot;\n      \n      func main() &#123;\n      \tif age:&#x3D;20;age&gt;18&#123;\n      \t\tfmt.Println(&quot;年龄大于18&quot;)\n      \t&#125;\n      &#125;\n      \n      &#96;&#96;&#96;\n\n  * 双分支\n\n    * ![image-20220117204631898](Go语言开发.assets&#x2F;image-20220117204631898.png)\n\n    * &#96;&#96;&#96;go\n      package main\n      \n      import &quot;fmt&quot;\n      \n      func main() &#123;\n      \tvar age int\n      \tfmt.Println(&quot;请输入年龄&quot;)\n      \tfmt.Scanln(&amp;age)\n      \tif age&gt;18&#123;\n      \t\tfmt.Println(&quot;大于18&quot;)\n      \t&#125; else&#123;\n      \t\tfmt.Println(&quot;小于18&quot;)\n      \t&#125;\n      &#125;\n      \n      &#96;&#96;&#96;\n\n  * 多分支\n\n    * ![image-20220117222510430](Go语言开发.assets&#x2F;image-20220117222510430.png)\n\n    * ![image-20220117222528417](Go语言开发.assets&#x2F;image-20220117222528417.png)\n\n    * &#96;&#96;&#96;go\n      package main\n      \n      import &quot;fmt&quot;\n      \n      func main() &#123;\n      \tvar b bool &#x3D; true\n      \tif b &#x3D;&#x3D; false &#123;\n      \t\tfmt.Println(&quot;a&quot;)\n      \t&#125; else if b &#123;\n      \t\tfmt.Println(&quot;b&quot;)\n      \t&#125; else if !b &#123;\n      \t\tfmt.Println(&quot;c&quot;)\n      \t&#125; else &#123;\n      \t\tfmt.Println(&quot;d&quot;)\n      \t&#125;\n      &#125;\n      \n      &#96;&#96;&#96;\n\n* 循环控制\n\n\n\n### Switch分支\n\n#### 基本介绍\n\n![](Go语言开发.assets&#x2F;image-20220118190039691.png)\n\n#### 基本语法\n\n![image-20220118190324288](Go语言开发.assets&#x2F;image-20220118190324288.png)\n\n#### 流程图\n\n![image-20220118190422876](Go语言开发.assets&#x2F;image-20220118190422876.png)\n\n#### 使用细节\n\n* case&#x2F; which后是一个表达式(即：常量值、变量、一个有返回值的函数都可以)\n\n  * &#96;&#96;&#96;go\n    func main() &#123;\n    \tvar key int32 &#x3D;20\n    \t&#x2F;&#x2F;使用返回值的函数\n    \tswitch test(key) &#123;\n    \tcase 10:\n    \t\tfmt.Println(&quot;10&quot;)\n    \tcase 20:\n    \t\tfmt.Println(&quot;20&quot;)\n    \tcase 30:\n    \t\tfmt.Println(&quot;30&quot;)\n    \tdefault:\n    \t\tfmt.Println(&quot;abc&quot;)\n    \t&#125;\n    &#125;\n    &#96;&#96;&#96;\n\n* case后的各个表达式的数据类型，必须要和switch的表达书数据类型一致\n\n* case后面可以带多个表达式，使用逗号间隔。\n\n  * &#96;&#96;&#96;&#96;go\n    func main() &#123;\n    \tvar key int32 &#x3D;15\n    \t&#x2F;&#x2F;使用返回值的函数\n    \tswitch key &#123;\n    \tcase 10,15,20:\n    \t\tfmt.Println(&quot;10&quot;)\n    \tcase 30:\n    \t\tfmt.Println(&quot;20&quot;)\n    \tcase 40:\n    \t\tfmt.Println(&quot;30&quot;)\n    \tdefault:\n    \t\tfmt.Println(&quot;abc&quot;)\n    \t&#125;\n    &#125;\n\n\n\n\ncase后面的表达式如果是常量值(字面量)，则要求不能重复\n\ncase后面不需要带break，程序匹配到一个case后就会执行对应的代码块，然后退出switch。如果匹配不到则执行switch\n\ndefault语句不是必须的\n\nswitch 后可以不带表达式，类似if–else分支方式来使用\n\n&#96;&#96;&#96;&#96;gofunc main() {var age int &#x3D;10&#x2F;&#x2F;switch后面不带表达式，if—else使用switch {case age&#x3D;&#x3D;10:    fmt.Println(“10”)    fallthroughcase age&gt;10 &amp;&amp;age&lt;&#x3D;20:    fmt.Println(“20”)case age&gt;20&amp;&amp;age&lt;&#x3D;30:    fmt.Println(“30”)default:    fmt.Println(“aabc”)}}\n* switch 后也可以直接声明&#x2F;定义一个变量，分号结束。**不推荐**\n\n  * &#96;&#96;&#96;go\n    func main() &#123;\n    \t&#x2F;&#x2F;使用返回值的函数\n    \tswitch m:&#x3D;20; &#123;\n    \tcase m&#x3D;&#x3D;10,m&#x3D;&#x3D;20:\n    \t\tfmt.Println(&quot;10&quot;)\n    \tcase m&#x3D;&#x3D;30:\n    \t\tfmt.Println(&quot;20&quot;)\n    \tcase m&#x3D;&#x3D;40:\n    \t\tfmt.Println(&quot;30&quot;)\n    \tdefault:\n    \t\tfmt.Println(&quot;abc&quot;)\n    \t&#125;\n        &#x2F;&#x2F;运行结果10\n    &#125;\n    &#96;&#96;&#96;\n\n* switch 穿透 &#96;fallthrough&#96;，如果在case语句块后增加&#96;fallthrough&#96;，则会继续执行下一个case，也叫switch穿透。\n\n  * &#96;&#96;&#96;go\n    func main() &#123;\n    \t&#x2F;&#x2F;使用返回值的函数\n    \tswitch m:&#x3D;20; &#123;\n    \tcase m&#x3D;&#x3D;10,m&#x3D;&#x3D;20:\n    \t\tfmt.Println(&quot;10&quot;)\n    \t\tfallthrough\n    \tcase m&#x3D;&#x3D;30:\n    \t\tfmt.Println(&quot;20&quot;)\n    \t\tfallthrough\n    \tcase m&#x3D;&#x3D;40:\n    \t\tfmt.Println(&quot;30&quot;)\n    \tdefault:\n    \t\tfmt.Println(&quot;abc&quot;)\n    \t&#125;\n        &#x2F;&#x2F;运行结果\n        &#x2F;&#x2F;10\n        &#x2F;&#x2F;20\n        &#x2F;&#x2F;30\n    &#125;\n    &#96;&#96;&#96;\n\n* Type Switch ：switch语句可以用于type-switch 来判断某个interface变量中实际指向的变量类型。\n\n\n\n### switch和if的比较\n\n* 如果判断的具体数值不多，而且符合整数、浮点数、字符、字符串这集中类型。建议使用switch，简洁高效\n* 其他情况：对区间判断和结果为bool类型的判断，使用if，if的适用范围更广泛。\n\n\n\n### for循环控制\n\n#### 基本语法\n\n![image-20220120231508752](Go语言开发.assets&#x2F;image-20220120231508752.png)\n\n![image-20220120232758266](Go语言开发.assets&#x2F;image-20220120232758266.png)\n\n![image-20220122175044471](Go语言开发.assets&#x2F;image-20220122175044471.png)\n\n![image-20220122180219648](Go语言开发.assets&#x2F;image-20220122180219648.png)\n\n\n\n\n\n### while和do-while的实现\n\nGo语言中没有while和do-while语法。**通过for循环来实现其使用效果**\n\n#### while实现\n\n![image-20220122190429492](Go语言开发.assets&#x2F;image-20220122190429492.png)\n\n&#96;&#96;&#96;&#96;go\n&#x2F;&#x2F;while语法实现\nvar i int &#x3D; 1\nfor&#123;\n    if i&gt;10&#123;\n        break\n    &#125;\n    fmt.Println(i)\n    i++\n&#125;\n\n\n\ndo-while实现\n&#x2F;&#x2F;do-while语法实现\nvar j int &#x3D;1\nfor&#123;\n    fmt.Println(j)\n    j++\n    if j&gt;10&#123;\n        break\n    &#125;\n&#125;\n\n\n\n多层循环控制\n打印空心菱形\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\tvar totalLevel int &#x3D; 4\n\n\tfor i :&#x3D; 1; i &lt;&#x3D; totalLevel; i++ &#123;\n\t\tfor k :&#x3D; 1; k &lt;&#x3D; totalLevel-i; k++ &#123;\n\t\t\tfmt.Printf(&quot; &quot;)\n\t\t&#125;\n\t\tfor j :&#x3D; 1; j &lt;&#x3D; i*2-1; j++ &#123;\n\t\t\t&#x2F;&#x2F;空心金字塔\n\t\t\tif j &#x3D;&#x3D; 1 || j &#x3D;&#x3D; 2*i-1&#123;\n\t\t\t\tfmt.Printf(&quot;*&quot;)\n\t\t\t&#125;else&#123;\n\t\t\t\tfmt.Printf(&quot; &quot;)\n\t\t\t&#125;\n\t\t&#125;\n\t\tfmt.Println()\n\t&#125;\n\n\t&#x2F;&#x2F;菱形打印\n\tfor i :&#x3D; totalLevel-1; i &gt;&#x3D; 1; i-- &#123;\n\t\tfor k :&#x3D; 1; k &lt;&#x3D; totalLevel-i; k++ &#123;\n\t\t\tfmt.Printf(&quot; &quot;)\n\t\t&#125;\n\t\tfor j :&#x3D; 1; j &lt;&#x3D; i*2-1; j++ &#123;\n\t\t\t&#x2F;&#x2F;空心金字塔\n\t\t\tif j &#x3D;&#x3D; 1 || j &#x3D;&#x3D; 2*i-1 &#123;\n\t\t\t\tfmt.Printf(&quot;*&quot;)\n\t\t\t&#125;else&#123;\n\t\t\t\tfmt.Printf(&quot; &quot;)\n\t\t\t&#125;\n\n\t\t&#125;\n\t\tfmt.Println()\n\t&#125;\n&#125;\n\n\n\n\n九九乘法表\nfor i:&#x3D;1;i&lt;&#x3D;9;i++&#123;\n    for j:&#x3D;1;j&lt;&#x3D;i;j++&#123;\n        fmt.Printf(&quot;%d * %d &#x3D; %d  &quot;,j,i,j*i)\n    &#125;\n    fmt.Println()\n&#125;\n\n\n\nbreak 语法break语句用于终止某个语句块的执行，用于中断当前for循环或跳出switch语句。\n\n\nbreak 语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层的语句块。\nbreak默认会跳出最近的for循环\nbreak 后面可以指定标签，跳出标签对应的for循环\n\n\ncontinue语句\ncontinue语句用于结束本次循环，继续执行下一次循环。\ncontinue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环，这个和break标签的使用规则一样。\n\n\ngoto语句","slug":"Go语言开发","date":"2022-02-10T17:38:23.912Z","categories_index":"","tags_index":"","author_index":"Xoc001"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"SpringMVC2021年8月15日\nssm:mybatis+Spring + SpringMVC  MVC三层架构\n1、MVC1.1、什么是MVC\nMVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。\n是将业务逻辑、数据、显示分离的方法来组织代码。\nMVC主要作用是降低了视图与业务逻辑间的双向偶合。\nMVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。\n\nModel（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。\nView（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。\nController（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。\n最典型的MVC就是JSP + servlet + javabean的模式。\n1.2、什么是SpringMVCSpring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。\n查看官方文档：https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web\n我们为什么要学习SpringMVC呢?\n Spring MVC的特点：\n\n轻量级，简单易学\n高效 , 基于请求响应的MVC框架\n与Spring兼容性好，无缝结合\n约定优于配置\n功能强大：RESTful、数据验证、格式化、本地化、主题等\n简洁灵活\n\nSpring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。\nDispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁；\n正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用Spring IoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……\n1.3、中心控制器​    Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。\n\nSpringMVC的原理如下图所示：\n​    当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。\n\n\n2、第一个SpringMVC程序配置版创建SpringMVC程序\n配置web.xml\n&lt;!--    配置DispatcherServlet 这是SPring MVC的核心，请求分发器--&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n    &lt;&#x2F;servlet&gt;\n\n&lt;!--     在Spring MVC中,  &#x2F;  &#x2F;*\n        &#x2F;:只匹配所有的请求，不会去匹配JSP页面\n        &#x2F;* ：匹配所有的请求，包括jsp页面\n\n--&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;\n        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;servlet-mapping&gt;\n\n\n\n\n编写springmvc-servlet.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\n&lt;&#x2F;beans&gt;\n\n\n\n\n添加处理映射器\n添加处理适配器\n添加视图解析器\n\n&lt;!--    处理器映射器--&gt;\n    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&#x2F;&gt;\n&lt;!--    处理器适配器--&gt;\n    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&#x2F;&gt;\n&lt;!--    视图解析器 : 模板引擎--&gt;\n    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id&#x3D;&quot;InternalResourceViewResolver&quot;&gt;\n        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;bean id&#x3D;&quot;&#x2F;test&quot; class&#x3D;&quot;my.HelloController&quot;&#x2F;&gt;\n\n\n\n创建操作业务类，实现Controller接口\npublic class HelloController implements Controller &#123;\n    @Override\n    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;\n        ModelAndView mv &#x3D; new ModelAndView();\n\n        String result &#x3D; &quot;HelloSpringMVC!&quot;;\n        mv.addObject(&quot;msg&quot;,result);\n\n        mv.setViewName(&quot;test&quot;);\n\n        return mv;\n    &#125;\n&#125;\n\n\n\n注册bean\n&lt;bean id&#x3D;&quot;&#x2F;test&quot; class&#x3D;&quot;my.HelloController&quot;&#x2F;&gt;\n\n\n\n编写需要跳转的视图界面\n\n测试。\n\n\n注解创建SpringMVC程序\n配置web.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;\n         version&#x3D;&quot;4.0&quot;&gt;\n\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;\n    &lt;&#x2F;servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;\n        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;servlet-mapping&gt;\n\n&lt;&#x2F;web-app&gt;\n\n&#x2F; 和 &#x2F;* 的区别：\n&lt; url-pattern &gt; &#x2F; &lt;&#x2F; url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。\n&lt; url-pattern &gt; &#x2F;* &lt;&#x2F; url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。\n\n\n注意web.xml版本问题，要最新版！\n注册DispatcherServlet\n关联SpringMVC的配置文件\n启动级别为1\n映射路径为 &#x2F; 【不要用&#x2F;*，会404】\n\n\n\n\n配置spring-servlet.xml\n&lt;!--自动扫描包--&gt;\n    &lt;context:component-scan base-package&#x3D;&quot;my&quot;&#x2F;&gt;\n&lt;!--    Spring mvc 不处理静态资源--&gt;\n    &lt;mvc:default-servlet-handler&#x2F;&gt;\n\n&lt;!--    支持MVC注解驱动--&gt;\n    &lt;mvc:annotation-driven&#x2F;&gt;\n\n&lt;!--    视图适配器--&gt;\n    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id&#x3D;&quot;internalResourceViewResolver&quot;&gt;\n        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n\n\n\n创建Controller 类\npackage my;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class HelloController &#123;\n\n    @RequestMapping(&quot;&#x2F;hello&quot;)\n    public String hello(Model model)&#123;\n        model.addAttribute(&quot;msg&quot;,&quot;Hello,SpringMVC Annotation!&quot;);\n        return &quot;hello&quot;;\n    &#125;\n&#125;\n\n\n\n@Controller是为了让Spring IOC容器初始化时自动扫描到；\n@RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是&#x2F;HelloController&#x2F;hello；\n方法中声明Model类型的参数是为了把Action中的数据带到视图中；\n方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF&#x2F;jsp&#x2F;hello.jsp。\n\n\n编写jsp页面\n\n测试\n\n\n3、控制器 Controller1.实现Controller 接口Controller 是一个接口，接口中只有一个方法\n@FunctionalInterface\npublic interface Controller &#123;\n    @Nullable\n    ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;\n&#125;\n\n\n\n测试\n新建Moudle\n\n编写ControllerTest类，实现Controller接口\npackage my;\n\n\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.mvc.Controller;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class ControllerTest1 implements Controller &#123;\n    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;\n        ModelAndView mv &#x3D; new ModelAndView();\n        mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);\n\n        mv.setViewName(&quot;test&quot;);\n        return mv;\n    &#125;\n&#125;\n\n\n\n\n在Spring 配置文件中配置bean；name对应请求路径，class对应处理类路径。\n&lt;bean id&#x3D;&quot;&#x2F;test1&quot; class&#x3D;&quot;my.ControllerTest1&quot;&#x2F;&gt;\n\n编写前端界面\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n$&#123;msg&#125;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n测试\n\n\n说明：\n\n实现接口Controller定义控制器是较老的办法\n缺点：一个控制器中只有一个方法，需要多个方法则需要多个控制器，定义麻烦。\n\n2.使用注解@Controller\n@Controller注解类型用于声明Spring类的实例是一个控制器\nSpring可以用扫描机制扫描应用程序下所有基于注解的类，为了保证可以扫描到控制器，需要在Spring配置文件中设置扫描的包路径。\n\n测试\n创建ControllerTest2类\npackage my;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class ControllerTest2 &#123;\n    @RequestMapping(&quot;&#x2F;test2&quot;)\n    public String test2(Model model)&#123;\n\n        model.addAttribute(&quot;msg&quot;,&quot;Hello ControllerTest2&quot;);\n\n        return &quot;test&quot;;\n    &#125;\n\n\n    @RequestMapping(&quot;&#x2F;test3&quot;)\n    public String test3(Model model)&#123;\n        model.addAttribute(&quot;msg&quot;,&quot;ControllerTest3&quot;);\n\n        return &quot;test&quot;;\n    &#125;\n&#125;\n\n\n\n\n在Spring配置中实现自动扫描指定的包\n&lt;!--自动扫描包--&gt;\n&lt;context:component-scan base-package&#x3D;&quot;my&quot;&#x2F;&gt;\n\n\n\n测试\n\n\n3.RequestMapping\n@RequestMapping 注解用于映射url到控制器类或一个特定的处理程序方法，可用于类上或方法上。用于类上，表示类中所有的相应请求的方法都是以该路径作为父路径。\n\n只注解在方法上面\n@RequestMapping(&quot;&#x2F;test2&quot;)\npublic String test2(Model model)&#123;\n  \n    model.addAttribute(&quot;msg&quot;,&quot;Hello ControllerTest2&quot;);\n  \n    return &quot;test&quot;;\n&#125;\n\n实现路径为：”http://localhost:8080/ 项目名 &#x2F;test2”\n\n注解在类上面\n@Controller\n@RequestMapping(&quot;&#x2F;hello&quot;)\npublic class ControllerTest3 &#123;\n\n    @RequestMapping(&quot;&#x2F;t1&quot;)\n    public String test1(Model model)&#123;\n        model.addAttribute(&quot;msg&quot;,&quot;RequestMapping  Test1!&quot;);\n\n        return &quot;test&quot;;\n    &#125;\n&#125;\n\n\n实现路径为：http://localhost:8080/项目名 &#x2F;hello&#x2F;t1\n&#x3D;&#x3D;需要先指定类的路径在指定方法的路径。&#x3D;&#x3D;\n\n\n4、RestFul 风格概念Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，知识一种风格。基于这个风格设计的软件可以更简洁，更有层次，更容易实现缓存等机制。\n功能资源：互联网所有的事物都可以被抽象为资源\n资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。分别对应：添加，删除，修改，查询。\n传统方式操作资源  ：通过不同的参数来实现不同的效果！方法单一，post 和 get\n​    http://127.0.0.1/item/queryItem.action?id=1 查询,GET\n​    http://127.0.0.1/item/saveItem.action 新增,POST\n​    http://127.0.0.1/item/updateItem.action 更新,POST\n​    http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST\n使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！\n​    http://127.0.0.1/item/1 查询,GET\n​    http://127.0.0.1/item 新增,POST\n​    http://127.0.0.1/item 更新,PUT\n​    http://127.0.0.1/item/1 删除,DELETE\n测试\n新建RestfulController 类\n@Controller\npublic class RestFulController &#123;\n\n&#125;\n\n\n\n\n在参数中使用@pathVariable注解，让方法参数的值对应绑定到一个URI模型板的变量上。\n@Controller\npublic class RestFulController &#123;\n\n    @RequestMapping(value &#x3D; &quot;&#x2F;abc&#x2F;&#123;a&#125;&#x2F;&#123;b&#125;&quot;, method &#x3D; RequestMethod.GET)\n    public String index(@PathVariable int a, @PathVariable int b, Model model)&#123;\n\n        int sum &#x3D; a+b;\n        model.addAttribute(&quot;msg&quot;,&quot;结果为：&quot; + sum);\n\n        return &quot;test&quot;;\n    &#125;\n&#125;\n\n\n测试\n\n\n使用路径变量的好处\n使路径变的更加简洁\n获得参数更加方便，框架会自动进行类型转换\n通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法。\n\n参数测试@Controller\npublic class RestFulController &#123;\n\n    @RequestMapping(value &#x3D; &quot;&#x2F;abc&#x2F;&#123;a&#125;&#x2F;&#123;b&#125;&quot;, method &#x3D; RequestMethod.GET)\n    public String index(@PathVariable int a, @PathVariable int b, Model model)&#123;\n\n        int sum &#x3D; a+b;\n        model.addAttribute(&quot;msg&quot;,&quot;结果为：&quot; + sum);\n\n        return &quot;test&quot;;\n    &#125;\n&#125;\n\n&#x3D;&#x3D;路径：localhost:8080&#x2F;demo04&#x2F;abc&#x2F;123&#x2F;1211&#x3D;&#x3D;\n\n使用method属性指定请求类型&#x3D;&#x3D;用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如：GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE、TRACE等。&#x3D;&#x3D;\n@Controller\npublic class RestFulController &#123;\n\n    @RequestMapping(value &#x3D; &quot;&#x2F;abc&#x2F;&#123;a&#125;&#x2F;&#123;b&#125;&quot;, method &#x3D; RequestMethod.GET)\n    public String index(@PathVariable int a, @PathVariable int b, Model model)&#123;\n\n        int sum &#x3D; a+b;\n        model.addAttribute(&quot;msg&quot;,&quot;结果为：&quot; + sum);\n\n        return &quot;test&quot;;\n    &#125;\n&#125;\n\n\n\n\n\n小结Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。\n所有的地址栏请求默认都会是 HTTP GET 类型的。\n方法级别的注解变体有如下几个：组合注解\n@GetMapping\n@PostMapping\n@PutMapping\n@DeleteMapping\n@PatchMapping\n\n@GetMapping 是一个组合注解，平时使用的会比较多！\n它所扮演的是 @RequestMapping(method &#x3D;RequestMethod.GET) 的一个快捷方式。\n5、Spring MVC重定向通过SpringMVC来实现转发和重定向-无需视图解析器：\n@Controller\npublic class ModelTest1 &#123;\n    \n    @RequestMapping(&quot;&#x2F;test&#x2F;t2&quot;)\n    public String test3(Model model) &#123;\n        &#x2F;&#x2F;转发\n        model.addAttribute(&quot;msg&quot;,&quot;转发&quot;);\n        return &quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;test.jsp&quot;;\n    &#125;\n\n    @RequestMapping(&quot;&#x2F;test&#x2F;t2&quot;)\n    public String test2(Model model) &#123;\n        &#x2F;&#x2F;转发\n        model.addAttribute(&quot;msg&quot;,&quot;转发&quot;);\n        return &quot;forward:&#x2F;WEB-INF&#x2F;jsp&#x2F;test.jsp&quot;;\n    &#125;\n\n\n    @RequestMapping(&quot;&#x2F;test&#x2F;h1&quot;)\n    public String test(Model model) &#123;\n        &#x2F;&#x2F;重定向\n        return &quot;redirect:&#x2F;abc.jsp&quot;;\n    &#125;\n&#125;\n\n\n\n\n通过SpringMVC实现转发和重定向-使用视图解析器\n@Controller\npublic class ModelTest1 &#123;\n\n    @RequestMapping(&quot;&#x2F;test&#x2F;t2&quot;)\n    public String test2(Model model) &#123;\n        &#x2F;&#x2F;转发\n        model.addAttribute(&quot;msg&quot;,&quot;转发&quot;);\n        return &quot;test&quot;;\n    &#125;\n\n\n    @RequestMapping(&quot;&#x2F;test&#x2F;h1&quot;)\n    public String test(Model model) &#123;\n        &#x2F;&#x2F;重定向\n        return &quot;redirect:&#x2F;abc.jsp&quot;;\n    &#125;\n&#125;\n\n\n6、数据处理处理提交数据1、提交的域名称和处理方法的参数名一致提交数据：localhost:8080&#x2F;user&#x2F;t1?name&#x3D;xoc001\n处理方法：\n@Controller\n@RequestMapping(&quot;&#x2F;user&quot;)\npublic class UserController &#123;\n\n    @GetMapping(&quot;&#x2F;t1&quot;)\n    public String test1(@RequestParam(&quot;name&quot;) String name, Model model)&#123;\n\n        System.out.println(&quot;name&#x3D;&quot;+name);\n        model.addAttribute(&quot;msg&quot;,name);\n        return &quot;test&quot;;\n    &#125;\n&#125;\n\n2、提交的域名称和处理方法的参数名不一致提交数据：localhost:8080&#x2F;user&#x2F;t1?username&#x3D;xoc001\n处理方法：\n@Controller\n@RequestMapping(&quot;&#x2F;user&quot;)\npublic class UserController &#123;\n\n    @GetMapping(&quot;&#x2F;t1&quot;)\n    public String test1(@RequestParam(&quot;username&quot;) String name, Model model)&#123;\n\n        System.out.println(&quot;name&#x3D;&quot;+name);\n        model.addAttribute(&quot;msg&quot;,name);\n        return &quot;test&quot;;\n    &#125;\n&#125;\n\n\n\n3、提交的是一个对象\n实体类\npackage my.pojo;\n\npublic class User &#123;\n    private int id;\n    private String name;\n    private int age;\n    \n    &#x2F;&#x2F;Get、Set\n    &#x2F;&#x2F;toString\n    &#x2F;&#x2F;构造\n&#125;\n\n\n\n\n提交数据：localhost:8080&#x2F;user&#x2F;t2?id&#x3D;1&amp;name&#x3D;xoc001?&amp;age&#x3D;21\n\n处理方法\n\n\n@Controller\n@RequestMapping(&quot;&#x2F;user&quot;)\npublic class UserController &#123;\n\n    @GetMapping(&quot;&#x2F;t2&#x2F;&#123;id&#125;&#x2F;&#123;name&#125;&#x2F;&#123;age&#125;&quot;)\n    public String test2(User user)&#123;\n\n        System.out.println(user);\n        return &quot;test&quot;;\n    &#125;\n&#125;\n\n如果使用对象的话，前端传递的参数名和对象名必须一致，否则字段信息为null\n数据显示到前端第一种：使用ModelAndViewpublic class HelloController implements Controller &#123;\n    @Override\n    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;\n        ModelAndView mv &#x3D; new ModelAndView();\n\n        String result &#x3D; &quot;HelloSpringMVC!&quot;;\n        mv.addObject(&quot;msg&quot;,result);\n\n        mv.setViewName(&quot;test&quot;);\n\n        return mv;\n    &#125;\n&#125;\n\n\n\n第二种：使用Model@Controller\n@RequestMapping(&quot;&#x2F;hello&quot;)\npublic class ControllerTest3 &#123;\n\n    @RequestMapping(&quot;&#x2F;t1&quot;)\n    public String test1(Model model)&#123;\n        model.addAttribute(&quot;msg&quot;,&quot;RequestMapping  Test1!&quot;);\n\n        return &quot;test&quot;;\n    &#125;\n&#125;\n\n\n\n第三种：使用ModelMap@Controller\n@RequestMapping(&quot;&#x2F;hello&quot;)\npublic class ControllerTest3 &#123;\n\n    @GetMapping(&quot;&#x2F;t3&quot;)\n    public String test3(@RequestParam(&quot;phone&quot;) String phone,ModelMap map)&#123;\n\n        map.addAttribute(&quot;msg&quot;,phone);\n\n        return &quot;test&quot;;\n    &#125;\n&#125;\n\n区别：\nModel 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；\n\nModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；\n\nModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。\n\n\n\n乱码问题测试\n\n编写前端提交的表单页面\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;form action&#x3D;&quot;e&#x2F;t1&quot; method&#x3D;&quot;post&quot;&gt;\n        &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot;&gt;\n        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n    &lt;&#x2F;form&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n后台编写对应处理类\npackage my;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.PostMapping;\n\n@Controller\npublic class EncodingController &#123;\n\n    @PostMapping(&quot;e&#x2F;t1&quot;)\n    public String test1(String name, Model model)&#123;\n        model.addAttribute(&quot;msg&quot;,name);\n        return &quot;test&quot;;\n    &#125;\n&#125;\n\n\n\n\n&#x3D;&#x3D;在web.xml中配置SpringMVC过滤器&#x3D;&#x3D;\n&lt;filter&gt;\n    &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;\n        &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n&lt;&#x2F;filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;\n\n\n\n其余方法\n\n修改tomcat配置文件：设置编码\n\n  &lt;Connector URIEncoding&#x3D;&quot;utf-8&quot; port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;\n          connectionTimeout&#x3D;&quot;20000&quot;\n          redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;\n\n\n自定义过滤器\npackage com.kuang.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Map;\n\n&#x2F;**\n* 解决get和post请求 全部乱码的过滤器\n*&#x2F;\npublic class GenericEncodingFilter implements Filter &#123;\n\n   @Override\n   public void destroy() &#123;\n  &#125;\n\n   @Override\n   public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;\n       &#x2F;&#x2F;处理response的字符编码\n       HttpServletResponse myResponse&#x3D;(HttpServletResponse) response;\n       myResponse.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);\n\n       &#x2F;&#x2F; 转型为与协议相关对象\n       HttpServletRequest httpServletRequest &#x3D; (HttpServletRequest) request;\n       &#x2F;&#x2F; 对request包装增强\n       HttpServletRequest myrequest &#x3D; new MyRequest(httpServletRequest);\n       chain.doFilter(myrequest, response);\n  &#125;\n\n   @Override\n   public void init(FilterConfig filterConfig) throws ServletException &#123;\n  &#125;\n\n&#125;\n\n&#x2F;&#x2F;自定义request对象，HttpServletRequest的包装类\nclass MyRequest extends HttpServletRequestWrapper &#123;\n\n   private HttpServletRequest request;\n   &#x2F;&#x2F;是否编码的标记\n   private boolean hasEncode;\n   &#x2F;&#x2F;定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰\n   public MyRequest(HttpServletRequest request) &#123;\n       super(request);&#x2F;&#x2F; super必须写\n       this.request &#x3D; request;\n  &#125;\n\n   &#x2F;&#x2F; 对需要增强方法 进行覆盖\n   @Override\n   public Map getParameterMap() &#123;\n       &#x2F;&#x2F; 先获得请求方式\n       String method &#x3D; request.getMethod();\n       if (method.equalsIgnoreCase(&quot;post&quot;)) &#123;\n           &#x2F;&#x2F; post请求\n           try &#123;\n               &#x2F;&#x2F; 处理post乱码\n               request.setCharacterEncoding(&quot;utf-8&quot;);\n               return request.getParameterMap();\n          &#125; catch (UnsupportedEncodingException e) &#123;\n               e.printStackTrace();\n          &#125;\n      &#125; else if (method.equalsIgnoreCase(&quot;get&quot;)) &#123;\n           &#x2F;&#x2F; get请求\n           Map&lt;String, String[]&gt; parameterMap &#x3D; request.getParameterMap();\n           if (!hasEncode) &#123; &#x2F;&#x2F; 确保get手动编码逻辑只运行一次\n               for (String parameterName : parameterMap.keySet()) &#123;\n                   String[] values &#x3D; parameterMap.get(parameterName);\n                   if (values !&#x3D; null) &#123;\n                       for (int i &#x3D; 0; i &lt; values.length; i++) &#123;\n                           try &#123;\n                               &#x2F;&#x2F; 处理get乱码\n                               values[i] &#x3D; new String(values[i]\n                                      .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);\n                          &#125; catch (UnsupportedEncodingException e) &#123;\n                               e.printStackTrace();\n                          &#125;\n                      &#125;\n                  &#125;\n              &#125;\n               hasEncode &#x3D; true;\n          &#125;\n           return parameterMap;\n      &#125;\n       return super.getParameterMap();\n  &#125;\n\n   &#x2F;&#x2F;取一个值\n   @Override\n   public String getParameter(String name) &#123;\n       Map&lt;String, String[]&gt; parameterMap &#x3D; getParameterMap();\n       String[] values &#x3D; parameterMap.get(name);\n       if (values &#x3D;&#x3D; null) &#123;\n           return null;\n      &#125;\n       return values[0]; &#x2F;&#x2F; 取回参数的第一个值\n  &#125;\n\n   &#x2F;&#x2F;取所有值\n   @Override\n   public String[] getParameterValues(String name) &#123;\n       Map&lt;String, String[]&gt; parameterMap &#x3D; getParameterMap();\n       String[] values &#x3D; parameterMap.get(name);\n       return values;\n  &#125;\n&#125;\n\n\n\n7、JSONJSON介绍\nJSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。\n采用完全独立于编程语言的文本格式来存储和表示数据。\n简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。\n易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。\n\n在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：\n\n对象表示为键值对，数据由逗号分隔\n花括号保存对象\n方括号保存数组\n\nJSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键&#x2F;值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值：\n&#123;&quot;name&quot;: &quot;Xoc001&quot;&#125;\n&#123;&quot;age&quot;: &quot;3&quot;&#125;\n&#123;&quot;sex&quot;: &quot;男&quot;&#125;\n\nJSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。\nJSON 和 JavaScript 对象互转\n要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：\nvar obj &#x3D; JSON.parse(&#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;);\n&#x2F;&#x2F;结果是 &#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;\n\n要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：\nvar json &#x3D; JSON.stringify(&#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;);\n&#x2F;&#x2F;结果是 &#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;\n\n\n\n相关Jar包\n&lt;dependencies&gt;\n     &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.fasterxml.jackson.core&#x2F;jackson-databind --&gt;\n     &lt;dependency&gt;\n         &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;\n         &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;\n         &lt;version&gt;2.12.4&lt;&#x2F;version&gt;\n     &lt;&#x2F;dependency&gt;\n\n &lt;&#x2F;dependencies&gt;\n\n\n\n\n\n乱码优化乱码统一解决在SpringMVC的配置文件中添加配置\n&lt;mvc:annotation-driven&gt;\n   &lt;mvc:message-converters register-defaults&#x3D;&quot;true&quot;&gt;\n       &lt;bean class&#x3D;&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;\n           &lt;constructor-arg value&#x3D;&quot;UTF-8&quot;&#x2F;&gt;\n       &lt;&#x2F;bean&gt;\n       &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;\n           &lt;property name&#x3D;&quot;objectMapper&quot;&gt;\n               &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;\n                   &lt;property name&#x3D;&quot;failOnEmptyBeans&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;\n               &lt;&#x2F;bean&gt;\n           &lt;&#x2F;property&gt;\n       &lt;&#x2F;bean&gt;\n   &lt;&#x2F;mvc:message-converters&gt;\n&lt;&#x2F;mvc:annotation-driven&gt;\n\n\n\n返回json字符串统一解决在类上直接使用@RestController，这样里面所有的方法只会返回json字符串。不用再每一个都添加@ResponseBody。\n@RestController\npublic class UserController &#123;\n\n    @RequestMapping(&quot;&#x2F;t1&quot;)\n    &#x2F;&#x2F;@ResponseBody       &#x2F;&#x2F;不走视图解析器，返回字符串\n    public String test() throws JsonProcessingException &#123;\n        User user &#x3D; new User(1,&quot;百度一下你就知道&quot;,12);\n\n        ObjectMapper mapper &#x3D; new ObjectMapper();\n        String s &#x3D; mapper.writeValueAsString(user);\n\n        return s;\n    &#125;\n\n    @RequestMapping(&quot;&#x2F;t2&quot;)\n    public String test2() throws JsonProcessingException &#123;\n        ObjectMapper mapper &#x3D; new ObjectMapper();\n\n        List&lt;User&gt; userList &#x3D; new ArrayList&lt;User&gt;();\n        userList.add(new User(1,&quot;a&quot;,18));\n        userList.add(new User(2,&quot;b&quot;,18));\n        userList.add(new User(3,&quot;c&quot;,18));\n        userList.add(new User(4,&quot;大大&quot;,18));\n\n        String s &#x3D; mapper.writeValueAsString(userList);\n\n        return s;\n    &#125;\n&#125;\n\n\n\n\nJackson、FastJson\n8、整合SSM框架环境要求：\nIDEA\nMySQL\nTomcat8.5\nMaven3.6\n\n要求：\n\n熟练掌握MySQL数据库，Spring，JavaWeb及Mybatis知识\n\n数据库环境CREATE DATABASE &#96;ssmbuild&#96;;\n\nUSE &#96;ssmbuild&#96;;\n\nDROP TABLE IF EXISTS &#96;books&#96;;\n\nCREATE TABLE &#96;books&#96; (\n&#96;bookID&#96; INT(10) NOT NULL AUTO_INCREMENT COMMENT &#39;书id&#39;,\n&#96;bookName&#96; VARCHAR(100) NOT NULL COMMENT &#39;书名&#39;,\n&#96;bookCounts&#96; INT(11) NOT NULL COMMENT &#39;数量&#39;,\n&#96;detail&#96; VARCHAR(200) NOT NULL COMMENT &#39;描述&#39;,\nKEY &#96;bookID&#96; (&#96;bookID&#96;)\n) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8\n\nINSERT  INTO &#96;books&#96;(&#96;bookID&#96;,&#96;bookName&#96;,&#96;bookCounts&#96;,&#96;detail&#96;)VALUES\n(1,&#39;Java&#39;,1,&#39;从入门到放弃&#39;),\n(2,&#39;MySQL&#39;,10,&#39;从删库到跑路&#39;),\n(3,&#39;Linux&#39;,5,&#39;从进门到进牢&#39;);\n\n\n\n基本环境搭建导入pom依赖\n&lt;dependencies&gt;\n   &lt;!--Junit--&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n       &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;\n       &lt;version&gt;4.12&lt;&#x2F;version&gt;\n   &lt;&#x2F;dependency&gt;\n   &lt;!--数据库驱动--&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n       &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n       &lt;version&gt;5.1.47&lt;&#x2F;version&gt;\n   &lt;&#x2F;dependency&gt;\n   &lt;!-- 数据库连接池 --&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;com.mchange&lt;&#x2F;groupId&gt;\n       &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;\n       &lt;version&gt;0.9.5.2&lt;&#x2F;version&gt;\n   &lt;&#x2F;dependency&gt;\n\n   &lt;!--Servlet - JSP --&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n       &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;\n       &lt;version&gt;2.5&lt;&#x2F;version&gt;\n   &lt;&#x2F;dependency&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;\n       &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;\n       &lt;version&gt;2.2&lt;&#x2F;version&gt;\n   &lt;&#x2F;dependency&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n       &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;\n       &lt;version&gt;1.2&lt;&#x2F;version&gt;\n   &lt;&#x2F;dependency&gt;\n\n   &lt;!--Mybatis--&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;\n       &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;\n       &lt;version&gt;3.5.2&lt;&#x2F;version&gt;\n   &lt;&#x2F;dependency&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;\n       &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;\n       &lt;version&gt;2.0.2&lt;&#x2F;version&gt;\n   &lt;&#x2F;dependency&gt;\n\n   &lt;!--Spring--&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n       &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;\n       &lt;version&gt;5.1.9.RELEASE&lt;&#x2F;version&gt;\n   &lt;&#x2F;dependency&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n       &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;\n       &lt;version&gt;5.1.9.RELEASE&lt;&#x2F;version&gt;\n   &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\nMaven资源过滤设置\n&lt;build&gt;\n   &lt;resources&gt;\n       &lt;resource&gt;\n           &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;\n           &lt;includes&gt;\n               &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;\n               &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;\n           &lt;&#x2F;includes&gt;\n           &lt;filtering&gt;false&lt;&#x2F;filtering&gt;\n       &lt;&#x2F;resource&gt;\n       &lt;resource&gt;\n           &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;\n           &lt;includes&gt;\n               &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;\n               &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;\n           &lt;&#x2F;includes&gt;\n           &lt;filtering&gt;false&lt;&#x2F;filtering&gt;\n       &lt;&#x2F;resource&gt;\n   &lt;&#x2F;resources&gt;\n&lt;&#x2F;build&gt;\n\n配置框架和基本结构\n\nmy.pojo\n\nmy.dao\n\nmy.service\n\nmy.controller\n\nmybatis-config.xml\n\napplicationContext.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\n    &lt;import resource&#x3D;&quot;classpath:spring-dao.xml&quot;&#x2F;&gt;\n    &lt;import resource&#x3D;&quot;classpath:spring-service.xml&quot;&#x2F;&gt;\n    &lt;import resource&#x3D;&quot;classpath:spring-mvc.xml&quot;&#x2F;&gt;\n\n&lt;&#x2F;beans&gt;\n\nMyBatis编写\n编写Mybatis核心配置文件Mybatis-config.xml\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n\n    &lt;typeAliases&gt;\n        &lt;package name&#x3D;&quot;my.pojo&quot;&#x2F;&gt;\n    &lt;&#x2F;typeAliases&gt;\n\n    &lt;mappers&gt;\n        &lt;mapper class&#x3D;&quot;my.dao.BookMapper&quot;&#x2F;&gt;\n        &lt;mapper class&#x3D;&quot;my.dao.UserMapper&quot;&#x2F;&gt;\n    &lt;&#x2F;mappers&gt;\n&lt;&#x2F;configuration&gt;\n\n\n创建POJO类\npackage my.pojo;\n\npublic class Books &#123;\n    private int bookID;\n    private String bookName;\n    private int bookCounts;\n    private String detail;\n\t\n    &#x2F;&#x2F;有参，无参构造方法\n    &#x2F;&#x2F;get set方法\n    &#x2F;&#x2F; toString 方法\n&#125;\n\n\n编写Dao层Mapper接口\npackage my.dao;\n\nimport my.pojo.Books;\n\nimport java.util.List;\n\npublic interface BookMapper &#123;\n    &#x2F;&#x2F;添加\n    int addBook(Books books);\n    &#x2F;&#x2F;删除\n    int deleteBook(int id);\n    &#x2F;&#x2F;更新\n    int updateBook(Books book);\n    &#x2F;&#x2F;查找单个\n    Books queryBookById(int id);\n    &#x2F;&#x2F;查找全部\n    List&lt;Books&gt; queryAllBook();\n    &#x2F;&#x2F;根据书籍名称查询\n    List&lt;Books&gt; queryBookByName(String queryBookByName);\n&#125;\n\n\n\n\n编写对应Mapper.xml文件。\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF8&quot; ?&gt;\n&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace&#x3D;&quot;my.dao.BookMapper&quot;&gt;\n    &lt;insert id&#x3D;&quot;addBook&quot; parameterType&#x3D;&quot;books&quot;&gt;\n        insert into &#96;books&#96; (bookName,&#96;bookCounts&#96;,&#96;detail&#96;) values (#&#123;bookName&#125;,#&#123;bookCounts&#125;,#&#123;detail&#125;);\n    &lt;&#x2F;insert&gt;\n\n    &lt;delete id&#x3D;&quot;deleteBook&quot; parameterType&#x3D;&quot;int&quot;&gt;\n        delete from &#96;books&#96; where &#96;bookID&#96;&#x3D;#&#123;id&#125;;\n    &lt;&#x2F;delete&gt;\n    \n    &lt;update id&#x3D;&quot;updateBook&quot; parameterType&#x3D;&quot;books&quot;&gt;\n        update &#96;books&#96; set bookName&#x3D;#&#123;bookName&#125;,bookCounts&#x3D;#&#123;bookCounts&#125;,detail&#x3D;#&#123;detail&#125;where bookID&#x3D;#&#123;bookID&#125; ;\n    &lt;&#x2F;update&gt;\n\n    &lt;select id&#x3D;&quot;queryBookById&quot; parameterType&#x3D;&quot;int&quot; resultType&#x3D;&quot;books&quot;&gt;\n        select * from &#96;books&#96; where &#96;bookID&#96;&#x3D;#&#123;id&#125;\n    &lt;&#x2F;select&gt;\n    \n    &lt;select id&#x3D;&quot;queryAllBook&quot; resultType&#x3D;&quot;books&quot;&gt;\n        select * from &#96;books&#96;\n    &lt;&#x2F;select&gt;\n\n    &lt;select id&#x3D;&quot;queryBookByName&quot; resultType&#x3D;&quot;books&quot;&gt;\n        select * from &#96;books&#96;\n        &lt;where&gt;\n            &lt;if test&#x3D;&quot;queryBookByName!&#x3D;null&quot;&gt;\n                bookName like #&#123;queryBookByName&#125;\n            &lt;&#x2F;if&gt;\n        &lt;&#x2F;where&gt;\n\n    &lt;&#x2F;select&gt;\n&lt;&#x2F;mapper&gt;\n\n\n\n编写Service层接口和实现类\n\n\n  package my.service;\n\nimport my.pojo.Books;\n\nimport java.util.List;\n\npublic interface BookService &#123;\n    &#x2F;&#x2F;添加\n    int addBook(Books books);\n    &#x2F;&#x2F;删除\n    int deleteBook(int id);\n    &#x2F;&#x2F;更新\n    int updateBook(Books book);\n    &#x2F;&#x2F;查找单个\n    Books queryBookById(int id);\n    &#x2F;&#x2F;查找全部\n    List&lt;Books&gt; queryAllBook();\n\n    List&lt;Books&gt; queryBookByName(String queryBookByName);\n&#125;\n\n\n  实现类\n  package my.service;\n\n        import my.dao.BookMapper;\n        import my.pojo.Books;\n\n        import java.util.List;\n\npublic class BookServiceImpl implements BookService &#123;\n\n    &#x2F;&#x2F;service调用Dao层\n    private BookMapper bookMapper;\n\n    public void setBookMapper(BookMapper bookMapper) &#123;\n        this.bookMapper &#x3D; bookMapper;\n    &#125;\n\n    public int addBook(Books books) &#123;\n        return bookMapper.addBook(books);\n    &#125;\n\n    public int deleteBook(int id) &#123;\n        return bookMapper.deleteBook(id);\n    &#125;\n\n    public int updateBook(Books book) &#123;\n        return bookMapper.updateBook(book);\n    &#125;\n\n    public Books queryBookById(int id) &#123;\n        return bookMapper.queryBookById(id);\n    &#125;\n\n    public List&lt;Books&gt; queryAllBook() &#123;\n        return bookMapper.queryAllBook();\n    &#125;\n\n    public List&lt;Books&gt; queryBookByName(String queryBookByName) &#123;\n        return bookMapper.queryBookByName(queryBookByName);\n    &#125;\n&#125;\n\n\nSpring层\n整合Spring-Mybatis，使用c3p0连接池\n\nspring-dao.xml文件\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\n\n    &lt;!--    DataSource：使用Spring的数据源替换Mybatis的位置 c3p0 dbcp druid\n        这里使用Spring 提供的JDBC org.springframework.jdbc.datasource.DriverManagerDataSource\n    --&gt;\n    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;\n        &lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssmbuild?useSSL&#x3D;true&amp;useUncode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;&quot;&#x2F;&gt;\n\n        &lt;!-- c3p0连接池的私有属性 --&gt;\n        &lt;property name&#x3D;&quot;maxPoolSize&quot; value&#x3D;&quot;30&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;minPoolSize&quot; value&#x3D;&quot;10&quot;&#x2F;&gt;\n        &lt;!-- 关闭连接后不自动commit --&gt;\n        &lt;property name&#x3D;&quot;autoCommitOnClose&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;\n        &lt;!-- 获取连接超时时间 --&gt;\n        &lt;property name&#x3D;&quot;checkoutTimeout&quot; value&#x3D;&quot;10000&quot;&#x2F;&gt;\n        &lt;!-- 当获取连接失败重试次数 --&gt;\n        &lt;property name&#x3D;&quot;acquireRetryAttempts&quot; value&#x3D;&quot;2&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;!--    sqlSessionFactory--&gt;\n    &lt;bean class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot; id&#x3D;&quot;sqlSessionFactory&quot;&gt;\n        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;\n        &lt;!--        绑定Mybatis 配置文件--&gt;\n        &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;!--    配置dao接口扫描包，动态的实现了Dao接口可以注入到Spring容器中--&gt;\n    &lt;bean class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;\n        &lt;!--        注入SqlSessionFactory--&gt;\n        &lt;property name&#x3D;&quot;sqlSessionFactoryBeanName&quot; value&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;\n        &lt;!--        要扫描的dao 包--&gt;\n        &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;my.dao&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\nSpring整合Service层&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;\n\n    &lt;context:component-scan base-package&#x3D;&quot;my.service&quot;&#x2F;&gt;\n\n    &lt;!--将所有业务类，注入到Spring--&gt;\n    &lt;bean id&#x3D;&quot;BookServiceImpl&quot; class&#x3D;&quot;my.service.BookServiceImpl&quot;&gt;\n        &lt;property name&#x3D;&quot;bookMapper&quot; ref&#x3D;&quot;bookMapper&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;bean id&#x3D;&quot;UserServiceImpl&quot; class&#x3D;&quot;my.service.UserServiceImpl&quot;&gt;\n        &lt;property name&#x3D;&quot;userMapper&quot; ref&#x3D;&quot;userMapper&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;!--    声明式事务配置--&gt;\n    &lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;!--    aop事务支持--&gt;\n&lt;&#x2F;beans&gt;\n\n\n\nSpringMVC层\nweb.xml\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;\n         version&#x3D;&quot;4.0&quot;&gt;\n\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n            &lt;!-- 注意此处的配置文件为总的配置文件，否则找不到相关的包--&gt;\n            &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n\n        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;\n    &lt;&#x2F;servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;\n        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;servlet-mapping&gt;\n\n    &lt;filter&gt;\n        &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;\n        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;\n            &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n    &lt;&#x2F;filter&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;\n        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;filter-mapping&gt;\n\n\n&lt;&#x2F;web-app&gt;\n\n\nSpring-mvc.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n       https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc\n       https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;\n\n&lt;!--    注解驱动--&gt;\n    &lt;mvc:annotation-driven&#x2F;&gt;\n&lt;!--    静态资源过滤--&gt;\n    &lt;mvc:default-servlet-handler&#x2F;&gt;\n&lt;!--    扫描包--&gt;\n    &lt;context:component-scan base-package&#x3D;&quot;my.controller&quot;&#x2F;&gt;\n\n&lt;!--    视图解析器--&gt;\n    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id&#x3D;&quot;internalResourceViewResolver&quot;&gt;\n        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n\n&lt;&#x2F;beans&gt;\n\n\n\n在applicationContext.xml中整合spring需要的配置文件\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\n    &lt;import resource&#x3D;&quot;classpath:spring-dao.xml&quot;&#x2F;&gt;\n    &lt;import resource&#x3D;&quot;classpath:spring-service.xml&quot;&#x2F;&gt;\n    &lt;import resource&#x3D;&quot;classpath:spring-mvc.xml&quot;&#x2F;&gt;\n\n&lt;&#x2F;beans&gt;\n\nController和视图层编写\nBookController类编写：查询书籍\n@Controller\n@RequestMapping(&quot;&#x2F;book&quot;)\npublic class BookController &#123;\n\n    @Autowired\n    @Qualifier(&quot;BookServiceImpl&quot;)\n    private BookService bookService;\n\n    &#x2F;&#x2F;查询全部书籍\n    @RequestMapping(&quot;&#x2F;allBook&quot;)\n    public String queryAllBook(Model model) &#123;\n        List&lt;Books&gt; books &#x3D; bookService.queryAllBook();\n        model.addAttribute(&quot;books&quot;, books);\n        return &quot;allBook&quot;;\n    &#125;\n&#125;\n\n\n\n编写index.jsp页面\n&lt;%--\n  Created by IntelliJ IDEA.\n  User: Xoc001\n  Date: 2021&#x2F;8&#x2F;21\n  Time: 16:01\n  To change this template use File | Settings | File Templates.\n--%&gt;\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;$Title$&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      a&#123;\n        text-decoration: none;\n        color: black;\n        font-size: 18px;\n      &#125;\n      h3&#123;\n        width: 180px;\n        height: 30px;\n        margin: 100px auto;\n        text-align: center;\n        line-height: 38px;\n        background: deepskyblue;\n        border-radius: 5px;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n  &lt;h3&gt;\n    &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;allBook&quot;&gt;进入书籍页面&lt;&#x2F;a&gt;\n  &lt;&#x2F;h3&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n书籍列表页面 allBook.jsp\n&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;\n&lt;%--\n  Created by IntelliJ IDEA.\n  User: Xoc001\n  Date: 2021&#x2F;8&#x2F;21\n  Time: 16:15\n  To change this template use File | Settings | File Templates.\n--%&gt;\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;书籍展示&lt;&#x2F;title&gt;\n    &lt;!-- 引入 Bootstrap --&gt;\n    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n&lt;div class&#x3D;&quot;container&quot;&gt;\n    &lt;div class&#x3D;&quot;row clearfix&quot;&gt;\n        &lt;div class&#x3D;&quot;color-md-12 column&quot;&gt;\n            &lt;div class&#x3D;&quot;page-header&quot;&gt;\n                &lt;h1&gt;\n                    &lt;small&gt;书籍列表—————— 显示所有书籍&lt;&#x2F;small&gt;\n                &lt;&#x2F;h1&gt;\n            &lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;row&quot;&gt;\n            &lt;div class&#x3D;&quot;col-md-4 column&quot;&gt;\n                &lt;a class&#x3D;&quot;btn btn-primary&quot; href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;toAddBook&quot;&gt;新增书籍&lt;&#x2F;a&gt;\n            &lt;&#x2F;div&gt;\n\n            &lt;div class&#x3D;&quot;col-md-4 column&quot; style&#x3D;&quot;float: right&quot;&gt;\n                &lt;form action&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;queryByName&quot; method&#x3D;&quot;post&quot;&gt;\n                    &lt;div class&#x3D;&quot;form-inline&quot;&gt;\n                        &lt;span style&#x3D;&quot;color: red&quot;&gt;$&#123;error&#125;&lt;&#x2F;span&gt;\n                        &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; name&#x3D;&quot;queryBookByName&quot; placeholder&#x3D;&quot;查询的书籍的名称&quot;&gt;\n                        &lt;input class&#x3D;&quot;btn btn-primary&quot; type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n                    &lt;&#x2F;div&gt;\n                &lt;&#x2F;form&gt;\n            &lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;div class&#x3D;&quot;row clearfix&quot;&gt;\n        &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt;\n            &lt;table class&#x3D;&quot;table table-hover table-striped&quot;&gt;\n                &lt;thead&gt;\n                &lt;tr&gt;\n                    &lt;th&gt;书籍编号&lt;&#x2F;th&gt;\n                    &lt;th&gt;书籍名称&lt;&#x2F;th&gt;\n                    &lt;th&gt;书籍数量&lt;&#x2F;th&gt;\n                    &lt;th&gt;书籍详情&lt;&#x2F;th&gt;\n                    &lt;th&gt;操作&lt;&#x2F;th&gt;\n                &lt;&#x2F;tr&gt;\n                &lt;&#x2F;thead&gt;\n                &lt;%--                书籍从数据库查询出来，从list中遍历出来--%&gt;\n                &lt;tbody&gt;\n                    &lt;c:forEach var&#x3D;&quot;book&quot; items&#x3D;&quot;$&#123;books&#125;&quot;&gt;\n                        &lt;tr&gt;\n                            &lt;td&gt;$&#123;book.bookID&#125;&lt;&#x2F;td&gt;\n                            &lt;td&gt;$&#123;book.bookName&#125;&lt;&#x2F;td&gt;\n                            &lt;td&gt;$&#123;book.bookCounts&#125;&lt;&#x2F;td&gt;\n                            &lt;td&gt;$&#123;book.detail&#125;&lt;&#x2F;td&gt;\n                            &lt;td&gt;\n                                &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;toUpdateBook&#x2F;$&#123;book.bookID&#125;&quot;&gt;修改&lt;&#x2F;a&gt;\n                                &amp;nbsp;|&amp;nbsp;\n                                &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;deleteBook&#x2F;$&#123;book.bookID&#125;&quot;&gt;删除&lt;&#x2F;a&gt;\n                            &lt;&#x2F;td&gt;\n                        &lt;&#x2F;tr&gt;\n                    &lt;&#x2F;c:forEach&gt;\n                &lt;&#x2F;tbody&gt;\n            &lt;&#x2F;table&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n\n&lt;&#x2F;div&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\nBookController类编写，添加书籍\n@Controller\n@RequestMapping(&quot;&#x2F;book&quot;)\npublic class BookController &#123;\n\n    @Autowired\n    @Qualifier(&quot;BookServiceImpl&quot;)\n    private BookService bookService;\n\n    &#x2F;&#x2F;查询全部书籍\n    @RequestMapping(&quot;&#x2F;allBook&quot;)\n    public String queryAllBook(Model model) &#123;\n        List&lt;Books&gt; books &#x3D; bookService.queryAllBook();\n        model.addAttribute(&quot;books&quot;, books);\n        return &quot;allBook&quot;;\n    &#125;\n\n    &#x2F;&#x2F;跳转到增加书籍页面\n    @RequestMapping(&quot;&#x2F;toAddBook&quot;)\n    public String toAddPage() &#123;\n        return &quot;addBook&quot;;\n    &#125;\n\n    &#x2F;&#x2F;添加数据请求\n    @RequestMapping(&quot;&#x2F;addBook&quot;)\n    public String addBook(Model model, Books books) &#123;\n        bookService.addBook(books);\n        return &quot;redirect:&#x2F;book&#x2F;allBook&quot;;\n    &#125;\n&#125;\n\n添加书籍页面 addBook.jsp\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;div class&#x3D;&quot;container&quot;&gt;\n    &lt;div class&#x3D;&quot;row clearfix&quot;&gt;\n        &lt;div class&#x3D;&quot;color-md-12 column&quot;&gt;\n            &lt;div class&#x3D;&quot;page-header&quot;&gt;\n                &lt;h1&gt;\n                    &lt;small&gt;书籍列表—————— 新增书籍&lt;&#x2F;small&gt;\n                &lt;&#x2F;h1&gt;\n            &lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;form action&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;addBook&quot; method&#x3D;&quot;post&quot;&gt;\n        &lt;div class&#x3D;&quot;form-group&quot;&gt;\n            &lt;label&gt;书籍名称&lt;&#x2F;label&gt;\n            &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; name&#x3D;&quot;bookName&quot; required&gt;\n        &lt;&#x2F;div&gt;\n\n        &lt;div class&#x3D;&quot;form-group&quot;&gt;\n            &lt;label&gt;书籍数量&lt;&#x2F;label&gt;\n            &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; name&#x3D;&quot;bookCounts&quot; required&gt;\n        &lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;form-group&quot;&gt;\n            &lt;label&gt;书籍描述&lt;&#x2F;label&gt;\n            &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; name&#x3D;&quot;detail&quot; required&gt;\n        &lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;form-group&quot;&gt;\n            &lt;input type&#x3D;&quot;submit&quot; class&#x3D;&quot;form-control&quot; value&#x3D;&quot;添加&quot;&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;form&gt;\n\n&lt;&#x2F;div&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\nBookController 类编写，修改书籍\n@Controller\n@RequestMapping(&quot;&#x2F;book&quot;)\npublic class BookController &#123;\n\n    @Autowired\n    @Qualifier(&quot;BookServiceImpl&quot;)\n    private BookService bookService;\n\n    &#x2F;&#x2F;查询全部书籍\n    @RequestMapping(&quot;&#x2F;allBook&quot;)\n    public String queryAllBook(Model model) &#123;\n        List&lt;Books&gt; books &#x3D; bookService.queryAllBook();\n        model.addAttribute(&quot;books&quot;, books);\n        return &quot;allBook&quot;;\n    &#125;\n\n    &#x2F;&#x2F;跳转到增加书籍页面\n    @RequestMapping(&quot;&#x2F;toAddBook&quot;)\n    public String toAddPage() &#123;\n        return &quot;addBook&quot;;\n    &#125;\n\n    &#x2F;&#x2F;添加数据请求\n    @RequestMapping(&quot;&#x2F;addBook&quot;)\n    public String addBook(Model model, Books books) &#123;\n        bookService.addBook(books);\n        return &quot;redirect:&#x2F;book&#x2F;allBook&quot;;\n    &#125;\n\n    &#x2F;&#x2F;跳转修改书籍页面\n    @RequestMapping(&quot;&#x2F;toUpdateBook&#x2F;&#123;bookID&#125;&quot;)\n    public String toUpdateBook(@PathVariable(&quot;bookID&quot;) int id, Model model) &#123;\n\n        Books books &#x3D; bookService.queryBookById(id);\n        model.addAttribute(&quot;books&quot;, books);\n        return &quot;updateBook&quot;;\n    &#125;\n\n    &#x2F;&#x2F;修改数据请求\n    @RequestMapping(&quot;&#x2F;updateBook&quot;)\n    public String updateBook(Books books) &#123;\n        System.out.println(&quot;updateBook&#x3D;&gt;&quot; + books);\n        bookService.updateBook(books);\n\n        return &quot;redirect:&#x2F;book&#x2F;allBook&quot;;\n    &#125;\n&#125;\n\n\n\n添加修改界面 updateBook.jsp\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;div class&#x3D;&quot;container&quot;&gt;\n    &lt;div class&#x3D;&quot;row clearfix&quot;&gt;\n        &lt;div class&#x3D;&quot;color-md-12 column&quot;&gt;\n            &lt;div class&#x3D;&quot;page-header&quot;&gt;\n                &lt;h1&gt;\n                    &lt;small&gt;书籍列表—————— 修改书籍&lt;&#x2F;small&gt;\n                &lt;&#x2F;h1&gt;\n            &lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;form action&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;updateBook&quot; method&#x3D;&quot;post&quot;&gt;\n\n&lt;%--        隐藏域--%&gt;\n        &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;bookID&quot; value&#x3D;&quot;$&#123;books.bookID&#125;&quot;&gt;\n        &lt;div class&#x3D;&quot;form-group&quot;&gt;\n            &lt;label&gt;书籍名称&lt;&#x2F;label&gt;\n            &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; name&#x3D;&quot;bookName&quot; value&#x3D;&quot;$&#123;books.bookName&#125;&quot; required&gt;\n        &lt;&#x2F;div&gt;\n\n        &lt;div class&#x3D;&quot;form-group&quot;&gt;\n            &lt;label&gt;书籍数量&lt;&#x2F;label&gt;\n            &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; name&#x3D;&quot;bookCounts&quot; value&#x3D;&quot;$&#123;books.bookCounts&#125;&quot; required&gt;\n        &lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;form-group&quot;&gt;\n            &lt;label&gt;书籍描述&lt;&#x2F;label&gt;\n            &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; name&#x3D;&quot;detail&quot; value&#x3D;&quot;$&#123;books.detail&#125;&quot; required&gt;\n        &lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;form-group&quot;&gt;\n            &lt;input type&#x3D;&quot;submit&quot; class&#x3D;&quot;form-control&quot; value&#x3D;&quot;修改&quot;&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;form&gt;\n\n&lt;&#x2F;div&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\nBookController 类编写，查询书籍\npackage my.controller;\n\nimport my.pojo.Books;\nimport my.service.BookService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport java.util.List;\n\n@Controller\n@RequestMapping(&quot;&#x2F;book&quot;)\npublic class BookController &#123;\n\n    @Autowired\n    @Qualifier(&quot;BookServiceImpl&quot;)\n    private BookService bookService;\n\n    &#x2F;&#x2F;查询全部书籍\n    @RequestMapping(&quot;&#x2F;allBook&quot;)\n    public String queryAllBook(Model model) &#123;\n        List&lt;Books&gt; books &#x3D; bookService.queryAllBook();\n        model.addAttribute(&quot;books&quot;, books);\n        return &quot;allBook&quot;;\n    &#125;\n\n    &#x2F;&#x2F;跳转到增加书籍页面\n    @RequestMapping(&quot;&#x2F;toAddBook&quot;)\n    public String toAddPage() &#123;\n        return &quot;addBook&quot;;\n    &#125;\n\n    &#x2F;&#x2F;添加数据请求\n    @RequestMapping(&quot;&#x2F;addBook&quot;)\n    public String addBook(Model model, Books books) &#123;\n        bookService.addBook(books);\n        return &quot;redirect:&#x2F;book&#x2F;allBook&quot;;\n    &#125;\n\n    &#x2F;&#x2F;跳转修改书籍页面\n    @RequestMapping(&quot;&#x2F;toUpdateBook&#x2F;&#123;bookID&#125;&quot;)\n    public String toUpdateBook(@PathVariable(&quot;bookID&quot;) int id, Model model) &#123;\n\n        Books books &#x3D; bookService.queryBookById(id);\n        model.addAttribute(&quot;books&quot;, books);\n        return &quot;updateBook&quot;;\n    &#125;\n\n    &#x2F;&#x2F;修改数据请求\n    @RequestMapping(&quot;&#x2F;updateBook&quot;)\n    public String updateBook(Books books) &#123;\n        System.out.println(&quot;updateBook&#x3D;&gt;&quot; + books);\n        bookService.updateBook(books);\n\n        return &quot;redirect:&#x2F;book&#x2F;allBook&quot;;\n    &#125;\n\n    &#x2F;&#x2F;删除数据\n    @RequestMapping(&quot;&#x2F;deleteBook&#x2F;&#123;bookID&#125;&quot;)\n    public String deleteBook(@PathVariable(&quot;bookID&quot;) int id) &#123;\n\n        bookService.deleteBook(id);\n        return &quot;redirect:&#x2F;book&#x2F;allBook&quot;;\n    &#125;\n\n    &#x2F;&#x2F;搜索书籍数据\n    @RequestMapping(&quot;&#x2F;queryByName&quot;)\n    public String queryBookByName(String queryBookByName,Model model)&#123;\n        List&lt;Books&gt; booksList &#x3D; bookService.queryBookByName(&quot;%&quot;+queryBookByName+&quot;%&quot;);\n\n        if(!(booksList.size()&gt;0))&#123;\n            model.addAttribute(&quot;error&quot;,&quot;未找到该书籍&quot;);\n        &#125;\n        model.addAttribute(&quot;books&quot;,booksList);\n        return &quot;allBook&quot;;\n    &#125;\n&#125;\n\n\n\n\n配置查询书籍的底层实现源码\n&lt;select id&#x3D;&quot;queryBookByName&quot; resultType&#x3D;&quot;books&quot;&gt;\n    select * from &#96;books&#96;\n    &lt;where&gt;\n        &lt;if test&#x3D;&quot;queryBookByName!&#x3D;null&quot;&gt;\n            bookName like #&#123;queryBookByName&#125;\n        &lt;&#x2F;if&gt;\n    &lt;&#x2F;where&gt;\n&lt;&#x2F;select&gt;\n\n\n\n出现问题的排错思路\n\n\n排错思路\n1. 查看这个bean注入是否成功\n2.Junit单元测试,看底层代码是否能查询出结果\n3.SpringMVC，整合的时候没调用Service层的bean\n\t1.applicationContext.xml没有注入bean\n\t2.web.xml中，我们也绑过配置文件，发现问题我们配置的是Spring-mvc.xml 并没有service bean，所以找不到\n\n9、AJAX简介\nAJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。\n\nAJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。\n\nAjax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。\n\n在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。\n\nGoogle Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。\n\n就和国内百度的搜索框一样!\n\n传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。\n\n使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。\n\n使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。\n\n\n利用AJAX可以做：\n\n注册时，输入用户名自动检测用户是否已经存在。\n登陆时，提示用户名密码错误\n删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。\n….等等\n\njQuery.ajax(...)\n      部分参数：\n            url：请求地址\n            type：请求方式，GET、POST（1.9.0之后用method）\n        headers：请求头\n            data：要发送的数据\n    contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8&quot;)\n          async：是否异步\n        timeout：设置请求超时时间（毫秒）\n      beforeSend：发送请求前执行的函数(全局)\n        complete：完成之后执行的回调函数(全局)\n        success：成功之后执行的回调函数(全局)\n          error：失败之后执行的回调函数(全局)\n        accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型\n        dataType：将服务器端返回的数据转换成指定类型\n          &quot;xml&quot;: 将服务器端返回的内容转换成xml格式\n          &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式\n          &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。\n        &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式\n          &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象\n        &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback&#x3D;?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数\n\n\n\n导入jquery ， 可以使用在线的CDN ， 也可以下载导入\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\n\n\n配置web.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;\n         version&#x3D;&quot;4.0&quot;&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n            &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;\n    &lt;&#x2F;servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;\n        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;servlet-mapping&gt;\n\n    &lt;filter&gt;\n        &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;\n        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;\n            &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n    &lt;&#x2F;filter&gt;\n\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;\n        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;filter-mapping&gt;\n&lt;&#x2F;web-app&gt;\n\n\n\n\n\napplicationContext.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n       https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc\n       https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;\n\n    &lt;context:component-scan base-package&#x3D;&quot;my&quot;&#x2F;&gt;\n    &lt;!-- 静态资源过滤--&gt;\n    &lt;mvc:default-servlet-handler&#x2F;&gt;\n\n\n    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id&#x3D;&quot;internalResourceViewResolver&quot;&gt;\n        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\t&lt;!-- 解决乱码--&gt;\n    &lt;mvc:annotation-driven&gt;\n        &lt;mvc:message-converters register-defaults&#x3D;&quot;true&quot;&gt;\n            &lt;bean class&#x3D;&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;\n                &lt;constructor-arg value&#x3D;&quot;UTF-8&quot;&#x2F;&gt;\n            &lt;&#x2F;bean&gt;\n            &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;\n                &lt;property name&#x3D;&quot;objectMapper&quot;&gt;\n                    &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;\n                        &lt;property name&#x3D;&quot;failOnEmptyBeans&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;\n                    &lt;&#x2F;bean&gt;\n                &lt;&#x2F;property&gt;\n            &lt;&#x2F;bean&gt;\n        &lt;&#x2F;mvc:message-converters&gt;\n    &lt;&#x2F;mvc:annotation-driven&gt;\n&lt;&#x2F;beans&gt;\n\n\n\n\n\n\n\n实现1.登录界面的异步交互后端实现@RequestMapping(&quot;&#x2F;a3&quot;)\n   public String ajax3(String name, String pwd) &#123;\n       String msg &#x3D; &quot;&quot;;\n\n       if (name !&#x3D; null) &#123;\n           if (&quot;admin&quot;.equals(name)) &#123;\n               msg &#x3D; &quot;OK&quot;;\n           &#125; else &#123;\n               msg &#x3D; &quot;账号有误&quot;;\n           &#125;\n       &#125;\n       if (pwd !&#x3D; null) &#123;\n           if (&quot;123456&quot;.equals(pwd)) &#123;\n               msg &#x3D; &quot;OK&quot;;\n           &#125; else &#123;\n               msg &#x3D; &quot;密码有误&quot;;\n           &#125;\n       &#125;\n       return msg;\n   &#125;\n\n\n\n前端界面实现 login.jsp&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\n    &lt;script&gt;\n        function a1() &#123;\n            $.post(&#123;\n                url: &quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a3&quot;,\n                data: &#123;&quot;name&quot;: $(&quot;#name&quot;).val()&#125;,\n                success: function (data) &#123;\n                    if (data.toString() &#x3D;&#x3D;&#x3D; &quot;OK&quot;) &#123;\n                        $(&quot;#namemsg&quot;).css(&quot;color&quot;, &quot;green&quot;);\n                    &#125;else&#123;\n                        $(&quot;#namemsg&quot;).css(&quot;color&quot;, &quot;red&quot;);\n                    &#125;\n                    $(&quot;#namemsg&quot;).html(data);\n                &#125;\n            &#125;)\n        &#125;\n\n        function a2() &#123;\n            $.post(&#123;\n                url: &quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a3&quot;,\n                data: &#123;&quot;pwd&quot;: $(&quot;#pwd&quot;).val()&#125;,\n                success: function (data) &#123;\n                    if (data.toString() &#x3D;&#x3D;&#x3D; &quot;OK&quot;) &#123;\n                        $(&quot;#pwdmsg&quot;).css(&quot;color&quot;, &quot;green&quot;);\n                    &#125; else &#123;\n                        $(&quot;#pwdmsg&quot;).css(&quot;color&quot;, &quot;red&quot;);\n                    &#125;\n                    $(&quot;#pwdmsg&quot;).html(data);\n                &#125;\n            &#125;)\n        &#125;\n    &lt;&#x2F;script&gt;\n\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n&lt;div&gt;\n    用户名：\n    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot; onblur&#x3D;&quot;a1()&quot;&gt;\n    &lt;span id&#x3D;&quot;namemsg&quot;&gt;&lt;&#x2F;span&gt;\n&lt;&#x2F;div&gt;\n&lt;div&gt;\n    密码：\n    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;pwd&quot; onblur&#x3D;&quot;a2()&quot;&gt;\n    &lt;span id&#x3D;&quot;pwdmsg&quot; &gt;&lt;&#x2F;span&gt;\n&lt;&#x2F;div&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n显示效果\n2.Spring MVC实现实现类package my.pojo;\n\npublic class User &#123;\n    private int id;\n    private String name;\n    private int age;\n\n&#x2F;&#x2F;构造方法\n&#x2F;&#x2F;Get Set方法\n&#x2F;&#x2F;toString方法\n&#125;\n\n\n后台实现@RequestMapping(&quot;&#x2F;a2&quot;)\npublic List&lt;User&gt; ajax2() &#123;\n    List&lt;User&gt; userList &#x3D; new ArrayList&lt;User&gt;();\n\n    userList.add(new User(1, &quot;奥迪罚&quot;, 18));\n    userList.add(new User(2, &quot;啊方法&quot;, 19));\n    userList.add(new User(3, &quot;昂发&quot;, 20));\n\n    return userList;\n&#125;\n\n界面实现&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt; &lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\n    &lt;script&gt;\n        $(function () &#123;\n            $(&quot;#btn&quot;).click(function () &#123;\n                $.post(&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a2&quot;,function (data) &#123;\n                    var html&#x3D;&quot;&quot;;\n                    for(var i&#x3D;0;i&lt;data.length;i++)&#123;\n                        html+&#x3D;&quot;&lt;tr&gt;&quot;\n                            +&quot;&lt;td&gt;&quot;+data[i].id+&quot;&lt;&#x2F;td&gt;&quot;+\n                            &quot;&lt;td&gt;&quot;+data[i].name+&quot;&lt;&#x2F;td&gt;&quot;+\n                            &quot;&lt;td&gt;&quot;+data[i].age+&quot;&lt;&#x2F;td&gt;&quot;+\n                            &quot;&lt;&#x2F;tr&gt;&quot;\n                    &#125;;\n                    $(&quot;#button&quot;).html(html);\n                &#125;);\n            &#125;)\n        &#125;);\n\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;加载数据&quot; id&#x3D;&quot;btn&quot;&gt;&lt;br&gt;\n&lt;table&gt;\n    &lt;thead&gt;\n        &lt;tr&gt;ID&lt;&#x2F;tr&gt;\n        &lt;tr&gt;Name&lt;&#x2F;tr&gt;\n        &lt;tr&gt;Age&lt;&#x2F;tr&gt;\n    &lt;&#x2F;thead&gt;\n    &lt;tbody id&#x3D;&quot;button&quot;&gt;\n\n    &lt;&#x2F;tbody&gt;\n&lt;&#x2F;table&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n10、拦截器SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。\n过滤器与拦截器的区别：拦截器是AOP思想的具体应用。\n过滤器：\n\nservlet规范中的一部分，任何java web工程中都可以使用。\n在url-partten中配置了&#x2F;*之后，可以对所有要访问的资源进行拦截。\n\n拦截器：\n\n拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用\n拦截器只会拦截访问控制器的方法，如果访问的是静态资源，不会拦截。\n\n自定义拦截器\n实现自定义拦截器必须实现HandlerInterceptor接口\n\npackage my.interceptor;\n\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class MyInterceptor implements HandlerInterceptor &#123;\n\n   &#x2F;&#x2F;在请求处理的方法之前执行\n   &#x2F;&#x2F;如果返回true执行下一个拦截器\n   &#x2F;&#x2F;如果返回false就不执行下一个拦截器\n   public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123;\n       System.out.println(&quot;------------处理前------------&quot;);\n       return true;\n  &#125;\n\n   &#x2F;&#x2F;在请求处理方法执行之后执行\n   public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;\n       System.out.println(&quot;------------处理后------------&quot;);\n  &#125;\n\n   &#x2F;&#x2F;在dispatcherServlet处理后执行,做清理工作.\n   public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;\n       System.out.println(&quot;------------清理------------&quot;);\n  &#125;\n&#125;\n\n\n在SpringMVC的配置文件中配置拦截器\n\n&lt;!--关于拦截器的配置--&gt;\n&lt;mvc:interceptors&gt;\n   &lt;mvc:interceptor&gt;\n       &lt;!--&#x2F;** 包括路径及其子路径--&gt;\n       &lt;!--&#x2F;admin&#x2F;* 拦截的是&#x2F;admin&#x2F;add等等这种 , &#x2F;admin&#x2F;add&#x2F;user不会被拦截--&gt;\n       &lt;!--&#x2F;admin&#x2F;** 拦截的是&#x2F;admin&#x2F;下的所有--&gt;\n       &lt;mvc:mapping path&#x3D;&quot;&#x2F;**&quot;&#x2F;&gt;\n       &lt;!--bean配置的就是拦截器--&gt;\n       &lt;bean class&#x3D;&quot;com.my.interceptor.MyInterceptor&quot;&#x2F;&gt;\n   &lt;&#x2F;mvc:interceptor&gt;\n&lt;&#x2F;mvc:interceptors&gt;\n\n\n\n\n\n2021年8月24日\n","slug":"SpringMVC","date":"2022-02-10T17:38:23.903Z","categories_index":"","tags_index":"","author_index":"Xoc001"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"SpringBoot2021年8月25日\n第一个SpringBoot程序原理yaml配置注入配置文件SpringBoot使用一个全局的配置文件，配置文件名称是固定的\n\napplication.properties\n语法结构：key&#x3D;value\n\n\napplication.yaml\n语法结构：key:空格value\n\n\n\n配置问加你的作用：修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给自动配置好了。例如可以修改Tomcat端口号\nserver.port&#x3D;8082\n\n\n\nserver:\n\tport: 8081\n\n\n\nyaml概述YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）\n这种语言以数据作为中心，而不是以标记语言为重点！\n以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml\nxml\n&lt;server&gt;\n\t&lt;port&gt;8081&lt;&#x2F;port&gt;\n&lt;&#x2F;server&gt;\n\nyaml\nserver:\n\tport: 8081\n\n\n\nyaml基础语法\n\n语法要求严格\n空格不能省略\n以缩进来控制层级关系，做要是左边对齐的一列数据都是同一层次\n属性和值的大小写都是十分敏感的\n\n字面量：普通的值  [ 数字，布尔值，字符串  ]\n字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号；\nk: v\n\n注意：\n\n“ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；\n比如 ：name: “百度\\n 一下”  输出 ：百度 换行  一下\n\n‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出\n比如 ：name: ‘百度\\n 一下’  输出 ：百度\\n  一下\n\n\n对象，Map(键值对)\n\n#对象格式 对象与属性的关系，注意缩进，。\nperson:\n\tname: abc\n\tage: 13\n\tsex: true\n\nList\nlist:\n\t- apple\n\t- banana\n\t- watermelon\n\t\n\t\n\n#行内写法\nlists: [cat,pig,dog]\n\n\n\nyaml注入配置文件通过yaml文件对pojo类的属性进行赋值\n@ConfigurationProperties(perfix&#x3D;&quot;person&quot;)\t&#x2F;&#x2F;在pojo类中进行注入，会提示Spingboot配置注解器没有找到\npublic class Person &#123;\n    private String name;\n    private int age;\n    private Date birthday;\n    private List&lt;Object&gt; lists;\n    private Map&lt;String,Object&gt; map;\n    private Dog dog;\n&#125;\n\npublic class Dog&#123;\n    private String name;\n    private int age;\n&#125;\n\nyaml配置\nperson:\n  name: &quot;百度\\n一下&quot;\n  age: 19\n  birthday: 2021&#x2F;08&#x2F;26\n  lists:\n    - apple\n    - banana\n    - watermelon\n  map: &#123;k1: v1,k2: v2&#125;\n  dog:\n    name: &quot;旺财&quot;\n    age: 3\n\n\n添加依赖\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;\n    &lt;optional&gt;true&lt;&#x2F;optional&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n加载指定配置文件@PropertySource：加载指定的配置文件\n@ConfigurationProperties：默认从全局配置文件中获取值\n配置文件占位符\nperson:\n    name: qinjiang$&#123;random.uuid&#125; # 随机uuid\n    age: $&#123;random.int&#125;  # 随机int\n    birthday: 2021&#x2F;01&#x2F;01\n    maps: &#123;k1: v1,k2: v2&#125;\n    lists:\n      - code\n      - girl\n      - music\n    dog:\n      name: $&#123;person.hello:other&#125;_旺财\n      age: 1\n\n对比小结@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图\n\n1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加\n2、松散绑定：这个什么意思呢? 比如我的yml中写的&#x3D;&#x3D;last-name，这个和lastName是一样的&#x3D;&#x3D;， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下\n3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性\n4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持\n结论：\n配置yml和配置properties都可以获取到值 ， 强烈推荐 yml；\n如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value；\n如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！\nJSR303数据校验@Validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。\n&#x3D;&#x3D;使用数据校验，可以保证数据的准确性&#x3D;&#x3D;\n常用的数据校验参数\n@NotNull(message&#x3D;&quot;名字不能为空&quot;)\nprivate String userName;\n@Max(value&#x3D;120,message&#x3D;&quot;年龄最大不能查过120&quot;)\nprivate int age;\n@Email(message&#x3D;&quot;邮箱格式错误&quot;)\nprivate String email;\n\n空检查\n@Null       验证对象是否为null\n@NotNull    验证对象是否不为null, 无法查检长度为0的字符串\n@NotBlank   检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.\n@NotEmpty   检查约束元素是否为NULL或者是EMPTY.\n    \nBooelan检查\n@AssertTrue     验证 Boolean 对象是否为 true  \n@AssertFalse    验证 Boolean 对象是否为 false  \n    \n长度检查\n@Size(min&#x3D;, max&#x3D;) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  \n@Length(min&#x3D;, max&#x3D;) string is between min and max included.\n\n日期检查\n@Past       验证 Date 和 Calendar 对象是否在当前时间之前  \n@Future     验证 Date 和 Calendar 对象是否在当前时间之后  \n@Pattern    验证 String 对象是否符合正则表达式的规则\n\n\n\n自动配置原理根据当前不同条件判断，决定这个配置类是否生效！\n\n一旦这个配置类生效；这个配置类就会给容器中添加各种组件。\n这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的。\n所有在配置文件中能配置的属性都是在XXXproperties类中封装的；\n配置文件能配置什么就可以参照某个功能对应的这个属性类。\n\n&#x2F;&#x2F;从配置文件中获取指定的值和bean的属性进行绑定\n@ConfigrationProperties(prefix&#x3D;&quot;spring.http&quot;)\npublic class HttpProperties&#123;\n    \n&#125;\n\n这就是自动装配的原理！\n\nSpringBoot启动会加载大量的自动配置类\n我们看我们需要的功能有没有在SpringBoot默认写好的自动类当中\n我们再来看这个自动配置类中到底配置了哪些组件；\n给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；\n\nxxxAutoConfiguration：自动配置类；给容器中添加组件\nxxxxProperties：封装配置文件中相关属性。\n了解：@Conditional了解完自动装配的原理后，我们来关注一个细节问题，自动配置类必须在一定的条件下才能生效；\n@Conditional派生注解（Spring注解版原生的@Conditional作用）\n作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；\n\n那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。\n我们怎么知道哪些自动配置类生效？\n我们可以通过启用 debug&#x3D;true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；\n#开启springboot的调试类debug&#x3D;true\n\nPositive matches:（自动配置类启用的：正匹配）\nNegative matches:（没有启动，没有匹配成功的自动配置类：负匹配）\nUnconditional classes: （没有条件的类）\nWeb开发静态资源处理SpringBoot中，SpringMVC的web配置都在WebMvcAutoConfiguration 这个配置类里面；有一个方法：addResourceHandlers\n@Override\npublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n    if (!this.resourceProperties.isAddMappings()) &#123;\n        logger.debug(&quot;Default resource handling disabled&quot;);\n        return;\n    &#125;\n    addResourceHandler(registry, &quot;&#x2F;webjars&#x2F;**&quot;, &quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;&quot;);\n    addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;\n        registration.addResourceLocations(this.resourceProperties.getStaticLocations());\n        if (this.servletContext !&#x3D; null) &#123;\n            ServletContextResource resource &#x3D; new ServletContextResource(this.servletContext, SERVLET_LOCATION);\n            registration.addResourceLocations(resource);\n        &#125;\n    &#125;);\n&#125;\n\n读一下源代码：比如所有的 &#x2F;webjars&#x2F;** ， 都需要去 classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F; 找对应的资源；\n什么是webjars 呢？Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。\n使用SpringBoot需要使用Webjars，我们可以去搜索一下：\n网站：https://www.webjars.org \n要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！\n&lt;dependency&gt;\n    &lt;groupId&gt;org.webjars&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jquery&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.4.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n导入完毕，查看webjars目录结构，并访问Jquery.js文件！\n\n访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源，我们这里访问：http://localhost:8080/webjars/jquery/3.4.1/jquery.js\n第二种静态资源映射规则\npublic static class Resources &#123;\n\n    private static final String[] CLASSPATH_RESOURCE_LOCATIONS &#x3D; &#123; &quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;,                           &quot;classpath:&#x2F;resources&#x2F;&quot;, &quot;classpath:&#x2F;static&#x2F;&quot;, &quot;classpath:&#x2F;public&#x2F;&quot; &#125;;\n&#125;\n\n\n结论：以下四个路径存放的静态资源可以被识别。 优先级分先后\n&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;\n&quot;classpath:&#x2F;resources&#x2F;&quot;\n&quot;classpath:&#x2F;static&#x2F;&quot;\n&quot;classpath:&#x2F;public&#x2F;&quot;\n\n我们可以在resources根目录下新建对应的文件夹，都可以存放我们的静态文件；\n比如我们访问 http://localhost:8080/1.js , 他就会去这些文件夹中寻找对应的静态资源文件；\n首页定制Spirng源码中的欢迎页映射\n@Bean\npublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,\n                                                           FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123;\n    WelcomePageHandlerMapping welcomePageHandlerMapping &#x3D; new WelcomePageHandlerMapping(\n        new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),\n        this.mvcProperties.getStaticPathPattern());\n    welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));\n    welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations());\n    return welcomePageHandlerMapping;\n&#125;\n\n进入其中的getWelcomePage()方法\nprivate Resource getWelcomePage() &#123;\n    for (String location : this.resourceProperties.getStaticLocations()) &#123;\n        Resource indexHtml &#x3D; getIndexHtml(location);\n        if (indexHtml !&#x3D; null) &#123;\n            return indexHtml;\n        &#125;\n    &#125;\n    ServletContext servletContext &#x3D; getServletContext();\n    if (servletContext !&#x3D; null) &#123;\n        return getIndexHtml(new ServletContextResource(servletContext, SERVLET_LOCATION));\n    &#125;\n    return null;\n&#125;\n\nprivate Resource getIndexHtml(Resource location) &#123;\n    try &#123;\n        Resource resource &#x3D; location.createRelative(&quot;index.html&quot;);\n        if (resource.exists() &amp;&amp; (resource.getURL() !&#x3D; null)) &#123;\n            return resource;\n        &#125;\n    &#125;\n    catch (Exception ex) &#123;\n    &#125;\n    return null;\n&#125;\n\n欢迎页，静态资源文件夹下所有的index.html页面会被 &#x2F;**映射。\n比如我访问  http://localhost:8080/ ，就会找静态资源文件夹下的 index.html\n新建一个 index.html ，在我们上面的3个目录中任意一个；然后访问测试  http://localhost:8080/  看结果！\n扩展使用SpringMVC官方文档如下：\nIf you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.\n我们要做的就是编写一个@Configuration注解类，并且类型要为WebMvcConfigurer，还不能标注@EnableWebMvc注解；我们去自己写一个；我们新建一个包叫config，写一个类MyMvcConfig；\n&#x2F;&#x2F;应为类型要求为WebMvcConfigurer，所以我们实现其接口\n&#x2F;&#x2F;可以使用自定义类扩展MVC的功能\n@Configuration\npublic class MyMvcConfig implements WebMvcConfigurer &#123;\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) &#123;\n        &#x2F;&#x2F; 浏览器发送&#x2F;test ， 就会跳转到test页面；\n        registry.addViewController(&quot;&#x2F;test&quot;).setViewName(&quot;test&quot;);\n    &#125;\n&#125;\n\n\n\n\n\n页面国际化网站会涉及多语言切换，需要实现国际化。\n需要将IDEA中统一设置properties的编码问题\n\n编写国际化配置文件，抽取页面需要显示的国际化页面消息。\n配置文件编写\n在resources资源文件夹下创建一个i18n目录，存放国际化配置文件\n建立一个login.properties，还有一个login_zh_CN.properties；发现IDEA自动识别了我们要做国际化操作；文件夹变了\n\n\n\n弹出添加页面，添加en_US配置。\n\n编写配置，在配置界面有一个Resource Bundle视图\n\n\n在视图中依次添加属性。\n\n\n\n配置文件生效探究涉及到国际化的类：MessageSourceAutoConfiguration\n@Bean\n\tpublic MessageSource messageSource(MessageSourceProperties properties) &#123;\n\t\tResourceBundleMessageSource messageSource &#x3D; new ResourceBundleMessageSource();\n\t\tif (StringUtils.hasText(properties.getBasename())) &#123;\n\t\t\tmessageSource.setBasenames(StringUtils\n\t\t\t\t\t.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename())));\n\t\t&#125;\n\t\tif (properties.getEncoding() !&#x3D; null) &#123;\n\t\t\tmessageSource.setDefaultEncoding(properties.getEncoding().name());\n\t\t&#125;\n\t\tmessageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());\n\t\tDuration cacheDuration &#x3D; properties.getCacheDuration();\n\t\tif (cacheDuration !&#x3D; null) &#123;\n\t\t\tmessageSource.setCacheMillis(cacheDuration.toMillis());\n\t\t&#125;\n\t\tmessageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());\n\t\tmessageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());\n\t\treturn messageSource;\n\t&#125;\n\n由此得：我们需要在application.properties中配置message路径\nspring.message.basename&#x3D;i18n.login  # 放置在i18n路径下得配置。\n\n\n\n配置页面国际化的值使用Thymeleaf模板，找到message取值的操作为#{}。\n\n配置国际化解析在Spring中有一个国际化的Locale(区域信息对象)类，里面有一个LocaleRosolver的解析器\npublic LocaleResolver localeResolver() &#123;\n    if (this.webProperties.getLocaleResolver() &#x3D;&#x3D; WebProperties.LocaleResolver.FIXED) &#123;\n        return new FixedLocaleResolver(this.webProperties.getLocale());\n    &#125;\n    if (this.mvcProperties.getLocaleResolver() &#x3D;&#x3D; WebMvcProperties.LocaleResolver.FIXED) &#123;\n        return new FixedLocaleResolver(this.mvcProperties.getLocale());\n    &#125;\n    AcceptHeaderLocaleResolver localeResolver &#x3D; new AcceptHeaderLocaleResolver();\n    Locale locale &#x3D; (this.webProperties.getLocale() !&#x3D; null) ? this.webProperties.getLocale()\n        : this.mvcProperties.getLocale();\n    localeResolver.setDefaultLocale(locale);\n    return localeResolver;\n&#125;\n\nAcceptHeaderLocaleResolver中的resolveLocale方法\npublic Locale resolveLocale(HttpServletRequest request) &#123;\n     Locale defaultLocale &#x3D; this.getDefaultLocale();\n     if (defaultLocale !&#x3D; null &amp;&amp; request.getHeader(&quot;Accept-Language&quot;) &#x3D;&#x3D; null) &#123;\n         return defaultLocale;\n     &#125; else &#123;\n         Locale requestLocale &#x3D; request.getLocale();\n         List&lt;Locale&gt; supportedLocales &#x3D; this.getSupportedLocales();\n         if (!supportedLocales.isEmpty() &amp;&amp; !supportedLocales.contains(requestLocale)) &#123;\n             Locale supportedLocale &#x3D; this.findSupportedLocale(request, supportedLocales);\n             if (supportedLocale !&#x3D; null) &#123;\n                 return supportedLocale;\n             &#125; else &#123;\n                 return defaultLocale !&#x3D; null ? defaultLocale : requestLocale;\n             &#125;\n         &#125; else &#123;\n             return requestLocale;\n         &#125;\n     &#125;\n &#125;\n\n需要使国际化资源生效，就需要配置我们自己的Locale，使其生效。\n修改前端页面跳转连接。\n&lt;a class&#x3D;&quot;btn btn-sm&quot; th:href&#x3D;&quot;@&#123;&#x2F;index.html(lang&#x3D;zh_CN)&#125;&quot;&gt;中文&lt;&#x2F;a&gt;\n&lt;a class&#x3D;&quot;btn btn-sm&quot; th:href&#x3D;&quot;@&#123;&#x2F;index.html(lang&#x3D;en_US)&#125;&quot;&gt;English&lt;&#x2F;a&gt;\n\n编写对应处理的组件类\npackage my.config;\n\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.servlet.LocaleResolver;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.Locale;\n\npublic class MyLocaleResolver implements LocaleResolver &#123;\n    @Override\n    public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123;\n        String language &#x3D; httpServletRequest.getParameter(&quot;lang&quot;);\n        &#x2F;&#x2F;如果没有就是用默认配置\n        Locale locale &#x3D; Locale.getDefault();\n        if(!StringUtils.hasText(language))&#123;\n\n            &#x2F;&#x2F;ZH_CN\n            String [] split &#x3D; language.split(&quot;_&quot;);\n            &#x2F;&#x2F;分割国家和地区。\n            locale&#x3D; new Locale(split[0],split[1]);\n        &#125;\n        return locale;\n    &#125;\n\n    @Override\n    public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123;\n\n    &#125;\n&#125;\n\n\n为了使国际化信息能够生效，需要配置这个组件，在自定义的MyMvcConfig类下添加Bean\n@Configuration\npublic class MyMvcConfig implements WebMvcConfigurer &#123;\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) &#123;\n        registry.addViewController(&quot;&#x2F;&quot;).setViewName(&quot;index&quot;);\n        registry.addViewController(&quot;&#x2F;index.html&quot;).setViewName(&quot;index&quot;);\n    &#125;\n\n    \n    &#x2F;&#x2F;添加国际化。\n    @Bean\n    public LocaleResolver localeResolver()&#123;\n        return new MyLocaleResolver();\n    &#125;\n&#125;\n\n\n\n\n整合JDBC使用\n创建测试项目测试数据源\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n    &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n\n编写yaml配置文件连接数据库\n\nspring:\n  datasource:\n    username: root\n    password:\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useSSL&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n\n\n\n测试类进行测试\npackage my;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\n@SpringBootTest\nclass DemoApplicationTests &#123;\n\n    @Autowired\n    DataSource dataSource;\n    @Test\n    void contextLoads() throws SQLException &#123;\n        System.out.println(dataSource.getClass());\n\n        Connection connection &#x3D; dataSource.getConnection();\n        System.out.println(connection);\n        connection.close();\n\n    &#125;\n\n&#125;\n\n\n结果：我们可以看到他默认给我们配置的数据源为 : class com.zaxxer.hikari.HikariDataSource ， 我们并没有手动配置\n我们来全局搜索一下，找到数据源的所有自动配置都在 ：DataSourceAutoConfiguration文件：\n@Import(\n    &#123;Hikari.class, Tomcat.class, Dbcp2.class, Generic.class, DataSourceJmxConfiguration.class&#125;\n)\nprotected static class PooledDataSourceConfiguration &#123;\n    protected PooledDataSourceConfiguration() &#123;\n    &#125;\n&#125;\n\n这里导入的类都在 DataSourceConfiguration 配置类下，可以看出 Spring Boot 2.2.5 默认使用HikariDataSource 数据源，而以前版本，如 Spring Boot 1.5 默认使用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源；\n&#x3D;&#x3D;HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀；可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限定名。&#x3D;&#x3D;\n关于数据源我们并不做介绍，有了数据库连接，显然就可以 CRUD 操作数据库了。但是我们需要先了解一个对象 JdbcTemplate\nJDBCTemplate1、有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了连接，就可以使用原生的 JDBC 语句来操作数据库；\n2、即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。\n3、数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。\n4、Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用\n5、JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类\nJdbcTemplate主要提供以下几类方法：\n\nexecute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；\nupdate方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；\nquery方法及queryForXXX方法：用于执行查询相关语句；\ncall方法：用于执行存储过程、函数相关语句。\n\n\n\n&#x3D;&#x3D;JDBCTemplate&#x3D;&#x3D;1、有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了连接，就可以使用原生的 JDBC 语句来操作数据库；\n2、即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。\n3、数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。\n4、Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用\n5、JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类\nJdbcTemplate主要提供以下几类方法：\n\nexecute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；\nupdate方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；\nquery方法及queryForXXX方法：用于执行查询相关语句；\ncall方法：用于执行存储过程、函数相关语句。\n\n整合Druid使用Druid简介Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。\nDruid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。\nDruid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。\nDruid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。\nSpring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。\nGithub地址：https://github.com/alibaba/druid/\n配置数据源&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.alibaba&#x2F;druid --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.2.6&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n切换数据源spring:\n  datasource:\n    username: root\n    password:\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useSSL&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n\n配置Druidspring:\n  datasource:\n    username: root\n    password:\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useSSL&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n\n\n    #Spring Boot 默认是不注入这些属性值的，需要自己绑定\n    #druid 数据源专有配置\n    initialSize: 5\n    minIdle: 5\n    maxActive: 20\n    maxWait: 60000\n    timeBetweenEvictionRunsMillis: 60000\n    minEvictableIdleTimeMillis: 300000\n    validationQuery: SELECT 1 FROM DUAL\n    testWhileIdle: true\n    testOnBorrow: false\n    testOnReturn: false\n    poolPreparedStatements: true\n\n    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入\n    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority\n    #则导入 log4j 依赖即可，Maven 地址：https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;log4j&#x2F;log4j\n    filters: stat,wall,log4j\n    maxPoolPreparedStatementPerConnectionSize: 20\n    useGlobalDataSourceStat: true\n    connectionProperties: druid.stat.mergeSql&#x3D;true;druid.stat.slowSqlMillis&#x3D;500\n\n导入Log4j依赖&lt;dependency&gt;\n    &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.2.17&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n为DruidDataSource绑定全局配置文件中的参数，再添加到容器中，而不再使用SpringBoot自动生成，需要添加自己的DruidDataSource组件到容器中，并绑定属性。\nDruid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。\n所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理；\n根据需求配置(配置Druid web 监控 filter 过滤器)\npackage my.config;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport com.alibaba.druid.support.http.StatViewServlet;\nimport com.alibaba.druid.support.http.WebStatFilter;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.boot.web.servlet.ServletRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport javax.sql.DataSource;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Configuration\npublic class DruidConfig &#123;\n\n    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource&quot;)\n    @Bean\n    public DataSource druidDataSource()&#123;\n        return new DruidDataSource();\n    &#125;\n\n    &#x2F;&#x2F;配置数据源监控\n    &#x2F;&#x2F;后台监控功能\n    @Bean\n    public ServletRegistrationBean statViewServlet()&#123;\n        ServletRegistrationBean&lt;StatViewServlet&gt; bean &#x3D; new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), &quot;&#x2F;druid&#x2F;*&quot;);\n\n        &#x2F;&#x2F;后台需要有人登录，账号密码设置\n        HashMap&lt;String, String&gt; initParameters &#x3D; new HashMap&lt;&gt;();\n        &#x2F;&#x2F;增加配置\n        initParameters.put(&quot;loginUsername&quot;,&quot;admin&quot;);\n        initParameters.put(&quot;loginPassword&quot;,&quot;123456&quot;);\n        &#x2F;&#x2F;允许访问\n        initParameters.put(&quot;allow&quot;,&quot;&quot;);     &#x2F;&#x2F;全部\n\n        &#x2F;&#x2F;禁止访问\n&#x2F;&#x2F;        initParameters.put(&quot;姓名&quot;,&quot;IP地址&quot;)&#x2F;&#x2F;\n\n        bean.setInitParameters(initParameters);\n\n        return bean;\n    &#125;\n\n    &#x2F;&#x2F;filter\n    @Bean\n    public FilterRegistrationBean webStatFilter()&#123;\n        FilterRegistrationBean bean &#x3D; new FilterRegistrationBean();\n\n        bean.setFilter(new WebStatFilter());\n        &#x2F;&#x2F;过滤请求设置；\n        HashMap&lt;String, String&gt; initParameters &#x3D; new HashMap&lt;&gt;();\n        &#x2F;&#x2F;不进行统计。\n        initParameters.put(&quot;exclusions&quot;,&quot;*.js,*.css,&#x2F;druid&#x2F;*&quot;);\n\n\n        bean.setInitParameters(initParameters);\n\n\n        return bean;\n    &#125;\n\n&#125;\n\n\n配置完毕后可以通过localhost:8080&#x2F;druid&#x2F;\n\n通过设置的用户名，密码进行登录，进入后台界面.\n\n整合MybatisSpringSecurity&#x3D;&#x3D;集成SpringSecurity&#x3D;&#x3D;\n安全简介在 Web 开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。\n市面上存在比较有名的：Shiro，Spring Security ！\n这里需要阐述一下的是，每一个框架的出现都是为了解决某一问题而产生了，那么Spring Security框架的出现是为了解决什么问题呢？\n首先我们看下它的官网介绍：Spring Security官网地址\nSpring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.\nSpring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements\nSpring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。\nSpring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求\n从官网的介绍中可以知道这是一个权限框架。想我们之前做项目是没有使用框架是怎么控制权限的？对于权限 一般会细分为功能权限，访问权限，和菜单权限。代码会写的非常的繁琐，冗余。\n怎么解决之前写权限代码繁琐，冗余的问题，一些主流框架就应运而生而Spring Scecurity就是其中的一种。\nSpring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。\n对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。\n测试\n\n创建springboot 项目 添加web，thymeleaf模块。\n\n导入静态资源\n\ncontroller跳转\npackage my.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class RouterController &#123;\n\n    @RequestMapping(&#123;&quot;&#x2F;&quot;,&quot;&#x2F;index&quot;&#125;)\n    public String index()&#123;\n        return &quot;index&quot;;\n    &#125;\n\n    @RequestMapping(&quot;&#x2F;toLogin&quot;)\n    public String login()&#123;\n        return &quot;views&#x2F;login&quot;;\n    &#125;\n\n    @RequestMapping(&quot;&#x2F;level1&#x2F;&#123;id&#125;&quot;)\n    public String level1(@PathVariable(&quot;id&quot;)int id)&#123;\n        return &quot;views&#x2F;level1&#x2F;&quot;+id;\n    &#125;\n\n    @RequestMapping(&quot;&#x2F;level2&#x2F;&#123;id&#125;&quot;)\n    public String level2(@PathVariable(&quot;id&quot;)int id)&#123;\n        return &quot;views&#x2F;level2&#x2F;&quot;+id;\n    &#125;\n\n    @RequestMapping(&quot;&#x2F;level3&#x2F;&#123;id&#125;&quot;)\n    public String level3(@PathVariable(&quot;id&quot;)int id)&#123;\n        return &quot;views&#x2F;level3&#x2F;&quot;+id;\n    &#125;\n&#125;\n\n\n测试实验环境\n\n\n认识SpringSecuritySpring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！\n记住几个类：\n\nWebSecurityConfigurerAdapter：自定义Security策略\nAuthenticationManagerBuilder：自定义认证策略\n@EnableWebSecurity：开启WebSecurity模式\n\nSpring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。\n“认证”（Authentication）\n身份验证是关于验证您的凭据，如用户名&#x2F;用户ID和密码，以验证您的身份。\n身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。\n “授权” （Authorization）\n授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。\n这个概念是通用的，而不是只在Spring Security 中存在。\n认证和授权目前，我们的测试环境是谁都可以访问的，我们使用SpringSecurity增加上认证和授权的功能\n\n引入Spring Security模块\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n编写Spring Security配置类\npackage my.config;\n\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\n\n@EnableWebSecurity\t\t&#x2F;&#x2F;开启WebSecurity模式\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n    &#x2F;&#x2F;链式编程\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n    &#125;\n&#125;\n\n定制请求的授权规则\npackage my.config;\n\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\n\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n    &#x2F;&#x2F;链式编程\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        &#x2F;&#x2F;首页所有人可以访问，功能页只对应优先权的人才能访问\n\n        &#x2F;&#x2F;请求授权的规则\n        http.authorizeRequests()\n                .antMatchers(&quot;&#x2F;&quot;).permitAll()\n                .antMatchers(&quot;&#x2F;level1&#x2F;**&quot;).hasRole(&quot;vip1&quot;)\n                .antMatchers(&quot;&#x2F;level2&#x2F;**&quot;).hasRole(&quot;vip2&quot;)\n                .antMatchers(&quot;&#x2F;level3&#x2F;**&quot;).hasRole(&quot;vip3&quot;);\n\n        &#x2F;&#x2F;没有权限，默认跳转到登录页,需要开启登录页面\n        http.formLogin();\n\n\n        http.logout().logoutSuccessUrl(&quot;&#x2F;&quot;);\n    &#125;\n&#125;\n\n\n\n\n测试，这时除了首页我们哪里都进不去，因为目前没有登录角色，请求需要登录的角色拥有对应的限权才可以。\n\n在configure中添加以下配置，开启自动配置的登录功能\npackage my.config;\n\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\n\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n    &#x2F;&#x2F;链式编程\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        &#x2F;&#x2F;首页所有人可以访问，功能页只对应优先权的人才能访问\n\n        &#x2F;&#x2F;请求授权的规则\n        http.authorizeRequests()\n                .antMatchers(&quot;&#x2F;&quot;).permitAll()\n                .antMatchers(&quot;&#x2F;level1&#x2F;**&quot;).hasRole(&quot;vip1&quot;)\n                .antMatchers(&quot;&#x2F;level2&#x2F;**&quot;).hasRole(&quot;vip2&quot;)\n                .antMatchers(&quot;&#x2F;level3&#x2F;**&quot;).hasRole(&quot;vip3&quot;);\n\n        &#x2F;&#x2F;没有权限，默认跳转到登录页,需要开启登录页面\n        http.formLogin();\n    &#125;\n&#125;\n\n\n测试：无限权时会跳转到登录页面。\n\n\n自定义登录规则：需要将&#x3D;&#x3D;前端传来的密码进行某种方式的加密&#x3D;&#x3D;，否则就无法登录。\npackage my.config;\n\n        import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\n        import org.springframework.security.config.annotation.web.builders.HttpSecurity;\n        import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n        import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n        import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\n\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n    &#x2F;&#x2F;链式编程\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        &#x2F;&#x2F;首页所有人可以访问，功能页只对应优先权的人才能访问\n\n        &#x2F;&#x2F;请求授权的规则\n        http.authorizeRequests()\n                .antMatchers(&quot;&#x2F;&quot;).permitAll()\n                .antMatchers(&quot;&#x2F;level1&#x2F;**&quot;).hasRole(&quot;vip1&quot;)\n                .antMatchers(&quot;&#x2F;level2&#x2F;**&quot;).hasRole(&quot;vip2&quot;)\n                .antMatchers(&quot;&#x2F;level3&#x2F;**&quot;).hasRole(&quot;vip3&quot;);\n\n        &#x2F;&#x2F;没有权限，默认跳转到登录页,需要开启登录页面\n        http.formLogin();\n\n\n        http.logout().logoutSuccessUrl(&quot;&#x2F;&quot;);\n    &#125;\n\n    &#x2F;&#x2F;认证，SpringBoot 2.1.x可以直接使用\n    &#x2F;&#x2F;密码编码 passwordEncoder\n    &#x2F;&#x2F;在Spring security 5.0+中新增了很多加密方法~\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n\n        &#x2F;&#x2F;数据正常从数据库中读\n        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())\n                .withUser(&quot;xoc001&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)\n                .and()\n                .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)\n                .and()\n                .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;);\n    &#125;\n&#125;\n\n\n权限控制和注销\n开启自动配置的注销功能\npackage my.config;\n\n        import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\n        import org.springframework.security.config.annotation.web.builders.HttpSecurity;\n        import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n        import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n        import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\n\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n    &#x2F;&#x2F;链式编程\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        &#x2F;&#x2F;首页所有人可以访问，功能页只对应优先权的人才能访问\n\n        &#x2F;&#x2F;请求授权的规则\n        http.authorizeRequests()\n                .antMatchers(&quot;&#x2F;&quot;).permitAll()\n                .antMatchers(&quot;&#x2F;level1&#x2F;**&quot;).hasRole(&quot;vip1&quot;)\n                .antMatchers(&quot;&#x2F;level2&#x2F;**&quot;).hasRole(&quot;vip2&quot;)\n                .antMatchers(&quot;&#x2F;level3&#x2F;**&quot;).hasRole(&quot;vip3&quot;);\n\n        &#x2F;&#x2F;没有权限，默认跳转到登录页,需要开启登录页面\n        http.formLogin();\n\n        &#x2F;&#x2F;开启注销功能。\n        &#x2F;&#x2F;logout注销请求\n        http.logout();\n    &#125;\n\n    &#x2F;&#x2F;认证，SpringBoot 2.1.x可以直接使用\n    &#x2F;&#x2F;密码编码 passwordEncoder\n    &#x2F;&#x2F;在Spring security 5.0+中新增了很多加密方法~\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n\n        &#x2F;&#x2F;数据正常从数据库中读\n        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())\n                .withUser(&quot;xoc001&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)\n                .and()\n                .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)\n                .and()\n                .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;);\n    &#125;\n&#125;\n\n\n\n\n在前端界面中增加一个注销功能按钮。\n&lt;!--注销--&gt;\n&lt;a class&#x3D;&quot;item&quot; th:href&#x3D;&quot;@&#123;&#x2F;logout&#125;&quot;&gt;\n    &lt;i class&#x3D;&quot;sign-out card icon&quot;&gt;&lt;&#x2F;i&gt; 注销\n&lt;&#x2F;a&gt;\n\n\n\n测试完成后，发现注销后会跳转到登录页面。思考：注销完如何跳转到首页\n\n添加配置，使注销完跳转到首页\nhttp.logut().logoutSuccessUrl(&quot;&#x2F;&quot;);\n\n测试：发现注销完，跳转到首页。\n\n需求：用户没有登录的时候，首页显示登录按钮。用户登录后，显示用户的名字和权限以及注销操作。以及显示对应用户可操作限权的功能。没有限权的共嫩不予显示。\n&#x3D;&#x3D;要结合thymeleaf中的一些功能&#x3D;&#x3D;    sec:authorize&#x3D;”isAuthenticated()“ 是否认证登录，来显示不同的页面。\n导入Maven依赖\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.thymeleaf.extras&#x2F;thymeleaf-extras-springsecurity5 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.thymeleaf.extras&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.0.4.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n修改前端页面，导入命名空间 \n&lt;html xmlns:sec&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&#x2F;thymeleaf-extras-springsecurity5&quot;&gt;&lt;&#x2F;html&gt;\n\n\n\n&lt;!--登录注销--&gt;\n&lt;div class&#x3D;&quot;right menu&quot;&gt;\n    &lt;!--未登录--&gt;\n    &lt;div sec:authorize&#x3D;&quot;!isAuthenticated()&quot;&gt;\n        &lt;a class&#x3D;&quot;item&quot; th:href&#x3D;&quot;@&#123;&#x2F;toLogin&#125;&quot;&gt;\n            &lt;i class&#x3D;&quot;address card icon&quot;&gt;&lt;&#x2F;i&gt; 登录\n        &lt;&#x2F;a&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;div sec:authorize&#x3D;&quot;isAuthenticated()&quot;&gt;\n        &lt;!--注销--&gt;\n        &lt;a class&#x3D;&quot;item&quot;&gt;\n            用户名：&lt;span sec:authentication&#x3D;&quot;name&quot;&gt;&lt;&#x2F;span&gt;\n            级别：&lt;span sec:authentication&#x3D;&quot;principal.authorities&quot;&gt;&lt;&#x2F;span&gt;\n        &lt;&#x2F;a&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div sec:authorize&#x3D;&quot;isAuthenticated()&quot;&gt;\n        &lt;!--注销--&gt;\n        &lt;a class&#x3D;&quot;item&quot; th:href&#x3D;&quot;@&#123;&#x2F;logout&#125;&quot;&gt;\n            &lt;i class&#x3D;&quot;sign-out card icon&quot;&gt;&lt;&#x2F;i&gt; 注销\n        &lt;&#x2F;a&gt;\n    &lt;&#x2F;div&gt;\n    &lt;!--已登录\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;usr&#x2F;toUserCenter&#125;&quot;&gt;\n&lt;i class&#x3D;&quot;address card icon&quot;&gt;&lt;&#x2F;i&gt; admin\n&lt;&#x2F;a&gt;\n--&gt;\n&lt;&#x2F;div&gt;\n\n\n如果注销了以后显示404，就是因为它默认方式csrf跨站请求伪造，因为会产生安全问题，我们可以将请求改为post表单提交，或者在spring security中关闭csrf功能； 跨站请求伪造（英语：Cross-site request forgery）\nhttp.csrf().disable();\t\t&#x2F;&#x2F;关闭csrf功能：跨站请求伪造，默认只能通过post方式提交logout请求。\n\n\n\n完成角色认证模块\n&lt;div&gt;\n    &lt;br&gt;\n    &lt;div class&#x3D;&quot;ui three column stackable grid&quot;&gt;\n        &lt;div class&#x3D;&quot;column&quot; sec:authorize&#x3D;&quot;hasRole(&#39;vip1&#39;)&quot;&gt;\n            &lt;div class&#x3D;&quot;ui raised segment&quot;&gt;\n                &lt;div class&#x3D;&quot;ui&quot;&gt;\n                    &lt;div class&#x3D;&quot;content&quot;&gt;\n                        &lt;h5 class&#x3D;&quot;content&quot;&gt;Level 1&lt;&#x2F;h5&gt;\n                        &lt;hr&gt;\n                        &lt;div&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;level1&#x2F;1&#125;&quot;&gt;&lt;i class&#x3D;&quot;bullhorn icon&quot;&gt;&lt;&#x2F;i&gt; Level-1-1&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;\n                        &lt;div&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;level1&#x2F;2&#125;&quot;&gt;&lt;i class&#x3D;&quot;bullhorn icon&quot;&gt;&lt;&#x2F;i&gt; Level-1-2&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;\n                        &lt;div&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;level1&#x2F;3&#125;&quot;&gt;&lt;i class&#x3D;&quot;bullhorn icon&quot;&gt;&lt;&#x2F;i&gt; Level-1-3&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;\n                    &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n            &lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n\n        &lt;div class&#x3D;&quot;column&quot; sec:authorize&#x3D;&quot;hasRole(&#39;vip2&#39;)&quot;&gt;\n            &lt;div class&#x3D;&quot;ui raised segment&quot;&gt;\n                &lt;div class&#x3D;&quot;ui&quot;&gt;\n                    &lt;div class&#x3D;&quot;content&quot;&gt;\n                        &lt;h5 class&#x3D;&quot;content&quot;&gt;Level 2&lt;&#x2F;h5&gt;\n                        &lt;hr&gt;\n                        &lt;div&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;level2&#x2F;1&#125;&quot;&gt;&lt;i class&#x3D;&quot;bullhorn icon&quot;&gt;&lt;&#x2F;i&gt; Level-2-1&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;\n                        &lt;div&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;level2&#x2F;2&#125;&quot;&gt;&lt;i class&#x3D;&quot;bullhorn icon&quot;&gt;&lt;&#x2F;i&gt; Level-2-2&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;\n                        &lt;div&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;level2&#x2F;3&#125;&quot;&gt;&lt;i class&#x3D;&quot;bullhorn icon&quot;&gt;&lt;&#x2F;i&gt; Level-2-3&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;\n                    &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n            &lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n\n        &lt;div class&#x3D;&quot;column&quot; sec:authorize&#x3D;&quot;hasRole(&#39;vip3&#39;)&quot;&gt;\n            &lt;div class&#x3D;&quot;ui raised segment&quot;&gt;\n                &lt;div class&#x3D;&quot;ui&quot;&gt;\n                    &lt;div class&#x3D;&quot;content&quot;&gt;\n                        &lt;h5 class&#x3D;&quot;content&quot;&gt;Level 3&lt;&#x2F;h5&gt;\n                        &lt;hr&gt;\n                        &lt;div&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;level3&#x2F;1&#125;&quot;&gt;&lt;i class&#x3D;&quot;bullhorn icon&quot;&gt;&lt;&#x2F;i&gt; Level-3-1&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;\n                        &lt;div&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;level3&#x2F;2&#125;&quot;&gt;&lt;i class&#x3D;&quot;bullhorn icon&quot;&gt;&lt;&#x2F;i&gt; Level-3-2&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;\n                        &lt;div&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;level3&#x2F;3&#125;&quot;&gt;&lt;i class&#x3D;&quot;bullhorn icon&quot;&gt;&lt;&#x2F;i&gt; Level-3-3&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;\n                    &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n            &lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n\n\n\n权限控制和注销搞定！\n\n\n记住我实现浏览器中记住账号密码的功能\n\n开启记住我功能\npackage my.config;\n\n        import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\n        import org.springframework.security.config.annotation.web.builders.HttpSecurity;\n        import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n        import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n        import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\n\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n    &#x2F;&#x2F;链式编程\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        &#x2F;&#x2F;首页所有人可以访问，功能页只对应优先权的人才能访问\n\n        &#x2F;&#x2F;请求授权的规则\n        http.authorizeRequests()\n                .antMatchers(&quot;&#x2F;&quot;).permitAll()\n                .antMatchers(&quot;&#x2F;level1&#x2F;**&quot;).hasRole(&quot;vip1&quot;)\n                .antMatchers(&quot;&#x2F;level2&#x2F;**&quot;).hasRole(&quot;vip2&quot;)\n                .antMatchers(&quot;&#x2F;level3&#x2F;**&quot;).hasRole(&quot;vip3&quot;);\n\n        &#x2F;&#x2F;没有权限，默认跳转到登录页,需要开启登录页面\n        http.formLogin();\n        \n        \n        &#x2F;&#x2F;关闭请求跨域。\n        http.csrf().disable();\n        http.logout().logoutSuccessUrl(&quot;&#x2F;&quot;);\n        \n        &#x2F;&#x2F;记住我\n        http.rememberMe();\n        \n    &#125;\n\n    &#x2F;&#x2F;认证，SpringBoot 2.1.x可以直接使用\n    &#x2F;&#x2F;密码编码 passwordEncoder\n    &#x2F;&#x2F;在Spring security 5.0+中新增了很多加密方法~\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n\n        &#x2F;&#x2F;数据正常从数据库中读\n        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())\n                .withUser(&quot;xoc001&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)\n                .and()\n                .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)\n                .and()\n                .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;);\n    &#125;\n&#125;\n\n\n\n\n测试，登录i页中多了一个记住我功能，勾选后关闭浏览器，重新打开，用户依旧存在。\n\n\n注销时，Spring Security会自动删除这个cookie。\n\n\n定制登录页上述使用的登录页面是Spring Security默认的，怎样才能使用我们自定义的登录页面呢？\n\n在之前的登录页配置后面添加配置\n&#x2F;&#x2F;没有权限，默认跳转到登录页,需要开启登录页面\nhttp.formLogin().loginPage(&quot;&#x2F;toLogin&quot;);\n\n\n\n前端也指向我们自定义的toLogin请求。\n&lt;!--未登录--&gt;\n&lt;div sec:authorize&#x3D;&quot;!isAuthenticated()&quot;&gt;\n    &lt;a class&#x3D;&quot;item&quot; th:href&#x3D;&quot;@&#123;&#x2F;toLogin&#125;&quot;&gt;\n        &lt;i class&#x3D;&quot;address card icon&quot;&gt;&lt;&#x2F;i&gt; 登录\n    &lt;&#x2F;a&gt;\n&lt;&#x2F;div&gt;\n\n\n\n登陆时，需要将这些数据发送到哪里，也需要我们手动配置，login.html配置请求及方式必须为post\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;index&#125;&quot; method&#x3D;&quot;post&quot;&gt;\n    &lt;div class&#x3D;&quot;field&quot;&gt;\n        &lt;label&gt;Username&lt;&#x2F;label&gt;\n        &lt;div class&#x3D;&quot;ui left icon input&quot;&gt;\n            &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;Username&quot; name&#x3D;&quot;username&quot;&gt;\n            &lt;i class&#x3D;&quot;user icon&quot;&gt;&lt;&#x2F;i&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;field&quot;&gt;\n        &lt;label&gt;Password&lt;&#x2F;label&gt;\n        &lt;div class&#x3D;&quot;ui left icon input&quot;&gt;\n            &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot;&gt;\n            &lt;i class&#x3D;&quot;lock icon&quot;&gt;&lt;&#x2F;i&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n    &lt;input type&#x3D;&quot;submit&quot; class&#x3D;&quot;ui blue submit button&quot;&#x2F;&gt;\n&lt;&#x2F;form&gt;A\n\n\n\n请求提交后，需要验证处理。配置接收登录的用户名和密码参数！\n&#x2F;&#x2F;没有权限，默认跳转到登录页,需要开启登录页面\n    http.formLogin().usernameParameter(&quot;username&quot;).passwordParameter(&quot;password&quot;).loginPage(&quot;&#x2F;toLogin&quot;).loginProcessingUrl(&quot;&#x2F;&quot;);\n\n在登录页面添加记住我的单选框\n&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;remember&quot;&gt; 记住我\n\n后端验证处理\n&#x2F;&#x2F;定制记住我的参数！\nhttp.rememberMe().rememberMeParameter(&quot;remember&quot;);\n\nShiro什么是Shiro？Apache Shiro 是 Java 的一个安全框架。目前，使用 Apache Shiro 的人越来越多，因为它相当简单，对比 Spring Security，可能没有 Spring Security 做的功能强大，但是在实际工作时 可能并不需要那么复杂的东西，所以使用小而简单的 Shiro 就足够了。对于它俩到底哪个好，这个不必纠结，能更简单的解决项目问题就好了。\n\nApache Shiro 是一个Java安全(限权)框架\nShiro可以非常容易地开发出足够好的应用，其不仅可以用在JavaSE环境，也可以运行在JavaEE环境。\nShiro可以完成：认证，授权，加密，会话管理，Web继承，缓存等。\n地址：Apache Shiro | Simple. Java. Security.\n\n基本功能\nAuthentication：身份认证&#x2F;登录，验证用户是不是拥有相应的身份； \nAuthorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用 户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用 户对某个资源是否具有某个权限； \nSession Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信 息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的；\n Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储； Web Support：Web 支持，可以非常容易的集成到 Web 环境； \nCaching：缓存，比如用户登录后，其用户信息、拥有的角色&#x2F;权限不必每次去查，这样可以提高效率；\nConcurrency：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能 把权限自动传播过去； \nTesting：提供测试支持； \nRun As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问； \nRemember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录 了。\nShiro架构架构(外部)\n可以看到：应用代码直接交互的对象是Subject。也就是说Shrio对外的API核心就是Subject；\nAPI含义\nSubject：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互 的任何东西都是 Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定 到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认 为是一个门面；SecurityManager 才是实际的执行者；\nSwagger\n新建SpringBoot 项目\n\n导入相关依赖\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger2 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger-ui --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n编写HelloWorld工程\n\n配置Swagger  &#x3D;&gt; Config\npackage my.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\n@Configuration\n&#x2F;&#x2F;开启Swagger2\n@EnableSwagger2\npublic class SwaggerConfig &#123;\n\n\n&#125;\n\n\n\n测试运行\n\n\n\n配置SwaggerSwagger配置实例 docket\n@Configuration\n&#x2F;&#x2F;开启Swagger2\n@EnableSwagger2\npublic class SwaggerConfig &#123;\n\n    @Bean\n    public Docket docket()&#123;\n        return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());\n    &#125;\n\n    private ApiInfo apiInfo()&#123;\n        Contact contact &#x3D; new Contact(&quot;Xoc001&quot;,&quot;http:&#x2F;&#x2F;www.baidu.com&quot;,&quot;635996171@qq.com&quot;);\n        return  new ApiInfo(&quot;Xoc001 文档测试&quot;\n                , &quot;ABCDEFG&quot;\n                , &quot;v1.0&quot;\n                , &quot;Xoc001&quot;\n                , contact\n                , &quot;Apache 2.0&quot;\n                , &quot;http:&#x2F;&#x2F;www.baidu.com&quot;\n                , new ArrayList()\n        );\n    &#125;\n&#125;\n\n\n\nSwagger配置扫描接口Swagger分组的接口@Api()\n@ApiModel()\n@ApiModelproperty()\n@ApiOperation()\n异步任务邮件任务&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-mail&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\nspring.mail.username&#x3D;635996171@qq.com\nspring.mail.password&#x3D; &#x2F;&#x2F;授权码\nspring.mail.host&#x3D;smtp.qq.com\n\n\n\npackage my;\n\n@SpringBootTest\nclass Springboot10AsyncApplicationTests &#123;\n\n    @Autowired\n    JavaMailSender mailSender;\n\n    @Test\n    void contextLoads() &#123;\n        SimpleMailMessage mailMessage &#x3D; new SimpleMailMessage();\n        mailMessage.setSubject(&quot;联盟紧急通知&quot;);\n        mailMessage.setText(&quot;上号！&quot;);\n\n        mailMessage.setFrom(&quot;635996171@qq.com&quot;);\n        mailMessage.setTo(&quot;635996171@qq.com&quot;);\n\n        mailSender.send(mailMessage);\n    &#125;\n\n    @Test\n    void contextLoads1() throws MessagingException &#123;\n\n        MimeMessage mimeMessage &#x3D; mailSender.createMimeMessage();\n\n        MimeMessageHelper helper &#x3D; new MimeMessageHelper(mimeMessage, true);\n\n        helper.addAttachment(&quot;1.jpg&quot;,new File(&quot;C:\\\\Users\\\\Xoc001\\\\Desktop\\\\图片素材\\\\0.jpg&quot;));\n\n        helper.setSubject(&quot;通知通知通知！&quot;);\n        helper.setText(&quot;&lt;h1 style&#x3D;&#39;color:red&#39;&gt;银河战争!&lt;&#x2F;h1&gt;&quot;,true);\n\n        helper.setFrom(&quot;635996171@qq.com&quot;);\n        helper.setTo(&quot;635996171@qq.com&quot;);\n\n        mailSender.send(mimeMessage);\n\n    &#125;\n&#125;\n\n\n\n\n定时任务crom\n计划任务，是任务在约定的时间执行已经计划好的工作，这是表面的意思。在Linux中，我们经常用到 cron 服务器来完成这项工作。cron服务器可以根据配置文件约定的时间来执行特定的任务。\n表达式 \n&#x2F;&#x2F;表达式： 秒 分 时 日 月 星期 年\n@Scheduled(cron &#x3D;&quot;0 * * * * * * &quot;)\n\n使用：启动类上表明@EnableScheduling\n@SpringBootApplication\n@EnableAsync\t\t&#x2F;&#x2F;开启异步注解\n@EnableScheduling\t\t&#x2F;&#x2F;开启定时任务注解\npublic class Springboot10AsyncApplication &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Springboot10AsyncApplication.class, args);\n    &#125;\n\n&#125;\n\n\n\npackage my.service;\n\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Service;\n\n@Service\t&#x2F;&#x2F;@Service注解\npublic class ScheduledService &#123;\n\n    &#x2F;&#x2F;计划注解\n    @Scheduled(cron &#x3D; &quot;0&#x2F;5 34 21 * * ?&quot;)\n    public void hello()&#123;\n        System.out.println(&quot;hello world&quot;);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\nDubbo+ZooKepper 集成分布式理论什么是分布式系统？在《分布式系统原理与范型》一书中有如下定义：“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”；\n分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。\n分布式系统（distributed system）是建立在网络之上的软件系统。\n首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。。。\nDubbo文档随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需一个治理系统确保架构有条不紊的演进。\n在Dubbo的官网文档有这样一张图\n\n单一应用架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。\n\n适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。\n缺点：\n1、性能扩展比较难\n2、协同开发问题\n3、不利于升级维护\n垂直应用架构当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。\n\n通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。\n缺点：公用模块无法重复利用，开发性的浪费\n分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键。\n\n流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键。\n\n什么是RPCRPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。\n也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数&#x2F;方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数；\n推荐阅读文章：https://www.jianshu.com/p/2accc2840a1b\nRPC基本原理\n\n步骤解析：\n\nRPC两个核心模块：通讯，序列化。\n测试环境搭建Dubbo：Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。\ndubbo官网 http://dubbo.apache.org/zh-cn/index.html\n1.了解Dubbo的特性\n2.查看官方文档\nDubbo基本概念\n服务提供者（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。\n服务消费者（Consumer）：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者\n监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心\n调用关系说明\n\n服务容器负责启动，加载，运行服务提供者。\n\n服务提供者在启动时，向注册中心注册自己提供的服务。\n\n服务消费者在启动时，向注册中心订阅自己所需的服务。\n\n注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。\n\n服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n\n服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n\nDubbo环境搭建推荐使用&#x3D;&#x3D;ZooKeeper&#x3D;&#x3D;注册中心\nZookeeper官方文档：Zookeeper 注册中心 | Apache Dubbo\nWindows安装zookeeper\n下载zookeeper：Index of &#x2F;zookeeper (apache.org)\n这里解压到D盘根目录下。\n\n运行文件：D:\\apache-zookeeper-3.7.0-bin\\bin\\zkServer.cmd。\n可能会发生的问题：闪退！\n解决方法：在zkServer.cmd文件末尾添加pause。这样运行出错后，就不会闪退。\n\n\n报错\n\n解决办法：在D:\\apache-zookeeper-3.7.0-bin\\conf目录下添加zoo.cfg文件。\n\ntickTime&#x3D;2000\ninitLimit&#x3D;10\nsyncLimit&#x3D;5\n#临时数据存储目录\ndataDir&#x3D;&#x2F;tmp&#x2F;zookeeper\n#zookeeper的端口号\nclientPort&#x3D;2181\n\n\n\n\n\n修改完成后，重新运行zkServer.cmd\n\n使用zkCli.cmd测试：\n&#x3D;&#x3D;ls /  ：查看节点&#x3D;&#x3D;\n\n&#x3D;&#x3D;create -e /xoc001 123 ：创建一个xoc001的节点，值为123&#x3D;&#x3D;\n\n&#x3D;&#x3D;get /xoc001 ：获取&#x2F;xoc001节点的值。&#x3D;&#x3D;\n\n\n\nWindows安装Dubbo-admin\n下载地址：apache&#x2F;dubbo-admin at master-0.2.0 (github.com)\n\n进入解压目录：D:\\dubbo-admin-master-0.2.0\\dubbo-admin\\src\\main\\resources\\application.properties 指定zookeeper地址\nserver.port=7001\nspring.velocity.cache=false\nspring.velocity.charset=UTF-8\nspring.velocity.layout-url=/templates/default.vm\nspring.messages.fallback-to-system-locale=false\nspring.messages.basename=i18n/message\nspring.root.password=root\nspring.guest.password=guest\n\n#注册中心地址\ndubbo.registry.address=zookeeper://127.0.0.1:2181\n\n\n在项目目录下打包 dubbo-admin\n&#x3D;&#x3D;mvn clean package -Dmaven.test.skip=true&#x3D;&#x3D;\n\n执行D:\\dubbo-admin-master-0.2.0\\dubbo-admin\\target\\dubbo-admin-0.0.1-SNAPSHOT.jar文件。\n\n注意：zookeeper的服务器一定要打开。\n\n\n运行完毕，进入页面测试\n\n\n执行完毕，我们去访问一下 http://localhost:7001/ ， 这时候我们需要输入登录账户和密码，我们都是默认的root-root；登陆成功，查看页面。\n\n\n安装完成。\n\n\n","slug":"SpringBoot","date":"2022-02-10T17:38:23.869Z","categories_index":"","tags_index":"","author_index":"Xoc001"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Spring21.8.7\n1、Spring1.1、简介&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework&#x2F;spring-webmvc --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.3.9&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework&#x2F;spring-webmvc --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.3.9&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n1.2、优点\nSpring 是一个开源的免费的框架\nSpring是一个轻量级的、非入侵式的框架\n控制反转(IOC)、面向切面编程(AOP)\n支持事务的处理，对框架整合的支持。\n\n总结：Spring就是一个轻量级的控制反转(IOC)和面向切面编程(AOP)框架\n1.3、组成\n1.4、拓展\nSpring  Boot \n一个快速开发的框架\n基于SpringBoot可以快速的开发单个微服务\n约定大于配置！\n\n\nSpring Cloud\nSpring Cloud是基于SpringBoot实现的\n\n\n\n学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！\n2、IOC理论推导\nUserDao 接口\n\nUserDaoImpl 实现类\n\nUserService 业务接口\n\nUserServiceImpl 业务实现类\n\n\n\n在之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求修改原代码！如果代码量大，修改一次的成本十分昂贵\n\n利用Set接口实现\n\n    private UserDao userDao;\n\n&#x2F;&#x2F;利用set进行动态实现值的注入！\n    public void setUserDao(UserDao userDao) &#123;\n        this.userDao &#x3D; userDao;\n    &#125;\n\n\n之前是程序主动创建对象，控制权在程序员手中！\n利用set注入后，程序不再具有主动性，变成被动的接收对象。\n这种思想从本质上解决了问题，使得程序员不用去管理对象的创建。系统的耦合性大大降低，使得程序员专注业务的实现。 这是IOC原型\nIOC本质控制反转IOC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IOC的一种方法。没有IOC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓的控制反转就是：获取依赖对象的方式反转了。 \n\nIOC是Spring的核心内容，使用多种方式完美的实现了IOC,可以使用XML配置，也可以使用注解，新版本的Spring可以零配置实现IOC。\n\n对象是由Spring创建的\n对象的属性是由Spring容器设置的\n\n&#x3D;&#x3D;这个过程就叫控制反转：&#x3D;&#x3D;\n\n控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的。\n反转：程序本身不创建对象，而变成被动接收对象。\n依赖注入：就是利用&#x3D;&#x3D;set&#x3D;&#x3D;方法来进行注入。\n\n&#x3D;&#x3D;IOC是一种编程思想，由主动的创建变成被动的接收&#x3D;&#x3D;\n&#x3D;&#x3D;对象由Spring创建，管理，装配！&#x3D;&#x3D;\n3、IOC创建对象的方式使用Spring方式从创建对象xml配置\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n    &lt;!-- id &#x3D; 变量名，class&#x3D; new的对象 --&gt;\n    &lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;my.pojo.Student&quot;&gt;\n        &lt;!-- property name 是类中属性的名称 ref 元素是指另一个bean定义的名称，value是具体值，基本数据类型。 对类中的属性进行赋值--&gt;\n        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;百度&quot;&gt;&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;id&quot; value&#x3D;&quot;2022&quot;&gt;&lt;&#x2F;property&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n在运行类中\npackage my;\n\nimport my.pojo.Student;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class MyTest &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;获取Spring的上下文对象\n        ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n        &#x2F;&#x2F;需要的对象已经被spring接管，需要什么值从上下文对象中取\n        Student student &#x3D; (Student) context.getBean(&quot;student&quot;);\n        System.out.println(student.toString());\n    &#125;\n&#125;\n\n\n\n\n\n使用无参构造创建对象，默认！\n使用有参构造创建对象。\n下标赋值\n&lt;!--    1.下标赋值--&gt;\n    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;my.pojo.User&quot;&gt;\n        &lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;BAIDU&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n类型赋值\n\n\n&lt;!--    2.使用类型赋值，一般不建议使用(两个String 无法识别)--&gt;\n    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;my.pojo.User&quot;&gt;\n        &lt;constructor-arg type&#x3D;&quot;java.lang.String&quot; value&#x3D;&quot;afjklaksldfj&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n\n直接通过参数名设置\n\n&lt;!--    3.使用参数名赋值--&gt;\n    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;my.pojo.User&quot;&gt;\n        &lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;阿富汗的&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n&#x3D;&#x3D;在配置文件加载时，容器中管理的对象就被实例化了。内存中只有一份实例。&#x3D;&#x3D;\n4、Spring配置4.1、别名&lt;alias name&#x3D;&quot;user&quot; alias&#x3D;&quot;asdfadfadfa&quot;&#x2F;&gt;\n\n\n\n4.2、Bean的配置&lt;!-- id: bean的唯一标识符，也就是对象名\n    class：bean对象所对应的全限定名：包名+类型\n    name：别名，可以接收多个别名\n\n--&gt;\n    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;my.pojo.User&quot; name&#x3D;&quot;user2 user1123,123;xoc&quot;&gt;\n        &lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;ABCCC&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n\n\n4.3、import可以用import将所有人的beans.xml合并为一个\n&lt;import resource&#x3D;&quot;beans1.xml&quot;&#x2F;&gt;\n&lt;import resource&#x3D;&quot;beans2.xml&quot;&#x2F;&gt;\n&lt;import resource&#x3D;&quot;beans3.xml&quot;&#x2F;&gt;\n \n\n\n\n5、依赖注入5.1、构造器注入&lt;constructor-arg &#x2F;&gt;\n\t&lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;阿富汗的&quot;&#x2F;&gt;\n\n\n\n5.2、Set方式注入【重点】\n依赖注入：Set注入\n依赖：bean对象的创建依赖于容器！\n注入：bean对象中的所有属性，都由容器来注入！\n\n\n\n【环境搭建】\n\n复杂类型\n\npublic class Address &#123;\n    private String address;\n\n    public String getAddress() &#123;\n        return address;\n    &#125;\n\n    public void setAddress(String address) &#123;\n        this.address &#x3D; address;\n    &#125;\n&#125;\n\n\n真实测试对象\n\npackage my.pojo;\n\nimport java.util.*;\n\npublic class Student &#123;\n    private String name;\n    private Address address;\n    private String[] books;\n    private List&lt;String&gt; hobbys;\n    private Map&lt;String,String&gt; card;\n    private Set&lt;String&gt; games;\n    private String wife;\n    private Properties info;\n&#125;\n\n\n\nbeans.xml\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\n    &lt;bean id&#x3D;&quot;address&quot; class&#x3D;&quot;my.pojo.Address&quot;&gt;\n        &lt;property name&#x3D;&quot;address&quot; value&#x3D;&quot;邢台&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;my.pojo.Student&quot;&gt;\n        &lt;!--    第一种，普通值直接value 赋值 --&gt;\n        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;百度一下你就知道&quot;&#x2F;&gt;\n        &lt;!--    bean 注入，ref   --&gt;\n        &lt;property name&#x3D;&quot;address&quot; ref&#x3D;&quot;address&quot;&#x2F;&gt;\n        &lt;!--   数组注入     --&gt;\n        &lt;property name&#x3D;&quot;books&quot;&gt;\n            &lt;array&gt;\n                &lt;value&gt;红楼梦&lt;&#x2F;value&gt;\n                &lt;value&gt;三国演义&lt;&#x2F;value&gt;\n                &lt;value&gt;水浒传&lt;&#x2F;value&gt;\n                &lt;value&gt;西游记&lt;&#x2F;value&gt;\n            &lt;&#x2F;array&gt;\n        &lt;&#x2F;property&gt;\n\n&lt;!--      List  --&gt;\n        &lt;property name&#x3D;&quot;hobbys&quot;&gt;\n            &lt;list&gt;\n                &lt;value&gt;篮球&lt;&#x2F;value&gt;\n                &lt;value&gt;足球&lt;&#x2F;value&gt;\n                &lt;value&gt;听歌&lt;&#x2F;value&gt;\n            &lt;&#x2F;list&gt;\n        &lt;&#x2F;property&gt;\n\n&lt;!--        Map--&gt;\n        &lt;property name&#x3D;&quot;card&quot;&gt;\n            &lt;map&gt;\n                &lt;entry key&#x3D;&quot;身份证&quot; value&#x3D;&quot;130100101010010101&quot;&gt;&lt;&#x2F;entry&gt;\n                &lt;entry key&#x3D;&quot;银行卡&quot; value&#x3D;&quot;1231231234990&quot;&gt;&lt;&#x2F;entry&gt;\n            &lt;&#x2F;map&gt;\n        &lt;&#x2F;property&gt;\n\n&lt;!--        Set--&gt;\n        &lt;property name&#x3D;&quot;games&quot;&gt;\n            &lt;set&gt;\n                &lt;value&gt;LOL&lt;&#x2F;value&gt;\n                &lt;value&gt;COC&lt;&#x2F;value&gt;\n                &lt;value&gt;CF&lt;&#x2F;value&gt;\n            &lt;&#x2F;set&gt;\n        &lt;&#x2F;property&gt;\n\n&lt;!--        String--&gt;\n        &lt;property name&#x3D;&quot;wife&quot;&gt;\n            &lt;null&#x2F;&gt;\n        &lt;&#x2F;property&gt;\n\n        &lt;property name&#x3D;&quot;info&quot;&gt;\n            &lt;props&gt;\n                &lt;prop key&#x3D;&quot;学号&quot;&gt;20210001&lt;&#x2F;prop&gt;\n                &lt;prop key&#x3D;&quot;phone&quot;&gt;13800012345&lt;&#x2F;prop&gt;\n                &lt;prop key&#x3D;&quot;password&quot;&gt;123456&lt;&#x2F;prop&gt;\n            &lt;&#x2F;props&gt;\n        &lt;&#x2F;property&gt;\n    &lt;&#x2F;bean&gt;\n\n\n&lt;&#x2F;beans&gt;\n\n&#x3D;&#x3D;结果&#x3D;&#x3D;\n&#x2F;*\n* Student&#123;\n* name&#x3D;&#39;百度一下你就知道&#39;,\n* address&#x3D;Address&#123;address&#x3D;&#39;邢台&#39;&#125;,\n* books&#x3D;[红楼梦, 三国演义, 水浒传, 西游记],\n* hobbys&#x3D;[篮球, 足球, 听歌],\n* card&#x3D;&#123;身份证&#x3D;130100101010010101, 银行卡&#x3D;1231231234990&#125;,\n* games&#x3D;[LOL, COC, CF],\n* wife&#x3D;&#39;null&#39;,\n* info&#x3D;&#123;学号&#x3D;20210001, phone&#x3D;13800012345, password&#x3D;123456&#125;&#125;\n*&#x2F;\n\n\n\n5.3、拓展方式注入p命名空间和c命名空间进行注入。(不能直接使用，需要导入xml约束)！\nxmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;\nxmlns:c&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;c&quot;\n\n配置：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;\n       xmlns:c&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;c&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\t&lt;!-- p命名空间注入，可以直接注入属性的值：property--&gt;\n    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;my.pojo.User&quot; p:age&#x3D;&quot;18&quot; p:name&#x3D;&quot;abc&quot;&#x2F;&gt;\n    &lt;!-- c命名空间注入，通过构造器注入：construct-args --&gt;\n    &lt;bean id&#x3D;&quot;user2&quot; class&#x3D;&quot;my.pojo.User&quot; c:age&#x3D;&quot;19&quot; c:name&#x3D;&quot;askdfk&quot;&#x2F;&gt;\n&lt;&#x2F;beans&gt;\n\n测试 \npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n        User user &#x3D; context.getBean(&quot;user2&quot;, User.class);\n        System.out.println(user);\n    &#125;\n&#125;\n\n5.4、bean的作用域\n\n单例模式(Spring 默认机制)\n\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;my.pojo.User&quot; p:age&#x3D;&quot;18&quot; p:name&#x3D;&quot;abc&quot; scope&#x3D;&quot;singleton&quot;&#x2F;&gt;\n\n原型模式：每次从容器中get的时候，都会从产生一个新的对象！\n\n\n\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;my.pojo.User&quot; p:age&#x3D;&quot;18&quot; p:name&#x3D;&quot;abc&quot; scope&#x3D;&quot;prototype&quot;&#x2F;&gt;\n\n\nrequest、session、application、websocket 在web 中使用。\n\n6、Bean自动装配\n自动装配是Spring满足bean依赖的一种方式！\nSpring会在上下文中自动寻找，并自动给bean装配属性！\n\n6.1、测试6.2、ByName 自动装配&lt;!--\n       byName：会自动在容器上下文中查找 和自己对象set方法名一样的 beanId\n       byType：会自动在容器上下文中查找 和自己对象属性相同的 bean\n\n--&gt;\n\n\t&lt;bean id&#x3D;&quot;cat&quot; class&#x3D;&quot;my.pojo.Cat&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;dog&quot; class&#x3D;&quot;my.pojo.Dog&quot;&#x2F;&gt;\n\n\t&lt;bean id&#x3D;&quot;people&quot; class&#x3D;&quot;my.pojo.People&quot; autowire&#x3D;&quot;byName&quot;&gt;\n        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;abc&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n\n\n6.3、ByType自动装配&lt;!--\n       byName：会自动在容器上下文中查找 和自己对象set方法名一样的 beanId\n       byType：会自动在容器上下文中查找 和自己对象属性相同的 bean\n\n--&gt;\n\t&lt;bean id&#x3D;&quot;cat&quot; class&#x3D;&quot;my.pojo.Cat&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;dog111&quot; class&#x3D;&quot;my.pojo.Dog&quot;&#x2F;&gt;\n\n    &lt;bean id&#x3D;&quot;people&quot; class&#x3D;&quot;my.pojo.People&quot; autowire&#x3D;&quot;byType&quot;&gt;\n        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;abc&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n小结：\n&#x3D;&#x3D;byName 时，需要保证所有bean的id 唯一，并且这个bean需要和自动注入的属性的set方法的名称一致！&#x3D;&#x3D;\n&#x3D;&#x3D;byType时，需要保证所有bean的class 唯一，并且这个bean需要和自动注入的set方法参数的类型一致！&#x3D;&#x3D;\n\n6.4、使用注解实现自动装配使用注解须知：\n\n导入约束：context约束\n配置注解的约束：&#x3D;&#x3D;context:annotation-config/&#x3D;&#x3D;\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n    xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;\n\n    &lt;context:annotation-config&#x2F;&gt;\n\n&lt;&#x2F;beans&gt;\n\n@Autowird\n在属性上使用即可！也可以在set方式上使用\n使用Autowird 可以不用编写set方法，前提是自动装配的属性在IOC(Spring)容器中存在，且符合类型byType\n@Nullable  这个字段可以为null\n@AutoWired(required &#x3D;false)\n\npublic @interface Autowired &#123;\n    boolean required() default true;\n&#125;\n\n测试代码\npublic class People &#123;\n    private String name;\n    @Autowired\n    private Cat cat;\n    @Autowired\n    private Dog dog;\n&#125;\n\n\n\n如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候、我们可以使用@Qualifier(value&#x3D;”xxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入\npublic class People &#123;\n    private String name;\n    @Autowired\n    private Cat cat;\n    @Autowired\n    @Qualifier(value &#x3D; &quot;dog222&quot;)\n    private Dog dog;\n&#125;\n\n&#x3D;&#x3D;@Autowire 先使用byType，如果唯一则注入，否则用byName查找。&#x3D;&#x3D;\n@Resource注解\npublic class People &#123;\n    private String name;\n    @Resource\n    private Cat cat;\n\n    @Resource\n    private Dog dog;\n&#125;\n\n\n\n小结：@Resource和@Autowired的区别\n\n都可以放在属性字段上，用来自动装配\n&#x3D;&#x3D;@Autowired 先使用byType，如果唯一则注入，否则用byName查找。&#x3D;&#x3D;\n&#x3D;&#x3D;@Resource 默认通过byName方式实现，如果找不到名字，则通过byType方式实现， 如果两个都找不到则报错。&#x3D;&#x3D;\n\n7、使用注解开发在Spring4之后，要使用注解开发，必须要保证aop的包导入。使用注解需要导入context约束，增加注解支持\n\nbean\n@Component\npublic class User &#123;\n    public String name;\n&#125;\n\n\n\n属性如何注入\npublic class User &#123;\n    @Value(&quot;百度一下，你就知道&quot;)\n    public String name;\n&#125;\n\n\n\n衍生的注解\n@Component 有几个衍生注解，在web开发中，会按照mvc三层架构分层\n\nDao层：@Repository\n\nService层：@Service\n\ncontroller层：@Controller\n&#x3D;&#x3D;这四个注解功能都是一样的，都是将代表某个类注册到Spring中，装配Bean&#x3D;&#x3D;\n\n\n\n自动装配\n@Autowired ： 通过类型、名字，自动装配对象\n@Nullable：字段标记注解，说明这个字段可以为null\n@Resource： 通过名字、类型，自动装配对象\n    \n\n作用域\n@Scope(&quot; &quot;) singleton单例模式，  prototype多例\n\n小结\n\n\nxml与注解\n\nxml更万能，适用于任何场合！维护方便\n注解 不是自己的类使用不了，维护相对复杂！\n\nxml与注解的最佳实践：\n\nxml用来管理bean；\n注解只负责完成属性的注入；\n在使用过程中，只需要注意一个问题，必须让注解生效， 就需要开启注解的支持\n\n&lt;!--    指定要扫描的包，包下的注解就会生效--&gt;\n    &lt;context:component-scan base-package&#x3D;&quot;my.pojo&quot;&#x2F;&gt;\n    &lt;context:annotation-config&#x2F;&gt;\n\n\n\n\n\n\n注解说明\n\n@Autowired ： 通过类型、名字，自动装配对象\n\n@Nullable：字段标记注解，说明这个字段可以为null\n\n@Resource： 通过名字、类型，自动装配对象\n\n@Component：组件，放在类上，说明Spring 被管理了，就是bean\n\n\n8、使用Java的方式配置Spring不使用xml配置，全权交给java来做！\n实体类package my.pojo;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class User &#123;\n    private String name;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    @Value(&quot;ajkdjaklj&quot;)\n    public void setName(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;\n\n\n配置文件package my.config;\n\nimport my.pojo.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n&#x2F;&#x2F;会被Spring 容器托管，注册到容器中，本身就是一个 @Component\n&#x2F;&#x2F;@Configuration代表一个配置类，相当于applicationContext.xml\n\n@Configuration\npublic class MyConfig &#123;\n\n    &#x2F;&#x2F;相当于&lt;bean id&#x3D;&quot;getUser&quot; class&#x3D;&quot;my.pojo.User&#x2F;&gt;\n    &#x2F;&#x2F;这个方法中的名字，就相当于bean标签中的ID，\n    &#x2F;&#x2F; 方法中的返回值相当于bean标签中的class属性。\n\n    @Bean\n    public User getuser()&#123;\n        return new User();      &#x2F;&#x2F;返回要注入到bean的对象\n    &#125;\n&#125;\n\n\n测试类package my;\n\nimport my.config.MyConfig;\nimport my.pojo.User;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class MyTest &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;如果完全使用了配置类方式去做，我们就只能通过AnnotationConfig 上下文来获取容器，通过配置类的Class对象加载！\n        ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(MyConfig.class);\n        &#x2F;*\n        *    使用Configuration注解，代表这是一个配置类。相当于applicationContext.xml\n        *    使用@Bean注解在配置类中声明在方法上后，getBean时调用方法名，即可获取对象。  @Bean就是相当于xml中的一个bean标签。，方法名字就是id属性，返回值就是class属性\n        *    使用@Component注解，在注解类中添加@ComponentScan(类路径),getBean时调用类名(小写)，即可获取对象\n        *\n        *\n        *&#x2F;\n        User user &#x3D; (User) context.getBean(&quot;user&quot;);\n        User user1 &#x3D; (User)context.getBean(&quot;getUser&quot;);\n\n        System.out.println(user&#x3D;&#x3D;user1);\n    &#125;\n&#125;\n\n\n&#x3D;&#x3D;纯Java的配置方式，在SpringBoot中随处可见！&#x3D;&#x3D;\n使用@Configuration声明配置类时，两种方法来生成Bean：\n\n在配置类中定义一个方法，用@Bean来注解声明\n在User类上用@Component注解，并在配置类上@ComponentScan(“User类的路径”),这样会自动扫描包，getBean的时候使用的id就是类名的小写。\n\n9、代理模式代理模式，SpringAOP底层。\n代理模式的分类：\n\n静态代理\n动态代理\n\n\n9.1、静态代理角色分析：\n\n抽象角色：一般会使用接口或者抽象类来解决。\n真实角色：被代理的角色\n代理角色：代理真实角色，代理真实角色后，做一些附属操作。\n客服：访问代理对象的人。\n\n代码步骤：\n\n接口\npublic interface Rent&#123;\n    void rent();\n&#125;\n\n\n\n真实角色\npublic class Host implements Rent &#123;\n    public void rent()&#123;\n        System.out.println(&quot;房东要出租房子&quot;);\n    &#125;\n&#125;\n\n\n\n代理角色\npackage my.demo01;\n\npublic class Proxy &#123;\n    private Host host;\n\n    public Proxy() &#123;\n    &#125;\n\n    public Proxy(Host host) &#123;\n        this.host &#x3D; host;\n    &#125;\n\n    &#x2F;&#x2F;代理中介转租房子\n    public void rent()&#123;\n        seeHouse();\n        host.rent();\n        contract();\n        fee();\n    &#125;\n\n    &#x2F;&#x2F;添加额外服务\n    private void fee()&#123;\n        System.out.println(&quot;中介收取中介费&quot;);\n    &#125;\n\n    private void seeHouse()&#123;\n        System.out.println(&quot;中介带领看房。&quot;);\n    &#125;\n\n    private void contract()&#123;\n        System.out.println(&quot;签订合同&quot;);\n    &#125;\n&#125;\n\n\n\n\n客户端访问代理角色\npackage my.demo01;\n\npublic class Client &#123;\n    public static void main(String[]args)&#123;\n        \n     \t &#x2F;&#x2F;房东出租房子\n        Host host &#x3D; new Host();\n        &#x2F;&#x2F;代理，中介帮房东出租房子，并附加额外操作\n        Proxy proxy &#x3D; new Proxy(host);\n\n       &#x2F;&#x2F;面向中介租房\n        proxy.rent();\n    &#125;\n&#125;\n\n代理模式的好处：\n\n可以使真实的角色的操作更加纯粹！不用关注一些公共业务\n公共业务交给代理角色，实现业务分工\n公共业务发生扩展时，方便集中管理\n\n缺点：\n\n一个真实角色就会产生一个代理角色，代码量增加，开发效率变低。\n\n在不破坏原有代码的基础上，利用”织入“的模式来实现代码的动态设置\n&#x3D;&#x3D;AOP(面向切面编程)&#x3D;&#x3D;\n\n9.2、动态代理\n动态代理和静态代理角色一样。\n抽象角色：一般会使用接口或者抽象类来解决。\n真实角色：被代理的角色\n代理角色：代理真实角色，代理真实角色后，做一些附属操作。\n客服：访问代理对象的人。\n\n\n动态代理的代理类是动态生成的，不是我们直接写好的。\n动态代理分为两大类：&#x3D;&#x3D;基于接口的动态代理，基于类的动态代理&#x3D;&#x3D;\n基于接口 —JDK动态代理\n基于类：cglib\njava字节码实现： &#x3D;&#x3D;JAVAssist&#x3D;&#x3D;\n\n\n\nProxy：生成动态代理实例\nInvocationHandler： 调用处理程序并返回结果\n动态代理的好处\n\n可以使真实的角色的操作更加纯粹！不用关注一些公共业务\n公共业务交给代理角色，实现业务分工\n公共业务发生扩展时，方便集中管理\n一个动态代理类代理的是一个接口，一般就是对应的一类业务\n一个动态代理类可以代理多个类，只要是实现了同一个接口\n\npackage my.demo04;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class ProxyInvocationHandler implements InvocationHandler &#123;\n\n    private Object target;\n\n    public void setTarget(Object target) &#123;\n        this.target &#x3D; target;\n    &#125;\n\n    public Object getProxy() &#123;\n        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this);\n    &#125;\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        log(method.getName());\n        Object invoke &#x3D; method.invoke(target, args);\n        return invoke;\n    &#125;\n\n    public void log(String msg)&#123;\n        System.out.println(&quot;执行了&quot; + msg + &quot;方法&quot;);\n    &#125;\n&#125;\n\n\n\n\npackage my.demo04;\n\nimport my.demo02.UserService;\nimport my.demo02.UserServiceImpl;\n\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        UserServiceImpl userService &#x3D; new UserServiceImpl();\n\n        ProxyInvocationHandler pih &#x3D; new ProxyInvocationHandler();\n        pih.setTarget(userService);\n        UserService proxy &#x3D; (UserService) pih.getProxy();\n\n        proxy.add();\n    &#125;\n&#125;\n\n\n\n\n\n\n10、AOP10.1、什么是AOPAOP（Aspect Oriented Prigramming）面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术，AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生泛型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可用性，同时提高了开发效率。\n\n11.2 AOP在Spring中的作用\n&#x3D;&#x3D;提供声明式事务；允许用户自定义切面&#x3D;&#x3D;\n\n横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等…\n切面(Aspect) ：横切关注点 被模块化的特殊对象，即，它是一个类\n通知(Adivce)：切面必须要完成的工作。即，它是类中的一个方法。\n目标(Target)：被通知对象\n代理(Proxy)：向目标对象应用通知之后创建的对象\n切入点(PointCut) ：切面通知执行的”地点”的定义\n连接点(JointPoint)：与切入点匹配的执行点。\n\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;1.9.4&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n\n\n方式一：使用Spring API 接口【SpringAPI接口实现】\npackage my.demo01;\n\nimport org.springframework.aop.MethodBeforeAdvice;\n\nimport java.lang.reflect.Method;\n\npublic class log implements MethodBeforeAdvice &#123;\n    @Override\n    public void before(Method method, Object[] objects, Object o) throws Throwable &#123;\n        System.out.println(o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;被执行了&quot;);\n    &#125;\n&#125;\n\n\n\n\n\npackage my.demo01;\n\nimport org.springframework.aop.AfterReturningAdvice;\n\nimport java.lang.reflect.Method;\n\npublic class AfterLog implements AfterReturningAdvice &#123;\n    @Override\n    public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable &#123;\n        System.out.println(&quot;执行了&quot; + method.getName() + &quot;方法，返回结果为&quot; + o);\n    &#125;\n&#125;\n\n\n\n\n&lt;!--    方式一：使用原生SPring API接口--&gt;\n&lt;!--    需要导入aop约束--&gt;\n&lt;aop:config&gt;\n&lt;!--    切入点，expression:表达式，execution(要执行的位置！* * * * * )   修饰词 返回值 类名 方法名 参数--&gt;\n    &lt;aop:pointcut id&#x3D;&quot;pointCut&quot; expression&#x3D;&quot;execution(* my.service.UserServiceImpl.*(..))&quot;&#x2F;&gt;\n\n&lt;!--        执行环绕增加--&gt;\n    &lt;aop:advisor advice-ref&#x3D;&quot;log&quot; pointcut-ref&#x3D;&quot;pointCut&quot;&#x2F;&gt;\n    &lt;aop:advisor advice-ref&#x3D;&quot;afterLog&quot; pointcut-ref&#x3D;&quot;pointCut&quot;&#x2F;&gt;\n&lt;&#x2F;aop:config&gt;\n\n\n\n方式二：自定义类来实现AOP【切面定义】\n&lt;!--    方式2：自定义类--&gt;\n    &lt;bean id&#x3D;&quot;diy&quot; class&#x3D;&quot;my.diy.DiyPointCut&quot;&#x2F;&gt;\n    &lt;aop:config&gt;\n        &lt;aop:aspect ref&#x3D;&quot;diy&quot;&gt;\n            &lt;aop:pointcut id&#x3D;&quot;point&quot; expression&#x3D;&quot;execution(* my.service.UserServiceImpl.*(..))&quot;&#x2F;&gt;\n            &lt;aop:before method&#x3D;&quot;before&quot; pointcut-ref&#x3D;&quot;point&quot;&#x2F;&gt;\n            &lt;aop:after method&#x3D;&quot;after&quot; pointcut-ref&#x3D;&quot;point&quot;&#x2F;&gt;\n        &lt;&#x2F;aop:aspect&gt;\n    &lt;&#x2F;aop:config&gt;\n\n方式三：使用注解实现\npackage my.diy;\n\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\n\n@Aspect&#x2F;&#x2F;标注这个类是一个切面\n\npublic class AnnotationPointCut &#123;\n\n    @Before(&quot;execution(* my.service.UserServiceImpl.*(..))&quot;)\n    public void before()&#123;\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;方法执行前&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    &#125;\n\n    @After(&quot;execution(* my.service.UserServiceImpl.*(..))&quot;)\n    public void after()&#123;\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;方法执行后&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    &#125;\n&#125;\n\n\n\n\n11、整合Mybatis\n导入相关jar包\n\n\njunit\nmysql\nspring-webmvc\nspring-jdbc\naop织入\nmybatis-spring【new】\n\n11.1Mybatis-Spring\n编写数据源配置\n&lt;!--    DataSource：使用Spring的数据源替换Mybatis的位置 c3p0 dbcp druid\n        这里使用Spring 提供的JDBC org.springframework.jdbc.datasource.DriverManagerDataSource\n--&gt;\n    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;\n        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useSSL&#x3D;true&amp;useUncode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n\n\n\nsqlSessionFactory\n&lt;!--    sqlSessionFactory--&gt;\n    &lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;\n        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;\n        &lt;!--        绑定Mybatis 配置文件--&gt;\n        &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;mapperLocations&quot; value&#x3D;&quot;classpath:my&#x2F;mapper&#x2F;*.xml&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n\n\nsqlSessionTemplate\n&lt;!--    SqlSessionTemplate 就是SqlSession--&gt;\n    &lt;bean id&#x3D;&quot;sqlSession&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;\n        &lt;constructor-arg index&#x3D;&quot;0&quot; ref&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n\n\n给接口加实现类\npublic class UserMapperImpl implements UserMapper &#123;\n\n    private SqlSessionTemplate sqlSession;\n\n    public void setSqlSession(SqlSessionTemplate sqlSession) &#123;\n        this.sqlSession &#x3D; sqlSession;\n    &#125;\n\n    public List&lt;User&gt; selectUser() &#123;\n        UserMapper mapper &#x3D; sqlSession.getMapper(UserMapper.class);\n        return mapper.selectUser();\n    &#125;\n&#125;\n\n注册bean\n\n测试\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n        UserMapper userMapper &#x3D; context.getBean(&quot;userMapper&quot;, UserMapper.class);\n        List&lt;User&gt; userList &#x3D; userMapper.selectUser();\n        for (User user : userList) &#123;\n            System.out.println(user);\n        &#125;\n    &#125;\n&#125;\n\n方式二：\n编写数据源配置\n&lt;!--    DataSource：使用Spring的数据源替换Mybatis的位置 c3p0 dbcp druid\n        这里使用Spring 提供的JDBC org.springframework.jdbc.datasource.DriverManagerDataSource\n--&gt;\n    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;\n        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useSSL&#x3D;true&amp;useUncode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n\n\n\nsqlSessionFactory\n&lt;!--    sqlSessionFactory--&gt;\n    &lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;\n        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;\n        &lt;!--        绑定Mybatis 配置文件--&gt;\n        &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;mapperLocations&quot; value&#x3D;&quot;classpath:my&#x2F;mapper&#x2F;*.xml&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n\n\nsqlSessionTemplate\n&lt;!--    SqlSessionTemplate 就是SqlSession--&gt;\n    &lt;bean id&#x3D;&quot;sqlSession&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;\n        &lt;constructor-arg index&#x3D;&quot;0&quot; ref&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\nsqlSessionDaoSupport\npackage my.mapper;\n\nimport my.pojo.User;\nimport org.mybatis.spring.support.SqlSessionDaoSupport;\n\nimport java.util.List;\n\npublic class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper &#123;\n    public List&lt;User&gt; selectUser() &#123;\n        return getSqlSession().getMapper(UserMapper.class).selectUser();\n    &#125;\n&#125;\n\n\n注册bean\n&lt;bean id&#x3D;&quot;userMapper2&quot; class&#x3D;&quot;my.mapper.UserMapperImpl2&quot;&gt;\n    &lt;property name&#x3D;&quot;sqlSessionFactory&quot; ref&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n\n\n测试\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n        UserMapper userMapper &#x3D; context.getBean(&quot;userMapper2&quot;, UserMapper.class);\n        List&lt;User&gt; userList &#x3D; userMapper.selectUser();\n        for (User user : userList) &#123;\n            System.out.println(user);\n        &#125;\n    &#125;\n&#125;\n\n\n12、声明式事务1、回顾事务\n把一组业务当成一个业务来做；要么都成功，要么都失败\n事务在项目开发中，十分的重要，涉及到数据的一致性问题，不能马虎！\n确保完整性和一致性！\n\n&#x3D;&#x3D;事务ACID原则：&#x3D;&#x3D;\n\n原子性\n一致性\n隔离性\n多个业务操作同一个资源，防止数据损坏。\n\n\n持久性\n一旦提交，无论系统发生什么问题，结果都不会被影响，被持久化的写到存储器中。\n\n\n\n2、Spring中的事务管理\n\n声明式事务：AOP\n编程式事务：需要在代码中，进行事务的管理。\n\n&lt;!--    配置声明式事务--&gt;\n    &lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n       &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;!--  配置事务通知  --&gt;\n    &lt;tx:advice id&#x3D;&quot;transaction&quot; transaction-manager&#x3D;&quot;transactionManager&quot;&gt;\n        &lt;tx:attributes&gt;\n            &lt;tx:method name&#x3D;&quot;add&quot; propagation&#x3D;&quot;REQUIRED&quot;&#x2F;&gt;\n            &lt;tx:method name&#x3D;&quot;delete&quot; propagation&#x3D;&quot;REQUIRED&quot;&#x2F;&gt;\n            &lt;tx:method name&#x3D;&quot;update&quot; propagation&#x3D;&quot;REQUIRED&quot;&#x2F;&gt;\n            &lt;tx:method name&#x3D;&quot;query&quot; read-only&#x3D;&quot;true&quot;&#x2F;&gt;\n            &lt;tx:method name&#x3D;&quot;*&quot; propagation&#x3D;&quot;REQUIRED&quot;&#x2F;&gt;\n        &lt;&#x2F;tx:attributes&gt;\n    &lt;&#x2F;tx:advice&gt;\n\n&lt;!--    结合AOP 实现事务织入--&gt;\n    &lt;aop:config&gt;\n        &lt;aop:pointcut id&#x3D;&quot;transactionPointCut&quot; expression&#x3D;&quot;execution(* my.mapper.*.*(..))&quot;&#x2F;&gt;\n        &lt;aop:advisor advice-ref&#x3D;&quot;transaction&quot; pointcut-ref&#x3D;&quot;transactionPointCut&quot;&#x2F;&gt;\n    &lt;&#x2F;aop:config&gt;\n\n\n\n\n&#x3D;&#x3D;为什么需要事务&#x3D;&#x3D;\n\n如果不配置事务，可能存在数据提交不一致的情况\n如果不在Spring中配置声明式事务，就需要在代码中手动配置事务\n事务在醒目开发中十分重要，涉及到数据的一致性和完整性问题，不容马虎！\n\n","slug":"Spring","date":"2022-02-10T17:38:23.861Z","categories_index":"","tags_index":"","author_index":"Xoc001"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Socket&#x2F;TCP数据发送与接收的规则\n数据的完整性发送方\npublic void sendMsg(String msg) throws Exception&#123;\n    byte[] msgBytes &#x3D; msg.getBytes(charset);\n\n    &#x2F;&#x2F;发送内容长度\n    ByteBuffer buffer &#x3D; ByteBuffer.allocate(4);\n    buffer.putInt(msgBytes.length);\n    outputStream.write(buffer.array(),0,4);\n\n    &#x2F;&#x2F;发送内容\n    outputStream.write(msgBytes);\n&#125;\n\n\n\n接收方\n&#x2F;&#x2F;接收相关信息\npublic String receiveMsg() throws Exception &#123;\n\t\n\tByteBuffer buffer &#x3D; ByteBuffer.allocate(4);\n\treadFully(buffer.array(),0,4); \t\t&#x2F;&#x2F;长度信息\n\tint n &#x3D; buffer.getInt();\n\n\treadFully(inputBuffer,0, n);\t&#x2F;&#x2F;内容信息。\n\tString msg &#x3D; new String(inputBuffer,0,n,&quot;UTF-8&quot;);\n\treturn msg;\n\t\n&#125;\n&#x2F;&#x2F;完全接收N个字节：此方法会一直等待，直到收满N个字节才返回\npublic int readFully(byte[]array,int off,int size) throws Exception &#123;\n\tint count &#x3D; 0;\t\t&#x2F;&#x2F;已读字节数\n\twhile(count &lt; size) &#123;\n\t\tint remain  &#x3D; size -count;\n\t\tint numBytes &#x3D; inputStream.read(array,off+count,remain);\n\t\tif(numBytes &lt; 0) &#123;\n\t\t\treturn -1;\n\t\t&#125;\n\t\tcount +&#x3D; numBytes;\n\t&#125;\n\treturn size;\n&#125;\n\n\n\n阻塞与超时\n\n文本的存储文件里存储的是字节数据。因此，无论任何数据，都需要先编码为byte[],然后才能写入文件。\n对于String来说，也要编码：String-&gt;byte[]\nString text &#x3D; &quot;百度一下你就知道&quot;;\nbyte[]data &#x3D; text.getBytes(&quot;GBK&quot;);\n\n\n\n文件的传输Clientpackage my0903;\n\nimport af.net.AfNetConnection;\nimport af.net.AfNetPacket;\nimport org.json.JSONObject;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class FileUploadClient &#123;\n\n    AfNetConnection connection;\n    File file;\n    InputStream inputStream;\n\n    public FileUploadClient(AfNetConnection connection,File file)\n    &#123;\n        this.connection &#x3D; connection;\n        this.file &#x3D; file;\n    &#125;\n\n    public void work() throws Exception\n    &#123;\n        inputStream &#x3D; new FileInputStream(file);\n        &#x2F;&#x2F; 第一步\n        doStartTransfer();\n\n        while(true)\n        &#123;\n            byte [] buffer &#x3D; new byte[1024*8];\n            int n &#x3D; inputStream.read(buffer);\n            if(n&lt;0) break;\n\n            System.out.println(&quot;&gt;&gt; FILE_DATA  &quot; + n);\n            connection.send(MsgDefine.FILE_DATA,buffer,n);\n        &#125;\n\n        &#x2F;&#x2F;第三步\n        doEndTransfer();\n        System.out.println(&quot;上传完毕 &quot;+ file);\n    &#125;\n\n    public void close()\n    &#123;\n        try &#123;\n            inputStream.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F;发送文件信息\n    private void doStartTransfer() throws Exception &#123;\n        JSONObject jreq &#x3D; new JSONObject();\n        jreq.put(&quot;fileName&quot;,file.getName());\n        jreq.put(&quot;fileLength&quot;,file.length());\n\n        connection.send(MsgDefine.FILE_UPLOAD,jreq.toString(2));\n\n        AfNetPacket packet &#x3D; connection.recv();\n        getReplyData(packet);\n    &#125;\n\n    &#x2F;&#x2F;文件结束\n    private void doEndTransfer() throws Exception\n    &#123;\n        System.out.println(&quot; &gt;&gt; FILE END&quot;);\n        &#x2F;&#x2F;\n        connection.send(MsgDefine.FILE_END);\n        &#x2F;&#x2F;接收应答\n        AfNetPacket packet &#x3D; connection.recv();\n        getReplyData(packet);\n    &#125;\n\n\n\n    private Object getReplyData(AfNetPacket packet) throws Exception\n    &#123;\n        JSONObject jresp &#x3D; new JSONObject(packet.toString(&quot;UTF-8&quot;));\n        int status &#x3D; jresp.getInt(&quot;status&quot;);\n        if(status!&#x3D;0)\n        &#123;\n            String reason &#x3D; jresp.optString(&quot;reason&quot;,&quot;未知错误&quot;);\n            throw new Exception(reason);\n        &#125;else&#123;\n            Object data &#x3D; jresp.opt(&quot;data&quot;);\n            return data;\n        &#125;\n    &#125;\n&#125;\n\n\n\n\nServerpackage my0903;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport af.net.AfNetConnection;\nimport af.net.AfNetPacket;\n\npublic class FileUploadHandler\n&#123;\n\tAfNetConnection connection;\n\tAfNetPacket packet;\n\t\n\tFile tmpDir;\t\t&#x2F;&#x2F;临时目录\n\tFile tmpFile;\n\tOutputStream outputStream;\n\t\n\tpublic FileUploadHandler(AfNetConnection conn,AfNetPacket packet)\n\t&#123;\n\t\tthis.connection  &#x3D; conn;\n\t\tthis.packet &#x3D; packet;\n\t\t\n\t\ttmpDir &#x3D; new File(&quot;D:&#x2F;test&#x2F;&quot;);\n\t\ttmpDir.mkdirs();\n\t&#125;\n\t\n\tpublic void work() throws Exception\n\t&#123;\n\t\tJSONObject jreq &#x3D; new JSONObject(packet.toString(&quot;UTF-8&quot;));\n\t\tString fileName &#x3D; jreq.getString(&quot;fileName&quot;);\n\t\t\n\t\ttmpFile &#x3D; new File(tmpDir,fileName);\n\t\toutputStream &#x3D; new FileOutputStream(tmpFile);\n\n\t\t&#x2F;&#x2F;接收传送\n\t\tsendReply(0, &quot;OK&quot;);\n\t\tSystem.out.println(&quot;保存临时文件 &quot; + tmpFile);\n\t\t\n\t\twhile(true)\n\t\t&#123;\n\t\t\tAfNetPacket packet &#x3D; connection.recv();\n\t\t\tif(packet.action &#x3D;&#x3D; MsgDefine.FILE_DATA)\n\t\t\t&#123;\n\t\t\t\tSystem.out.println(&quot;FILE_DATA&quot; + packet.length);\n\t\t\t\toutputStream.write(packet.content, 0, packet.length);\n\t\t\t&#125;else if(packet.action &#x3D;&#x3D; MsgDefine.FILE_END) &#123;\n\t\t\t\tSystem.out.println(&quot;FILE_END!&quot;);\n\t\t\t\t&#x2F;&#x2F;关闭文件\n\t\t\t\toutputStream.close();\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\t\n\t\t&#x2F;&#x2F;第三阶段\n\t\tsendReply(0, &quot;OK&quot;);\n\t&#125;\n\t\n\tpublic void close() \n\t&#123;\n\t\ttry\n\t\t&#123;\n\t\t\toutputStream.close();\n\t\t&#125; catch (IOException e)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n\t\n\t\n\tprivate void sendReply(int status,String reason) throws Exception\n\t&#123;\n\t\tJSONObject jresp &#x3D; new JSONObject();\n\t\tjresp.put(&quot;status&quot;, status);\n\t\tjresp.put(&quot;reason&quot;, reason);\n\t\t\n\t\tconnection.send(MsgDefine.FILE_UPLOAD, jresp.toString(2));\n\t&#125;\n&#125;\n\n\n\n\n\n\n网络抓包\n并发访问与多线程线程与句柄\n查看进程PID\nRuntimeMXBean bean &#x3D; ManagementFactory.getRuntimeMXBean();\nString name &#x3D; bean.getName();\nSystem.out.println(name);\n\n","slug":"SocketTCP","date":"2022-02-10T17:38:23.855Z","categories_index":"","tags_index":"","author_index":"Xoc001"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"SMBMS1、项目搭建1.搭建一个Maven web 项目\n2.配置Tomcat\n3.测试项目\n4.导入项目中需要的jar包\n5.编写实体类\n​        ORM映射：表-类映射\n6.编写基础公共类\n​        1.数据库配置文件\ndriver&#x3D;com.mysql.jdbc.Driver\nurl&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8\nusername&#x3D;root\npassword&#x3D;\n\n​        2.数据库公共操作类\npackage my.dao;\n\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.sql.*;\nimport java.util.Properties;\n\npublic class BaseDao &#123;\n    private static String driver;\n    private static String url;\n    private static String username;\n    private static String password;\n\n    static &#123;\n        Properties properties &#x3D; new Properties();\n        InputStream input &#x3D; BaseDao.class.getResourceAsStream(&quot;do.properties&quot;);\n\n        try &#123;\n            properties.load(input);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        driver &#x3D; properties.getProperty(&quot;driver&quot;);\n        url &#x3D; properties.getProperty(&quot;url&quot;);\n        username &#x3D; properties.getProperty(&quot;username&quot;);\n        password &#x3D; properties.getProperty(&quot;password&quot;);\n\n    &#125;\n\n    &#x2F;&#x2F;获取数据库的连接\n    public static Connection getConnection() throws ClassNotFoundException &#123;\n        Connection connection &#x3D; null;\n        try &#123;\n            Class.forName(driver);\n            connection &#x3D; DriverManager.getConnection(url, username, password);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n        return connection;\n    &#125;\n\n    &#x2F;&#x2F;编写查询公共类\n    public static ResultSet executeQuery(PreparedStatement preparedStatement, Connection connection, String sql, Object[] params, ResultSet resultSet) throws SQLException &#123;\n        preparedStatement &#x3D; connection.prepareStatement(sql);\n        for (int i &#x3D; 0; i &lt; params.length; i++) &#123;\n            &#x2F;&#x2F;占位符从1开始，数组从0开始\n            preparedStatement.setObject(i + 1, params[i]);\n        &#125;\n        resultSet &#x3D; preparedStatement.executeQuery();\n        return resultSet;\n    &#125;\n\n    &#x2F;&#x2F;编写增删改公共方法\n    public static int update(PreparedStatement preparedStatement, Connection connection, String sql, Object[] params) throws SQLException &#123;\n        preparedStatement &#x3D; connection.prepareStatement(sql);\n        for (int i &#x3D; 0; i &lt; params.length; i++) &#123;\n            preparedStatement.setObject(i + 1, params[i]);\n        &#125;\n        int updateRows &#x3D; preparedStatement.executeUpdate();\n        return updateRows;\n    &#125;\n\n    &#x2F;&#x2F;释放资源操作\n    public static boolean closeResources(Connection connection, PreparedStatement preparedStatement, ResultSet resultSet) &#123;\n        boolean flag &#x3D; true;\n        if (resultSet !&#x3D; null) &#123;\n            try &#123;\n                resultSet.close();\n                &#x2F;&#x2F;GC回收\n                resultSet &#x3D; null;\n            &#125; catch (SQLException e) &#123;\n                e.printStackTrace();\n                flag &#x3D; false;\n            &#125;\n        &#125;\n\n        if (preparedStatement !&#x3D; null) &#123;\n            try &#123;\n                preparedStatement.close();\n                &#x2F;&#x2F;GC回收\n                preparedStatement &#x3D; null;\n            &#125; catch (SQLException e) &#123;\n                e.printStackTrace();\n                flag &#x3D; false;\n            &#125;\n        &#125;\n\n        if (connection !&#x3D; null) &#123;\n            try &#123;\n                connection.close();\n                &#x2F;&#x2F;GC回收\n                connection &#x3D; null;\n            &#125; catch (SQLException e) &#123;\n                e.printStackTrace();\n                flag &#x3D; false;\n            &#125;\n        &#125;\n\n        return flag;\n    &#125;\n&#125;\n\n\n​        3.编写字符编码过滤器\n\n\n\n2、登录界面实现\n1.编写前端界面\n2.设置首页\n&lt;!--    设置欢迎界面--&gt;\n&lt;welcome-file-list&gt;\n&lt;welcome-file&gt;login.jsp&lt;&#x2F;welcome-file&gt;\n&lt;&#x2F;welcome-file-list&gt;\n\n3.编写Servlet\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        String userCode &#x3D; req.getParameter(&quot;userCode&quot;);\n        String password &#x3D; req.getParameter(&quot;userPassword&quot;);\n\n        UserServiceImpl userService &#x3D; new UserServiceImpl();\n        User user &#x3D; userService.login(userCode, password);\n        if (user !&#x3D; null) &#123;\n            if (user.getUserPassword().equals(password)) &#123;\n                HttpSession session &#x3D; req.getSession();\n                session.setAttribute(Constants.User_SESSION, user);\n                resp.sendRedirect(&quot;jsp&#x2F;frame.jsp&quot;);\n            &#125; else &#123;\n                req.setAttribute(&quot;error&quot;, &quot;密码不正确&quot;);\n                req.getRequestDispatcher(&quot;login.jsp&quot;).forward(req, resp);\n            &#125;\n\n        &#125; else &#123;\n            req.setAttribute(&quot;error&quot;, &quot;用户名或密码不正确&quot;);\n            req.getRequestDispatcher(&quot;login.jsp&quot;).forward(req, resp);\n        &#125;\n    &#125;\n\n\n\n\n4.注册Servlet\n&lt;servlet&gt;\n    &lt;servlet-name&gt;LoginServlet&lt;&#x2F;servlet-name&gt;\n    &lt;servlet-class&gt;my.servlet.user.LoginServlet&lt;&#x2F;servlet-class&gt;\n&lt;&#x2F;servlet&gt;\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;LoginServlet&lt;&#x2F;servlet-name&gt;\n    &lt;url-pattern&gt;&#x2F;login.do&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;servlet-mapping&gt;\n\n登录界面优化3、密码修改1、导入前端素材\n2、写项目，建议从底层向上写\n\n\n3、UserDao接口\n&#x2F;&#x2F;密码修改\n    public int updatePassword(Connection connection,int id,String password) throws SQLException;\n\n\n\n4、UserDaoImpl实现类\n&#x2F;&#x2F;用户密码修改\npublic int updatePassword(Connection connection, int id, String password) throws SQLException &#123;\n    PreparedStatement preparedStatement &#x3D; null;\n    int flag &#x3D; 0;\n    if (connection !&#x3D; null) &#123;\n        String sql &#x3D; &quot;update &#96;smbms_user&#96; set userPassword&#x3D;? where id&#x3D;?&quot;;\n        Object[] params &#x3D; &#123;password, id&#125;;\n        flag &#x3D; BaseDao.update(preparedStatement, connection, sql, params);\n        BaseDao.closeResources(null, preparedStatement, null);\n    &#125;\n    return flag;\n&#125;\n\n\n\n5、Service接口\n&#x2F;&#x2F;修改密码\n   public boolean updatePassword(int id,String password);\n\n\n\n6、ServiceImpl实现类\n&#x2F;&#x2F;修改密码\npublic boolean updatePassword(int id, String password) &#123;\n    Connection connection &#x3D; null;\n    boolean flag &#x3D; false;\n    try &#123;\n        connection &#x3D; BaseDao.getConnection();\n        if (userDao.updatePassword(connection, id, password) &gt; 0) &#123;\n            flag &#x3D; true;\n        &#125;\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        BaseDao.closeResources(connection, null, null);\n    &#125;\n\n    return flag;\n&#125;\n\n\n\n\n7、Servlet实现类\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n    String oldpassword &#x3D; req.getParameter(&quot;oldpassword&quot;);\n    String newpassword &#x3D; req.getParameter(&quot;newpassword&quot;);\n    String rnewpassword &#x3D; req.getParameter(&quot;rnewpassword&quot;);\n    User user &#x3D; (User) req.getSession().getAttribute(Constants.User_SESSION);\n\n    boolean flag &#x3D; false;\n    if (oldpassword.equals(user.userPassword)) &#123;\n        if (newpassword.equals(rnewpassword)) &#123;\n            UserService service &#x3D; new UserServiceImpl();\n            flag &#x3D; service.updatePassword(user.getId(), newpassword);\n            if(flag)&#123;\n                req.setAttribute(&quot;message&quot;,&quot;修改密码成功,请退出重新登陆&quot;);\n                req.getSession().removeAttribute(Constants.User_SESSION);\n            &#125;else &#123;\n                req.setAttribute(&quot;message&quot;,&quot;密码修改失败&quot;);\n            &#125;\n\n        &#125;else&#123;\n            req.setAttribute(&quot;message&quot;,&quot;两次输入的密码不一致&quot;);\n        &#125;\n    &#125;else&#123;\n        req.setAttribute(&quot;message&quot;,&quot;旧密码输入错误&quot;);\n    &#125;\n    req.getRequestDispatcher(&quot;pwdmodify.jsp&quot;).forward(req,resp);\n&#125;\n\n\n\n8、复用Servlet\nString method &#x3D; req.getParameter(&quot;method&quot;);\nif (method !&#x3D; null &amp;&amp; method.equals(&quot;savepwd&quot;)) &#123;\n    this.updatePwd(req, resp);\n&#125; else if (method !&#x3D; null &amp;&amp; method.equals(&quot;pwdmodify&quot;)) &#123;\n    this.pwdModify(req, resp);\n&#125;\n\n\n\n4、用户管理实现流程\n\n1.导入分页的工具类\n2.用户列表页面导入\n1、用户管理1、获取用户数量1.UserDao&#x2F;&#x2F;用户数量查询\n   public int getUserCount(Connection connection,String userName,int userRole) throws SQLException;\n\n\n\n2.UserDaoImpl&#x2F;&#x2F;用户数量查询\n   public int getUserCount(Connection connection, String userName, int userRole) throws SQLException &#123;\n       PreparedStatement preparedStatement &#x3D; null;\n       ResultSet rs &#x3D; null;\n       int count &#x3D; 0;\n       if (connection !&#x3D; null) &#123;\n           StringBuffer sql &#x3D; new StringBuffer();\n           sql.append(&quot;select count(1) as count from smbms_user u,smbms_role r where u.userRole &#x3D; r.id&quot;);\n           ArrayList&lt;Object&gt; list &#x3D; new ArrayList&lt;Object&gt;();\n\n           if (userName !&#x3D; null) &#123;\n               sql.append(&quot; and u.userName&#x3D;?&quot;);\n               list.add(&quot;%&quot; + userName + &quot;%&quot;);\n           &#125;\n           if (userRole &gt; 0) &#123;\n               sql.append(&quot; and u.userRole&#x3D;?&quot;);\n               list.add(userRole);\n           &#125;\n           Object[] params &#x3D; list.toArray();\n           rs &#x3D; BaseDao.executeQuery(preparedStatement, connection, sql.toString(), params, rs);\n           if (rs.next()) &#123;\n               count &#x3D; rs.getInt(&quot;count&quot;);\n           &#125;\n           BaseDao.closeResources(null, preparedStatement, rs);\n       &#125;\n       return count;\n   &#125;\n\n\n\n3.UserService&#x2F;&#x2F;查询用户数量\n public int getUserCount(String userName,int userRole);\n\n\n\n4.UserServiceImpl&#x2F;&#x2F;查询用户数量\npublic int getUserCount(String userName, int userRole) &#123;\n    Connection connection &#x3D; null;\n    int count &#x3D;0;\n    try &#123;\n        connection &#x3D; BaseDao.getConnection();\n        count &#x3D; userDao.getUserCount(connection,userName,userRole);\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;finally &#123;\n        BaseDao.closeResources(connection,null,null);\n    &#125;\n    return count;\n&#125;\n\n5、servlet操作2、获取用户列表1.UserDao&#x2F;&#x2F;查询用户列表\n   public List&lt;User&gt; getUserList(Connection connection,String userName,int userRole,int currentPageNo,int pageSize) throws SQLException;\n\n2.UserDaoImpl&#x2F;&#x2F;用户列表查询\n    public List&lt;User&gt; getUserList(Connection connection, String userName, int userRole, int currentPageNo, int pageSize) throws SQLException &#123;\n        PreparedStatement preparedStatement &#x3D; null;\n        ResultSet rs &#x3D; null;\n        List&lt;User&gt; userList &#x3D; new ArrayList&lt;User&gt;();\n        if (connection !&#x3D; null) &#123;\n            StringBuffer sql &#x3D; new StringBuffer();\n            sql.append(&quot;select u.*,r.roleName as userRoleName from smbms_user u,smbms_role r where u.userRole&#x3D;r.id&quot;);\n            List&lt;Object&gt; list &#x3D; new ArrayList&lt;Object&gt;();\n            if (!StringUtils.isNullOrEmpty(userName)) &#123;\n                sql.append(&quot; and u.userName&#x3D; ? &quot;);\n                list.add(&quot;%&quot; + userName + &quot;%&quot;);\n            &#125;\n            if (userRole &gt; 0) &#123;\n                sql.append(&quot; and u.userRole&#x3D;&quot;);\n                list.add(userRole);\n            &#125;\n\n            &#x2F;&#x2F;分页使用 LIMIT查询\n            &#x2F;&#x2F;0,5\n            &#x2F;&#x2F;5,5\n            &#x2F;&#x2F;10,5\n\n            sql.append(&quot; order by creationDate DESC limit ?,?&quot;);\n            currentPageNo &#x3D; (currentPageNo - 1) * pageSize;\n            list.add(currentPageNo);\n            list.add(pageSize);\n\n            Object[] params &#x3D; list.toArray();\n            rs &#x3D; BaseDao.executeQuery(preparedStatement, connection, sql.toString(), params, rs);\n            while (rs.next()) &#123;\n                User user &#x3D; new User();\n                user &#x3D; new User();\n                user.setId(rs.getInt(&quot;id&quot;));\n                user.setUserCode(rs.getString(&quot;userCode&quot;));\n                user.setUserName(rs.getString(&quot;userName&quot;));\n                user.setUserPassword(rs.getString(&quot;userPassword&quot;));\n                user.setGender(rs.getInt(&quot;gender&quot;));\n                user.setBirthday(rs.getDate(&quot;birthday&quot;));\n                user.setPhone(rs.getString(&quot;phone&quot;));\n                user.setAddress(rs.getString(&quot;address&quot;));\n                user.setUserRole(rs.getInt(&quot;userRole&quot;));\n                user.setCreatedBy(rs.getLong(&quot;createdBy&quot;));\n                user.setCreationDate(rs.getDate(&quot;creationDate&quot;));\n                user.setModifyBy(rs.getLong(&quot;modifyBy&quot;));\n                user.setModifyDate(rs.getDate(&quot;modifyDate&quot;));\n\n                userList.add(user);\n            &#125;\n            BaseDao.closeResources(null, preparedStatement, rs);\n        &#125;\n        return userList;\n    &#125;\n\n\n3.UserService&#x2F;&#x2F;查询用户列表\n  public List&lt;User&gt; getUserList(String userName,int userRole,int currentPageNo,int pageSize);\n\n4.UserServiceImpl&#x2F;&#x2F;查询用户列表\n   public List&lt;User&gt; getUserList(String userName, int userRole, int currentPageNo, int pageSize) &#123;\n       Connection connection &#x3D;null;\n       List&lt;User&gt;userList &#x3D; new ArrayList&lt;User&gt;();\n       try &#123;\n           connection &#x3D; BaseDao.getConnection();\n           userList &#x3D; userDao.getUserList(connection,userName,userRole,currentPageNo,pageSize);\n       &#125; catch (Exception e) &#123;\n           e.printStackTrace();\n       &#125;finally &#123;\n           BaseDao.closeResources(connection,null,null);\n       &#125;\n       return userList;\n   &#125;\n\n5.Servlet实现 &#x2F;&#x2F;查询用户列表\n    public void query(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        String queryUserName &#x3D; req.getParameter(&quot;queryname&quot;);\n        String temp &#x3D; req.getParameter(&quot;queryUserRole&quot;);\n        String pageIndex &#x3D; req.getParameter(&quot;pageIndex&quot;);\n        int queryUserRole &#x3D; 0;\n\n        &#x2F;&#x2F;获取用户列表\n        UserServiceImpl userService &#x3D; new UserServiceImpl();\n        List&lt;User&gt; userList &#x3D; null;\n\n        int pageSize &#x3D; 5;\n        int currentPageNo &#x3D; 1;\n        if (queryUserName &#x3D;&#x3D; null) &#123;\n            queryUserName &#x3D; &quot;&quot;;\n        &#125;\n        if (temp !&#x3D; null &amp;&amp; !temp.equals(&quot;&quot;)) &#123;\n            queryUserRole &#x3D; Integer.parseInt(temp);\n        &#125;\n        if (pageIndex !&#x3D; null) &#123;\n            currentPageNo &#x3D; Integer.parseInt(pageIndex);\n        &#125;\n        &#x2F;&#x2F;获取用户总数 ()\n        int totalCount &#x3D; userService.getUserCount(queryUserName, queryUserRole);\n        &#x2F;&#x2F;总页数支持\n        PageSupport pageSupport &#x3D; new PageSupport();\n        pageSupport.setCurrentPageNo(currentPageNo);        &#x2F;&#x2F;设置当前页\n        pageSupport.setPageSize(pageSize);                  &#x2F;&#x2F;设置分页数量限制\n        pageSupport.setTotalCount(totalCount);              &#x2F;&#x2F;设置总数\n&#x2F;&#x2F;        pageSupport.setTotalPageCountByRs();        &#x2F;&#x2F;设置totalPageCount数量\n\n        int totalPageCount &#x3D; pageSupport.getTotalPageCount();       &#x2F;&#x2F;得到总分页数量。\n\n        &#x2F;&#x2F;控制首尾页显示\n        if (currentPageNo &lt; 1) &#123;        &#x2F;&#x2F;当前页小于1\n            currentPageNo &#x3D; 1;\n        &#125; else if (currentPageNo &gt; totalPageCount) &#123;         &#x2F;&#x2F;当前页大于总页数\n            currentPageNo &#x3D; totalPageCount;\n        &#125;\n\n\n        userList &#x3D; userService.getUserList(queryUserName, queryUserRole, currentPageNo, pageSize);\n        req.setAttribute(&quot;userList&quot;, userList);\n        List&lt;Role&gt; roleList &#x3D; null;\n        RoleService roleService &#x3D; new RoleServiceImpl();\n        roleList &#x3D; roleService.getRoleList();\n\n\n        req.setAttribute(&quot;roleList&quot;, roleList);\n        req.setAttribute(&quot;queryUserName&quot;, queryUserName);\n        req.setAttribute(&quot;queryUserRole&quot;, queryUserRole);\n        req.setAttribute(&quot;totalPageCount&quot;, totalPageCount);\n        req.setAttribute(&quot;totalCount&quot;, totalCount);\n        req.setAttribute(&quot;currentPageNo&quot;, currentPageNo);\n\n\n        req.getRequestDispatcher(&quot;userlist.jsp&quot;).forward(req, resp);\n\n\n\n\n\n\n\n3、获取角色列表1、RoleDao&#x2F;&#x2F;获取角色列表\npublic List&lt;Role&gt; getRoleList(Connection connection) throws ClassNotFoundException, SQLException;\n\n2、RoleDaoImpl&#x2F;&#x2F;获取角色列表\n    public List&lt;Role&gt; getRoleList(Connection connection) throws ClassNotFoundException, SQLException &#123;\n        PreparedStatement preparedStatement &#x3D; null;\n        ResultSet rs &#x3D; null;\n        List&lt;Role&gt; roleList &#x3D; new ArrayList&lt;Role&gt;();\n\n        connection &#x3D; BaseDao.getConnection();\n        String sql &#x3D; &quot;select * from smbms_role&quot;;\n        Object[] params &#x3D; &#123;&#125;;\n        rs &#x3D; BaseDao.executeQuery(preparedStatement, connection, sql, params, rs);\n        while (rs.next()) &#123;\n            Role role &#x3D; new Role();\n            role.setId(rs.getInt(&quot;id&quot;));\n            role.setRoleCode(rs.getString(&quot;roleCode&quot;));\n            role.setRoleName(rs.getString(&quot;roleName&quot;));\n            roleList.add(role);\n        &#125;\n        BaseDao.closeResources(null, preparedStatement, rs);\n        return null;\n    &#125;\n&#125;\n\n3、RoleService&#x2F;&#x2F;获取角色列表\n   public List&lt;Role&gt; getRoleList();\n\n4、RoleServiceImplpublic List&lt;Role&gt; getRoleList() &#123;\n    Connection connection &#x3D; null;\n    List&lt;Role&gt; roleList &#x3D; null;\n    try &#123;\n        connection &#x3D; BaseDao.getConnection();\n        roleList &#x3D;roleDao.getRoleList(connection);\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;finally &#123;\n        BaseDao.closeResources(connection,null,null);\n    &#125;\n    return roleList;\n&#125;\n\n\n\n4、添加用户1、UserDao&#x2F;&#x2F;添加用户\n  public int addUser(Connection connection,User user) throws SQLException;\n\n\n\n2、UserDaoImpl&#x2F;&#x2F;添加用户\npublic int addUser(Connection connection, User user) throws SQLException &#123;\n    PreparedStatement preparedStatement &#x3D; null;\n    int flag &#x3D; 0;\n    if (connection !&#x3D; null) &#123;\n        String sql &#x3D; &quot;insert into &#96;smbms_user&#96; (userCode, userName, userPassword, gender, birthday, phone, address, userRole, createdBy, creationDate) &quot; +\n            &quot;VALUES (?,?,?,?,?,?,?,?,?,?)&quot;;\n        Object[] params &#x3D; &#123;user.getUserCode(), user.getUserName(), user.getUserPassword(), user.getGender(), user.getBirthday(),\n                           user.getPhone(), user.getAddress(), user.getUserRole(), user.getCreatedBy(), user.getCreationDate()&#125;;\n        flag &#x3D; BaseDao.update(preparedStatement,connection,sql,params);\n        BaseDao.closeResources(null,preparedStatement,null);\n    &#125;\n    return flag;\n&#125;\n\n\n\n3、UserService&#x2F;&#x2F;添加用户\n  public boolean addUser(User user);\n\n\n\n4、UserServiceImpl&#x2F;&#x2F;添加用户\n    public boolean addUser(User user) &#123;\n        Connection connection &#x3D; null;\n        boolean flag &#x3D; false;\n\n        try &#123;\n            connection &#x3D; BaseDao.getConnection();\n            connection.setAutoCommit(false);    &#x2F;&#x2F;开启事务管理\n            int updateRows &#x3D; userDao.addUser(connection, user);\n            if (updateRows &gt; 0) &#123;\n                flag &#x3D; true;\n                connection.commit();\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            try &#123;\n                connection.rollback();\n            &#125; catch (SQLException ex) &#123;\n                ex.printStackTrace();\n            &#125;\n        &#125; finally &#123;\n            BaseDao.closeResources(connection, null, null);\n        &#125;\n\n        return flag;\n    &#125;\n\n\n\n5、Servlet&#x2F;&#x2F;添加用户\n    public void add(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException &#123;\n        String userCode &#x3D; req.getParameter(&quot;userCode&quot;);\n        String userName &#x3D; req.getParameter(&quot;userName&quot;);\n        String userPassword &#x3D; req.getParameter(&quot;userPassword&quot;);\n        String gender &#x3D; req.getParameter(&quot;gender&quot;);\n        String birthday &#x3D; req.getParameter(&quot;birthday&quot;);\n        String phone &#x3D; req.getParameter(&quot;phone&quot;);\n        String address &#x3D; req.getParameter(&quot;address&quot;);\n        String userRole &#x3D; req.getParameter(&quot;userRole&quot;);\n\n        User user &#x3D; new User();\n        user.setUserCode(userCode);\n        user.setUserName(userName);\n        user.setUserPassword(userPassword);\n        user.setGender(Integer.valueOf(gender));\n        try &#123;\n            user.setBirthday(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(birthday));\n        &#125; catch (ParseException e) &#123;\n            e.printStackTrace();\n        &#125;\n        user.setPhone(phone);\n        user.setAddress(address);\n        user.setUserRole(Integer.valueOf(userRole));\n        user.setCreationDate(new Date());\n        user.setCreatedBy(((User) req.getSession().getAttribute(Constants.User_SESSION)).getId());\n\n        UserService userService &#x3D; new UserServiceImpl();\n        boolean flag &#x3D; userService.addUser(user);\n        if (flag) &#123;\n            resp.sendRedirect(req.getContextPath() + &quot;&#x2F;jsp&#x2F;user.do?method&#x3D;query&quot;);\n        &#125; else &#123;\n            req.getRequestDispatcher(&quot;useradd.jsp&quot;).forward(req, resp);\n        &#125;\n    &#125;\n\n\n\n5、删除用户1、UserDao&#x2F;&#x2F;删除用户\n   public int delectUser(Connection connection, Integer userId) throws SQLException;\n\n2、UserDaoImpl&#x2F;&#x2F;删除用户\npublic int delectUser(Connection connection, Integer userId) throws SQLException &#123;\n    PreparedStatement preparedStatement &#x3D;null;\n    int flag &#x3D; 0;\n    if(connection!&#x3D;null)\n    &#123;\n        String sql &#x3D;&quot;delete from &#96;smbms_user&#96; where &#96;id&#96; &#x3D; ?&quot;;\n        Object []params &#x3D; &#123;userId&#125;;\n        flag &#x3D; BaseDao.update(preparedStatement,connection,sql,params);\n        BaseDao.closeResources(null,preparedStatement,null);\n    &#125;\n\n    return flag;\n&#125;\n\n\n3、UserService&#x2F;&#x2F;删除用户\n   public boolean deleteUser(Integer userId);\n\n4、UserServiceImpl&#x2F;&#x2F;删除用户\n  public boolean deleteUser(Integer userId) &#123;\n      boolean flag &#x3D; false;\n      Connection connection &#x3D; null;\n      try &#123;\n          connection &#x3D; BaseDao.getConnection();\n          if (userDao.delectUser(connection, userId) &gt; 0) &#123;\n              flag&#x3D;true;\n          &#125;\n      &#125; catch (Exception e) &#123;\n          e.printStackTrace();\n      &#125;finally &#123;\n          BaseDao.closeResources(connection,null,null);\n      &#125;\n      return flag;\n  &#125;\n\n\n\n\n5、Servlet&#x2F;&#x2F;删除用户\npublic void deleteUser(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;\n    String userid &#x3D; req.getParameter(&quot;uid&quot;);\n    JSONObject jreq &#x3D; new JSONObject();\n    int delId &#x3D; 0;\n    try &#123;\n        delId &#x3D; Integer.parseInt(userid);\n    &#125; catch (Exception e) &#123;\n        delId &#x3D; 0;\n    &#125;\n    if (delId &lt;&#x3D; 0) &#123;\n        jreq.put(&quot;delResult&quot;, &quot;notexist&quot;);\n    &#125; else &#123;\n        UserService userService &#x3D; new UserServiceImpl();\n        boolean flag &#x3D; userService.deleteUser(delId);\n        if (flag) &#123;\n            jreq.put(&quot;delResult&quot;, &quot;true&quot;);\n        &#125;else &#123;\n            jreq.put(&quot;delResult&quot;,&quot;false&quot;);\n        &#125;\n    &#125;\n\n    resp.setContentType(&quot;application&#x2F;json&quot;);\n    PrintWriter writer &#x3D; resp.getWriter();\n    writer.write(jreq.toString());\n    writer.flush();\n    writer.close();\n&#125;\n\n\n\n6、编辑用户1、UserDao&#x2F;&#x2F;根据ID查找用户\n   public User getUserById(Connection connection,Integer userId) throws SQLException;\n\n   &#x2F;&#x2F;编辑用户\n   public int modifyUser(Connection connection,User user) throws SQLException;\n\n\n\n2、UserDaoImpl&#x2F;&#x2F;根据ID查询用户\n    public User getUserById(Connection connection, Integer userId) throws SQLException &#123;\n        PreparedStatement preparedStatement &#x3D; null;\n        ResultSet rs &#x3D; null;\n        User user &#x3D;null;\n        if(connection!&#x3D;null)&#123;\n            String sql &#x3D;&quot;select u.*,r.roleName as userRoleName from smbms_user u,smbms_role r where id&#x3D;? and u.userRole &#x3D;r.id&quot;;\n            Object []params &#x3D; &#123;userId&#125;;\n            rs &#x3D; BaseDao.executeQuery(preparedStatement,connection,sql,params,rs);\n            if(rs.next())&#123;\n                user &#x3D; new User();\n                user.setId(rs.getInt(&quot;id&quot;));\n                user.setUserCode(rs.getString(&quot;userCode&quot;));\n                user.setUserName(rs.getString(&quot;userName&quot;));\n                user.setUserPassword(rs.getString(&quot;userPassword&quot;));\n                user.setGender(rs.getInt(&quot;gender&quot;));\n                user.setBirthday(rs.getDate(&quot;birthday&quot;));\n                user.setPhone(rs.getString(&quot;phone&quot;));\n                user.setAddress(rs.getString(&quot;address&quot;));\n                user.setUserRole(rs.getInt(&quot;userRole&quot;));\n                user.setModifyBy(rs.getInt(&quot;modifyBy&quot;));\n                user.setModifyDate(rs.getDate(&quot;modifyDate&quot;));\n                user.setUserRoleName(rs.getString(&quot;userRoleName&quot;));\n            &#125;\n            BaseDao.closeResources(null,preparedStatement,rs);\n        &#125;\n        return user;\n    &#125;\n\n    &#x2F;&#x2F;修改用户\n    public int modifyUser(Connection connection, User user) throws SQLException &#123;\n        PreparedStatement preparedStatement &#x3D; null;\n        int flag &#x3D;0;\n        if(connection!&#x3D;null)\n        &#123;\n            String sql&#x3D;&quot;update smbms_user set userName&#x3D;?,gender&#x3D;?,birthday&#x3D;?,phone&#x3D;?,address&#x3D;?,userRole&#x3D;?,modifyBy&#x3D;?,modifyDate&#x3D;? where id&#x3D;?&quot;;\n            Object [] params &#x3D;&#123;user.getUserName(),user.getGender(),user.getBirthday(),user.getPhone(),user.getAddress(),user.getUserRole(),user.getModifyBy(),user.getModifyDate(),user.getId()&#125;;\n            flag &#x3D; BaseDao.update(preparedStatement,connection,sql,params);\n            BaseDao.closeResources(null,preparedStatement,null);\n        &#125;\n        return flag;\n    &#125;\n\n\n\n\n3、UserService&#x2F;&#x2F;根据ID查询用户\n  public User geyUserById(int id);\n\n  &#x2F;&#x2F;修改用户\n  public boolean modifyUser(User user);\n\n\n\n4、UserServiceImpl&#x2F;&#x2F;通过ID查找用户\n   public User geyUserById(int id) &#123;\n       Connection connection &#x3D;null;\n       User user &#x3D; null;\n       try &#123;\n           connection &#x3D;BaseDao.getConnection();\n           user &#x3D; userDao.getUserById(connection,id);\n       &#125; catch (Exception e) &#123;\n           e.printStackTrace();\n       &#125;finally &#123;\n           BaseDao.closeResources(connection,null,null);\n       &#125;\n       return user;\n   &#125;\n\n   &#x2F;&#x2F;修改用户\n   public boolean modifyUser(User user) &#123;\n       boolean flag &#x3D; false;\n       Connection connection &#x3D; null;\n       try &#123;\n           connection &#x3D; BaseDao.getConnection();\n           connection.setAutoCommit(false);\n           if (userDao.modifyUser(connection, user) &gt; 0) &#123;\n               flag &#x3D; true;\n               connection.commit();\n           &#125;\n       &#125; catch (Exception e) &#123;\n           e.printStackTrace();\n           try &#123;\n               connection.rollback();\n           &#125; catch (SQLException ex) &#123;\n               ex.printStackTrace();\n           &#125;\n       &#125; finally &#123;\n           BaseDao.closeResources(connection, null, null);\n       &#125;\n\n       return flag;\n   &#125;\n\n\n\n\n5、Servlet&#x2F;&#x2F;通过id查找用户\npublic void getUserById(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n    String uid &#x3D; req.getParameter(&quot;uid&quot;);\n    User user &#x3D;null;\n    if(!StringUtils.isNullOrEmpty(uid))\n    &#123;\n        UserService userService &#x3D; new UserServiceImpl();\n        user &#x3D; userService.geyUserById(Integer.valueOf(uid));\n        req.setAttribute(&quot;user&quot;,user);\n        req.getRequestDispatcher(&quot;usermodify.jsp&quot;).forward(req,resp);\n    &#125;\n&#125;\n\n\n&#x2F;&#x2F;修改用户\npublic void modifyUser(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException &#123;\n    String id &#x3D; req.getParameter(&quot;uid&quot;);\n    String userName &#x3D; req.getParameter(&quot;userName&quot;);\n    String gender &#x3D; req.getParameter(&quot;gender&quot;);\n    String birthday &#x3D; req.getParameter(&quot;birthday&quot;);\n    String phone &#x3D; req.getParameter(&quot;phone&quot;);\n    String address &#x3D; req.getParameter(&quot;address&quot;);\n    String userRole &#x3D; req.getParameter(&quot;userRole&quot;);\n    User user &#x3D; new User();\n    user.setId(Integer.valueOf(id));\n    user.setUserName(userName);\n    user.setGender(Integer.valueOf(gender));\n    try &#123;\n        user.setBirthday(new SimpleDateFormat(&quot;yyyy-MM-mm&quot;).parse(birthday));\n    &#125; catch (ParseException e) &#123;\n        e.printStackTrace();\n    &#125;\n    user.setPhone(phone);\n    user.setAddress(address);\n    user.setUserRole(Integer.valueOf(userRole));\n    user.setModifyBy(((User) req.getSession().getAttribute(Constants.User_SESSION)).getId());\n    user.setModifyDate(new Date());\n\n    UserService userService &#x3D; new UserServiceImpl();\n    if (userService.modifyUser(user))&#123;\n        resp.sendRedirect(req.getContextPath()+&quot;&#x2F;jsp&#x2F;user.do?method&#x3D;query&quot;);\n    &#125;else&#123;\n        req.getRequestDispatcher(&quot;usermodify.jsp&quot;).forward(req,resp);\n    &#125;\n\n&#125;\n\n\n\n7、查看用户1、Servlet&#x2F;&#x2F;查看用户\n   public void viewUser(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n       String uid &#x3D; req.getParameter(&quot;uid&quot;);\n       User user &#x3D; null;\n       if(!StringUtils.isNullOrEmpty(uid))&#123;\n           UserService userService &#x3D; new UserServiceImpl();\n           user &#x3D; userService.geyUserById(Integer.valueOf(uid));\n           req.setAttribute(&quot;user&quot;,user);\n           req.getRequestDispatcher(&quot;userview.jsp&quot;).forward(req,resp);\n       &#125;\n   &#125;\n\n\n\n2、订单管理1、订单列表查询1、BillDao&#x2F;&#x2F;订单列表\n   public List&lt;Bill&gt; getBillList(Connection connection,String ProductName,int ProviderId,int IsPayment,int currentPageNo,int pageSize) throws SQLException;\n\n\n2、BillDaoImpl&#x2F;&#x2F;获取订单列表\n   public List&lt;Bill&gt; getBillList(Connection connection, String ProductName, int ProviderId, int IsPayment, int currentPageNo, int pageSize) throws SQLException &#123;\n       PreparedStatement preparedStatement &#x3D; null;\n       ResultSet rs &#x3D; null;\n       List&lt;Bill&gt; billList &#x3D; new ArrayList&lt;Bill&gt;();\n       if (connection !&#x3D; null) &#123;\n           StringBuffer sql &#x3D; new StringBuffer();\n           sql.append(&quot;select b.*,p.proName as providerName from smbms_bill b,smbms_provider p where b.providerId &#x3D;p.id&quot;);\n           List&lt;Object&gt; list &#x3D; new ArrayList&lt;Object&gt;();\n           if (!StringUtils.isNullOrEmpty(ProductName)) &#123;\n               sql.append(&quot; and b.productName like ? &quot;);\n               list.add(&quot;%&quot; + ProductName + &quot;%&quot;);\n           &#125;\n           if (ProviderId &gt; 0) &#123;\n               sql.append(&quot; and b.providerId&#x3D;?&quot;);\n               list.add(ProviderId);\n           &#125;\n           if (IsPayment &gt; 0) &#123;\n               sql.append(&quot; and b.isPayment&#x3D;?&quot;);\n               list.add(IsPayment);\n           &#125;\n\n           sql.append(&quot; order by creationDate DESC limit ?,?&quot;);\n           currentPageNo &#x3D; (currentPageNo - 1) * pageSize;\n           list.add(currentPageNo);\n           list.add(pageSize);\n\n           Object[] params &#x3D; list.toArray();\n           rs &#x3D; BaseDao.executeQuery(preparedStatement, connection, sql.toString(), params, rs);\n           while (rs.next()) &#123;\n               Bill bill &#x3D; new Bill();\n               bill.setId(rs.getLong(&quot;id&quot;));\n               bill.setBillCode(rs.getString(&quot;billCode&quot;));\n               bill.setProductName(rs.getString(&quot;productName&quot;));\n               bill.setProductDesc(rs.getString(&quot;productDesc&quot;));\n               bill.setProductUnit(rs.getString(&quot;productUnit&quot;));\n               bill.setProductCount(rs.getString(&quot;productCount&quot;));\n               bill.setTotalPrice(rs.getString(&quot;totalPrice&quot;));\n               bill.setIsPayment(rs.getInt(&quot;isPayment&quot;));\n               bill.setCreatedBy(rs.getLong(&quot;createdBy&quot;));\n               bill.setCreationDate(rs.getDate(&quot;creationDate&quot;));\n               bill.setModifyBy(rs.getLong(&quot;modifyBy&quot;));\n               bill.setModifyDate((rs.getDate(&quot;modifyDate&quot;)));\n               bill.setProviderId(rs.getInt(&quot;providerId&quot;));\n               bill.setProviderName(rs.getString(&quot;providerName&quot;));\n\n               billList.add(bill);\n           &#125;\n           BaseDao.closeResources(null, preparedStatement, rs);\n       &#125;\n       return billList;\n   &#125;\n\n3、BillService&#x2F;&#x2F;查询订单列表\n public List&lt;Bill&gt; getBillList(String ProductName,int queryProviderId,int IsPayment,int currentPageNo,int pageSize);\n\n4、BillServiceImpl&#x2F;&#x2F;查询订单列表\n  public List&lt;Bill&gt; getBillList(String ProductName, int ProviderId, int IsPayment, int currentPageNo, int pageSize) &#123;\n      Connection connection &#x3D; null;\n      List&lt;Bill&gt; billList &#x3D; null;\n      try &#123;\n          connection &#x3D; BaseDao.getConnection();\n          billList &#x3D; billDao.getBillList(connection, ProductName, ProviderId, IsPayment, currentPageNo, pageSize);\n      &#125; catch (Exception e) &#123;\n          e.printStackTrace();\n      &#125; finally &#123;\n          BaseDao.closeResources(connection, null, null);\n      &#125;\n      return billList;\n  &#125;\n\n\n\n\n5、Servlet&#x2F;&#x2F;得到订单列表  并进行分页显示\n    public void getBillList(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        String queryProductName &#x3D; req.getParameter(&quot;queryProductName&quot;);\n        String queryProviderId &#x3D; req.getParameter(&quot;queryProviderId&quot;);\n        String queryIsPayment &#x3D; req.getParameter(&quot;queryIsPayment&quot;);\n        String pageIndex &#x3D; req.getParameter(&quot;pageIndex&quot;);\n        int providerId &#x3D; 0;\n        int isPayment &#x3D; 0;\n\n        &#x2F;&#x2F;获取账单列表\n        BillService billService &#x3D; new BillServiceImpl();\n        List&lt;Bill&gt; billList &#x3D; null;\n\n        int pageSize &#x3D; Constants.Page_Size;\n        int currentPageNo &#x3D; 1;\n        if (StringUtils.isNullOrEmpty(queryProductName)) &#123;\n            queryProductName &#x3D; &quot;&quot;;\n        &#125;\n        if (!StringUtils.isNullOrEmpty(queryProviderId)) &#123;\n            providerId &#x3D; Integer.parseInt(queryProviderId);\n        &#125;\n\n        if (!StringUtils.isNullOrEmpty(queryIsPayment)) &#123;\n            isPayment &#x3D; Integer.parseInt(queryIsPayment);\n        &#125;\n        if (pageIndex !&#x3D; null) &#123;\n            currentPageNo &#x3D; Integer.parseInt(pageIndex);\n        &#125;\n\n        &#x2F;&#x2F;获取用户总数 ()\n        int totalCount &#x3D; billService.getBillCount(queryProductName,providerId,isPayment);\n        &#x2F;&#x2F;总页数支持\n        PageSupport pageSupport &#x3D; new PageSupport();\n        pageSupport.setCurrentPageNo(currentPageNo);        &#x2F;&#x2F;设置当前页\n        pageSupport.setPageSize(pageSize);                  &#x2F;&#x2F;设置分页数量限制\n        pageSupport.setTotalCount(totalCount);              &#x2F;&#x2F;设置总数\n&#x2F;&#x2F;        pageSupport.setTotalPageCountByRs();        &#x2F;&#x2F;设置totalPageCount数量\n\n        int totalPageCount &#x3D; pageSupport.getTotalPageCount();       &#x2F;&#x2F;得到总分页数量。\n\n        &#x2F;&#x2F;控制首尾页显示\n        if (currentPageNo &lt; 1) &#123;        &#x2F;&#x2F;当前页小于1\n            currentPageNo &#x3D; 1;\n        &#125; else if (currentPageNo &gt; totalPageCount) &#123;         &#x2F;&#x2F;当前页大于总页数\n            currentPageNo &#x3D; totalPageCount;\n        &#125;\n\n\n        billList &#x3D; billService.getBillList(queryProductName, providerId, isPayment,currentPageNo,pageSize);\n        req.setAttribute(&quot;billList&quot;, billList);\n        List&lt;Provider&gt; providerList &#x3D; new ArrayList&lt;Provider&gt;();\n        ProviderService providerService &#x3D; new ProviderServiceImpl();\n        providerList &#x3D; providerService.getProviderList();\n        req.setAttribute(&quot;queryProviderId&quot;, queryProviderId);\n        req.setAttribute(&quot;providerList&quot;, providerList);\n        req.setAttribute(&quot;queryProductName&quot;, queryProductName);\n        req.setAttribute(&quot;queryIsPayment&quot;, queryIsPayment);\n        req.setAttribute(&quot;totalPageCount&quot;, totalPageCount);\n        req.setAttribute(&quot;totalCount&quot;, totalCount);\n        req.setAttribute(&quot;currentPageNo&quot;, currentPageNo);\n\n        req.getRequestDispatcher(&quot;billlist.jsp&quot;).forward(req, resp);\n    &#125;\n\n\n\n\n2、删除订单1、BillDao&#x2F;&#x2F;删除订单信息\n  public int deleteBill(Connection connection,int id) throws SQLException;\n\n2、BillDaoImpl&#x2F;&#x2F;删除订单信息\n   public int deleteBill(Connection connection, int id) throws SQLException &#123;\n       PreparedStatement preparedStatement &#x3D; null;\n       int flag&#x3D;0;\n       if(connection!&#x3D;null)&#123;\n           String sql &#x3D;&quot;delete from &#96;smbms_bill&#96; where id&#x3D; ?&quot;;\n           Object [] params&#x3D;&#123;id&#125;;\n           flag &#x3D; BaseDao.update(preparedStatement,connection,sql,params);\n           BaseDao.closeResources(null,preparedStatement,null);\n       &#125;\n       return flag;\n   &#125;\n\n3、BillService&#x2F;&#x2F;删除订单\n public boolean deleteBill(int id);\n\n4、BillServiceImpl&#x2F;&#x2F;删除订单信息\n    public boolean deleteBill(int id) &#123;\n        Connection connection &#x3D; null;\n        boolean flag &#x3D; false;\n        try &#123;\n            connection &#x3D; BaseDao.getConnection();\n            if (billDao.deleteBill(connection, id) &gt; 0) &#123;\n                flag &#x3D; true;\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            BaseDao.closeResources(connection, null, null);\n        &#125;\n        return flag;\n    &#125;\n\n5、Servlet&#x2F;&#x2F;删除订单\n    public void deleteBill(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;\n        String billid &#x3D; req.getParameter(&quot;billid&quot;);\n        JSONObject jreq &#x3D; new JSONObject();\n        int bid&#x3D;0;\n        try &#123;\n            bid &#x3D; Integer.parseInt(billid);\n        &#125;catch(Exception e)&#123;\n            e.printStackTrace();\n            bid&#x3D;0;\n        &#125;\n        if(bid&lt;&#x3D;0)&#123;\n            jreq.put(&quot;delResult&quot;,&quot;notexist&quot;);\n        &#125;else&#123;\n            BillService billService &#x3D; new BillServiceImpl();\n            boolean flag&#x3D;false;\n            flag &#x3D; billService.deleteBill(bid);\n            if(flag)&#123;\n                jreq.put(&quot;delResult&quot;,&quot;true&quot;);\n            &#125;else&#123;\n                jreq.put(&quot;delResult&quot;,&quot;false&quot;);\n            &#125;\n        &#125;\n        resp.setContentType(&quot;application&#x2F;json&quot;);\n        PrintWriter writer &#x3D; resp.getWriter();\n        writer.write(jreq.toString());\n        writer.flush();\n        writer.close();\n    &#125;\n\n","slug":"SMBMS","date":"2022-02-10T17:38:23.832Z","categories_index":"","tags_index":"","author_index":"Xoc001"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"MyBatis1、简介\n1.1、什么是 MyBatis？MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\nGithub：mybatis&#x2F;mybatis-3: MyBatis SQL mapper framework for Java (github.com)\n文档：mybatis – MyBatis 3 | 入门\n1.2、持久化数据持久化\n\n持久化就是将程序的数据在持久状态和瞬时状态转化的过程\n\n内存：断电即失\n\n数据库(JDBC)，IO持久化。\n\n\n1.3、持久层\n完成持久化工作的代码块\n层界限十分明显。\n\n1.4为什么需要Mybatis？\n帮助程序员将数据存入数据库中。\n方便\n传统JDBC代码太复杂。简化。框架。自动化\n\n2、第一个Mybatis程序2.1搭建环境搭建数据库\nCREATE DATABASE &#96;mybatis&#96;;\n\nUSE &#96;mybatis&#96;;\n\nCREATE TABLE &#96;user&#96;(\n&#96;id&#96; INT(20) NOT NULL PRIMARY KEY,\n&#96;name&#96; VARCHAR(30) DEFAULT NULL,\n&#96;password&#96; VARCHAR(30) DEFAULT NULL\n)ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8;\n\nINSERT INTO &#96;user&#96;(&#96;id&#96;,&#96;name&#96;,&#96;password&#96;) VALUES(1,&#39;a&#39;,&#39;123456&#39;),(2,&#39;b&#39;,&#39;123456&#39;),(3,&#39;c&#39;,&#39;12344&#39;)\n\n\n\n2.2创建模块mapper.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n  PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;\n  &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace&#x3D;&quot;org.mybatis.example.BlogMapper&quot;&gt;\n  &lt;select id&#x3D;&quot;selectBlog&quot; resultType&#x3D;&quot;Blog&quot;&gt;\n    select * from Blog where id &#x3D; #&#123;id&#125;\n  &lt;&#x2F;select&gt;\n&lt;&#x2F;mapper&gt;\n\n\n\n\n\npackage my.utils;\n\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class Mybatis &#123;\n    private static SqlSessionFactory sqlSessionFactory;\n\n    static &#123;\n        try &#123;\n            String resource &#x3D; &quot;mybatis-config.xml&quot;;\n            InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);\n            sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F;既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。\n    &#x2F;&#x2F; SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：\n    public static SqlSession getSqlSession()&#123;\n        return sqlSessionFactory.openSession();\n    &#125;\n&#125;\n\n\n\n\n2.3测试核心配置文件中注册Mappers\n\nJunit测试\n\n@Test\npublic void test()&#123;\n    &#x2F;&#x2F;获取Session 对象\n    SqlSession session &#x3D; Mybatis.getSqlSession();\n\n    &#x2F;&#x2F;\n    UserMapper mapper &#x3D; session.getMapper(UserMapper.class);\n    List&lt;User&gt; userList &#x3D; mapper.getUserList();\n\n    for (User user:userList) &#123;\n        System.out.println(user);\n    &#125;\n\n    session.close();\n&#125;\n\n\n\n\n\n\n\n3、CURD1、namespacenamespace中的包名要和Dao中的Mapper接口的包名一致！\n2、select1、编写接口&#x2F;&#x2F;查\nList&lt;User&gt; getUserList();\n&#x2F;&#x2F;查\nUser getUserById(int id);\n\n2、编写Mapper中对应的xml语句&lt;select id&#x3D;&quot;getUserList&quot; resultType&#x3D;&quot;my.pojo.User&quot;&gt;\n    select * from &#96;user&#96;\n&lt;&#x2F;select&gt;\n    \n&lt;select id&#x3D;&quot;getUserById&quot; resultType&#x3D;&quot;my.pojo.User&quot; parameterType&#x3D;&quot;int&quot;&gt;\n    select * from &#96;user&#96; where id&#x3D;#&#123;id&#125;\n&lt;&#x2F;select&gt;\n\n3、测试3、update&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;my.pojo.User&quot;&gt;\n   update &#96;user&#96; set name&#x3D;#&#123;name&#125;, password&#x3D;#&#123;password&#125; where id&#x3D;#&#123;id&#125;\n&lt;&#x2F;update&gt;\n\n\n\n\n4、delete&lt;delete id&#x3D;&quot;deleteUser&quot; parameterType&#x3D;&quot;int&quot;&gt;\n    delete from &#96;user&#96; where id&#x3D;#&#123;id&#125;\n&lt;&#x2F;delete&gt;\n\n\n\n5、insert&lt;insert id&#x3D;&quot;addUser&quot; parameterType&#x3D;&quot;my.pojo.User&quot;&gt;\ninsert into &#96;user&#96; (&#96;id&#96;,&#96;name&#96;,&#96;password&#96;) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)\n&lt;&#x2F;insert&gt;\n\n\n\n6、Map实体类，或者数据库中的表，字段或参数过多可以使用Map\n&lt;insert id&#x3D;&quot;addUser&quot; parameterType&#x3D;&quot;map&quot;&gt;\n\tinsert into &#96;user&#96;(&#96;id&#96;,&#96;name&#96;,&#96;password&#96;) values(#&#123;userId&#125;,#&#123;userName&#125;,#&#123;passWord&#125;)\n&lt;&#x2F;insert&gt;\n\nMap传递参数，直接在sql中取出key即可！ parameterType&#x3D;”map”\n对象传递参数，直接在sql中取出对象即可！parameterType&#x3D;”Object”\n只有一个基本类型参数，可以直接在sql中取到！\n多个参数用Map，或者注解！\n@Test\n public void addUser1()&#123;\n     SqlSession sqlSession &#x3D; Mybatis.getSqlSession();\n     UserMapper mapper &#x3D; sqlSession.getMapper(UserMapper.class);\n     Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;String, Object&gt;();\n     map.put(&quot;userId&quot;,6);\n     map.put(&quot;userName&quot;,&quot;aabab&quot;);\n     mapper.addUser1(map);\n     sqlSession.commit();\n     sqlSession.close();\n &#125;\n\n\n\n7、注意模糊查询\n1、Java代码执行的时候，传递通配符%%\nList&lt;User&gt;userList &#x3D; mapper.getUserList(&quot;%李%&quot;);\n\n2、在sql拼接中使用通配符\nselect * from user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot;\n\n\n\n4、配置解析1、核心配置文件\nmybatis-config.xml\nMybatis的配置文件包含了会深深影响Mybatis行为的设置和属性信息\n\nconfiguration（配置）\nproperties（属性）\nsettings（设置）\ntypeAliases（类型别名）\ntypeHandlers（类型处理器）\nobjectFactory（对象工厂）\nplugins（插件）\nenvironments（环境配置）\nenvironment（环境变量）\ntransactionManager（事务管理器）\ndataSource（数据源）\ndatabaseIdProvider（数据库厂商标识）\nmappers（映射器）\n\n\n\n&lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt;\n&lt;build&gt;\n    &lt;resources&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;\n            &lt;includes&gt;\n                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;\n                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;\n            &lt;&#x2F;includes&gt;\n            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;\n        &lt;&#x2F;resource&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;\n            &lt;includes&gt;\n                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;\n                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;\n            &lt;&#x2F;includes&gt;\n            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;\n        &lt;&#x2F;resource&gt;\n    &lt;&#x2F;resources&gt;\n&lt;&#x2F;build&gt;\n\n\n\n\n\n\n\n2、环境配置（environments）Mybatis可以配置成适应多种环境\n不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。    \n3、属性（properties）\n属性可以在外部配置，并可以进行动态替换。\n你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置\ndriver&#x3D;com.mysql.jdbc.Driver\nurl&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useSSL&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8\nusername&#x3D;root\npassword&#x3D;\n\n设置好的属性可以在整个配置文件中用来替换需要动态配置的属性值\n&lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n  &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;\n  &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;\n  &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;\n  &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;\n&lt;&#x2F;dataSource&gt;\n\n引入外部文件\n&lt;properties resource&#x3D;&quot;org&#x2F;mybatis&#x2F;example&#x2F;config.properties&quot;&gt;\n  &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;dev_user&quot;&#x2F;&gt;\n  &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;F2Fa3!33TYyg&quot;&#x2F;&gt;\n&lt;&#x2F;properties&gt;\n\n\n可以直接引入外部文件\n可以在其中添加一些属性，配置\n如果两个文件有同一个字段，优先使用外部文件配置。\n\n4、类型别名（typeAliases）\n类型别名可为 Java 类型设置一个缩写名字。\n它仅用于 XML 配置，意在降低冗余的全限定类名书写。\n\n类型别名可为 Java 类型设置一个缩写名字。 \n&lt;typeAliases&gt;\n       &lt;typeAlias type&#x3D;&quot;my.pojo.User&quot; alias&#x3D;&quot;User&quot;&#x2F;&gt;\n&lt;&#x2F;typeAliases&gt;\n\n**也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 **\n&lt;typeAliases&gt;\n    &lt;package name&#x3D;&quot;my.pojo&quot;&#x2F;&gt;\n&lt;&#x2F;typeAliases&gt;\n\n在实体类比较少时，使用缩写。\n在实体类比较多时，使用包名。\n缩写可以DIY别名，包名则需要注解起别名\nimport org.apache.ibatis.type.Alias;\n\n@Alias(&quot;user&quot;)\n\n\n\n5、设置这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。\n&lt;settings&gt;\n  &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;lazyLoadingEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;multipleResultSetsEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;useColumnLabel&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;useGeneratedKeys&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;autoMappingBehavior&quot; value&#x3D;&quot;PARTIAL&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;autoMappingUnknownColumnBehavior&quot; value&#x3D;&quot;WARNING&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;defaultExecutorType&quot; value&#x3D;&quot;SIMPLE&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;defaultStatementTimeout&quot; value&#x3D;&quot;25&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;defaultFetchSize&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;safeRowBoundsEnabled&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;localCacheScope&quot; value&#x3D;&quot;SESSION&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;jdbcTypeForNull&quot; value&#x3D;&quot;OTHER&quot;&#x2F;&gt;\n  &lt;setting name&#x3D;&quot;lazyLoadTriggerMethods&quot; value&#x3D;&quot;equals,clone,hashCode,toString&quot;&#x2F;&gt;\n&lt;&#x2F;settings&gt;\n\n6、映射器MapperRegistry:注册绑定我们的Mapper文件；\n方式一：\n&lt;mappers&gt;\n       &lt;mapper resource&#x3D;&quot;my&#x2F;dao&#x2F;UserMapper.xml&quot;&gt;&lt;&#x2F;mapper&gt;\n   &lt;&#x2F;mappers&gt;\n\n方式二：使用class文件绑定注册\n&lt;mappers&gt;\n    &lt;mapper class&#x3D;&quot;my.dao.UserMapper&quot;&#x2F;&gt;\n&lt;&#x2F;mappers&gt;\n\n注意点\n\n接口和他的Mapper配置文件必须同名\n接口和他的Mapper配置文件必须在同一个包下\n\n7、生命周期和作用域\n生命周期，和作用域，是至关重要的，因为错误的使用会导致非常严重的并发问题\nSqlSessionFactoryBuilder:\n\n一旦创建了SqlSessionFactoryBuilder，就不再需要它。\n局部变量\n\nSqlSessionFactory:\n\n想象为：数据库连接池\nSqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃或重新创建另一个实例。\n因此SqlSessionFactory的最佳作用域是应用作用域\n最简单的就是使用单例模式或者静态单例模式\n\nSqlSession\n\n连接到连接池的一个请求！\nSqlSession的实例不是线程安全的，因此是不能被共享的，多以他的最佳的作用域是请求或方法作用域。\n用完之后关闭，否则资源被占用！\n\n\n每一个Mapper，就代表一个业务。\n5、解决属性名和字段名不一致的问题\nresultMap 元素是 MyBatis 中最重要最强大的元素。\nResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。\n\n使用显式使用外部resultMap配置，解决列名不匹配\n&lt;resultMap id&#x3D;&quot;UserMap&quot; type&#x3D;&quot;User&quot;&gt;\n      &lt;result column&#x3D;&quot;password&quot; property&#x3D;&quot;pwd&quot;&gt;&lt;&#x2F;result&gt;\n  &lt;&#x2F;resultMap&gt;\n  &lt;select id&#x3D;&quot;getUserList&quot; resultMap&#x3D;&quot;UserMap&quot;&gt;\n  select * from &#96;user&#96;\n  &lt;&#x2F;select&gt;\n\n6、日志​    Mybatis 通过使用内置的日志工厂提供日志功能。内置日志工厂将会把日志工作委托给下面的实现之一：\n\nSLF4J\nLOG4J\nLOG4J2\nJDK_LOGGING \nCOMMONS_LOGGING\nSTDOUT_LOGGING \nNO_LOGGING\n\n&lt;settings&gt;\n       &lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;STDOUT_LOGGING&quot;&#x2F;&gt;\n   &lt;&#x2F;settings&gt;\n\n\n\nLOG4J1.导入log4j的包\n&lt;dependency&gt;\n         &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;\n         &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;\n         &lt;version&gt;1.2.17&lt;&#x2F;version&gt;\n     &lt;&#x2F;dependency&gt;\n\n2.添加log4.properties文件\n#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码\nlog4j.rootLogger&#x3D;DEBUG,console,file\n\n#控制台输出的相关设置\nlog4j.appender.console &#x3D; org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target &#x3D; System.out\nlog4j.appender.console.Threshold&#x3D;DEBUG\nlog4j.appender.console.layout &#x3D; org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern&#x3D;[%c]-%m%n\n\n#文件输出的相关设置\nlog4j.appender.file &#x3D; org.apache.log4j.RollingFileAppender\nlog4j.appender.file.File&#x3D;.&#x2F;log&#x2F;test.log\nlog4j.appender.file.MaxFileSize&#x3D;10mb\nlog4j.appender.file.Threshold&#x3D;DEBUG\nlog4j.appender.file.layout&#x3D;org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern&#x3D;[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n\n\n#日志输出级别\nlog4j.logger.org.mybatis&#x3D;DEBUG\nlog4j.logger.java.sql&#x3D;DEBUG\nlog4j.logger.java.sql.Statement&#x3D;DEBUG\nlog4j.logger.java.sql.ResultSet&#x3D;DEBUG\nlog4j.logger.java.sql.PreparedStatement&#x3D;DEBUG\n\n3.配置log4j为日志的实现\n&lt;settings&gt;\n    &lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;LOG4J&quot;&#x2F;&gt;\n&lt;&#x2F;settings&gt;\n\n\n\n7、分页为什么分页？\n减少数据的处理量\n\n7.1、使用LIMIT分页语法：select * from &#96;user&#96; limit startIndex,pageSize\nselect * from &#96;user&#96;limit 3  #[0,n-1]\n\n使用Mybatis实现分页，核心SQL1.接口&#x2F;&#x2F;查\nList&lt;User&gt; getUserList(Map&lt;String,Object&gt;map);\n\n2.Mapper.xml&lt;select id&#x3D;&quot;getUserList&quot; parameterType&#x3D;&quot;map&quot;  resultType&#x3D;&quot;user&quot;&gt;\n select * from &#96;user&#96; limit #&#123;startIndex&#125;,#&#123;pageSize&#125;\n &lt;&#x2F;select&gt;\n\n\n\n7.2、RowBounds分页不再使用SQL实现分页\n1.接口\nList&lt;User&gt;getUserByRowBounds();\n\n2.Mapper.xml\n&lt;select id&#x3D;&quot;getUserListByRowBounds&quot; resultType&#x3D;&quot;user&quot;&gt;\n    select * from &#96;user&#96;\n&lt;&#x2F;select&gt;\n\n\n\n3.测试\n@Test\npublic void getUserByRowBounds() &#123;\n    SqlSession sqlSession &#x3D; Mybatis.getSqlSession();\n\n    &#x2F;&#x2F;创建RowBounds分页\n    RowBounds rowBounds &#x3D; new RowBounds(1, 2);\n    &#x2F;&#x2F;通过Java代码层面实现分页\n    List&lt;User&gt; userList &#x3D; sqlSession.selectList(&quot;my.dao.UserMapper.getUserListByRowBounds&quot;, null, rowBounds);\n    for (User user : userList) &#123;\n        System.out.println(user);\n    &#125;\n    sqlSession.close();\n&#125;\n\n7.3、分页插件8、使用注解开发8.1、面向接口编程大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程- 根本原因 :  &#x3D;&#x3D;解耦&#x3D;&#x3D; , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好- 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了；- 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。\n关于接口的理解\n- 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。- 接口的本身反映了系统设计人员对系统的抽象理解。- 接口应有两类：  - 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)；  - 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；- 一个体有可能有多个抽象面。抽象体与抽象面是有区别的。\n三个面向区别\n- 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 .- 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 .- 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构\nMyBatis流程\n8.2、使用注解开发1.注解在接口上实现\n@Select(&quot;select * from &#96;user&#96;&quot;)\nList&lt;User&gt; getUserList();\n\n2.需要在核心配置文件中绑定接口！\n&lt;mappers&gt;\n    &lt;mapper class&#x3D;&quot;my.dao.UserMapper&quot;&#x2F;&gt;\n&lt;&#x2F;mappers&gt;\n\n3.测试\n@Test\npublic void test()\n&#123;\n    SqlSession sqlSession &#x3D; Mybatis.getSqlSession();\n    UserMapper mapper &#x3D; sqlSession.getMapper(UserMapper.class);\n    List&lt;User&gt; userList &#x3D; mapper.getUserList();\n    for (User user : userList) &#123;\n        System.out.println(user);\n    &#125;\n    sqlSession.close();\n&#125;\n\n本质：反射机制实现\n底层：动态代理！\n8.3、CURD@Select(&quot;select * from &#96;user&#96;&quot;)\n  List&lt;User&gt; getUserList();\n\n  @Select(&quot;select * from user where id&#x3D;#&#123;id&#125;&quot;)\n  User getUser(@Param(&quot;id&quot;) int id);\n\n  @Insert(&quot;insert into &#96;user&#96;(id,name,password) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&quot;)\n  int addUser(User user);\n\n  @Update(&quot;update user set name&#x3D;#&#123;name&#125;,password&#x3D;#&#123;pwd&#125; where id&#x3D;#&#123;id&#125;&quot;)\n  int updateUser(User user);\n\n  @Delete(&quot;delete from user where id&#x3D;#&#123;id&#125;&quot;)\n  int deleteUser(int id);\n\n\n\n关于@Param()注解\n基本类型的参数或者String 类型，需要加上\n引用类型不需要加。\n如果只有一个基本类型，可不加。\n我们在SQL中引用的就是@Param()中设定的属性名。\n\n#{}和${}的区别：#{}更安全，防止SQL注入，自动加上””(双引号)。9、多对一\n按照查询嵌套处理&lt;select id&#x3D;&quot;getStudentList&quot; resultMap&#x3D;&quot;StudentTeacher&quot;&gt;\n    select * from &#96;student&#96;\n&lt;&#x2F;select&gt;\n\n&lt;resultMap id&#x3D;&quot;StudentTeacher&quot; type&#x3D;&quot;Student&quot;&gt;\n    &lt;result property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;\n    &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot;&#x2F;&gt;\n    &lt;association property&#x3D;&quot;teacher&quot; column&#x3D;&quot;tid&quot; javaType&#x3D;&quot;Teacher&quot; select&#x3D;&quot;getTeacher&quot;&#x2F;&gt;\n&lt;&#x2F;resultMap&gt;\n\n&lt;select id&#x3D;&quot;getTeacher&quot; resultType&#x3D;&quot;Teacher&quot;&gt;\n    select * from &#96;teacher&#96; where id&#x3D;#&#123;id&#125;\n&lt;&#x2F;select&gt;\n\n按照结果查询处理&lt;!--按照结果查询处理--&gt;\n    &lt;select id&#x3D;&quot;getStudentList2&quot; resultMap&#x3D;&quot;getStudent2&quot;&gt;\n        select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid&#x3D;t.id;\n    &lt;&#x2F;select&gt;\n    &lt;resultMap id&#x3D;&quot;getStudent2&quot; type&#x3D;&quot;Student&quot;&gt;\n        &lt;result property&#x3D;&quot;id&quot; column&#x3D;&quot;sid&quot;&#x2F;&gt;\n        &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;sname&quot;&#x2F;&gt;\n        &lt;association property&#x3D;&quot;teacher&quot; javaType&#x3D;&quot;Teacher&quot;&gt;\n            &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;tname&quot;&#x2F;&gt;\n        &lt;&#x2F;association&gt;\n    &lt;&#x2F;resultMap&gt;\n\nMySql多对一查询方式\n子查询\n联表查询\n\n10、一对多查询一个老师拥有多个学生！\n按结果嵌套处理&lt;select id&#x3D;&quot;getTeacher&quot; resultMap&#x3D;&quot;TeacherStudent&quot;&gt;\n    select s.id sid,s.name sname,t.id tid,t.name tname from student s,teacher t where s.tid &#x3D;t.id and t.id&#x3D;#&#123;tid&#125;\n&lt;&#x2F;select&gt;\n&lt;resultMap id&#x3D;&quot;TeacherStudent&quot; type&#x3D;&quot;Teacher&quot;&gt;\n    &lt;result property&#x3D;&quot;id&quot; column&#x3D;&quot;tid&quot;&#x2F;&gt;\n    &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;tname&quot;&#x2F;&gt;\n\n    &lt;collection property&#x3D;&quot;students&quot; ofType&#x3D;&quot;Student&quot;&gt;\n        &lt;result property&#x3D;&quot;id&quot; column&#x3D;&quot;sid&quot;&#x2F;&gt;\n        &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;sname&quot;&#x2F;&gt;\n        &lt;result property&#x3D;&quot;tid&quot; column&#x3D;&quot;tid&quot;&#x2F;&gt;\n    &lt;&#x2F;collection&gt;\n&lt;&#x2F;resultMap&gt;\n\n按查询嵌套处理&lt;!--    按照查询嵌套处理--&gt;\n\n    &lt;select id&#x3D;&quot;getTeacher2&quot; resultMap&#x3D;&quot;TeacherStudent2&quot;&gt;\n        select * from &#96;teacher&#96; where id&#x3D;#&#123;tid&#125;\n    &lt;&#x2F;select&gt;\n    &lt;resultMap id&#x3D;&quot;TeacherStudent2&quot; type&#x3D;&quot;Teacher&quot;&gt;\n        &lt;!--      List&lt;Student&gt; students 是一个集合 使用collection--&gt;\n        &lt;result property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;\n        &lt;collection property&#x3D;&quot;students&quot; javaType&#x3D;&quot;ArrayList&quot; ofType&#x3D;&quot;Student&quot; select&#x3D;&quot;getStudentByTeacherId&quot; column&#x3D;&quot;id&quot;&gt;&lt;&#x2F;collection&gt;\n    &lt;&#x2F;resultMap&gt;\n    &lt;select id&#x3D;&quot;getStudentByTeacherId&quot; resultType&#x3D;&quot;Student&quot;&gt;\n        select * from &#96;student&#96; where tid &#x3D;#&#123;tid&#125;\n    &lt;&#x2F;select&gt;\n\n\n\n小结\n关联 - association  【多对一】\n\n集合 - collection     【一对多】\n\njavaType &amp; ofType\n\nJavaType 用来指定实体类中的某个类型\nofType 用来指定映射到List或者集合中的POJO类型，泛型中的约束类型！\n\n\n\n注意点：\n保证SQL的可读性\n注意一对多和多对一中，属性名和字段的问题！\n如果问题不好排查错误，可以使用日志，建议使用log4j\n\n面试高频\nMysql引擎\nInnoDB底层原理\n索引\n索引优化！\n\n11、动态SQL动态SQL：动态SQL就是指根据不同的条件生成不同的SQL语句\n**本质还是SQL语句，只是在SQL层面，去执行一个逻辑代码 **\n搭建环境\n导包\n编写配置文件\n编写实体类\n编写实体类Mapper接口和Mapper.xml文件\n\nIF&lt;select id&#x3D;&quot;getBlogByIF&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;blog&quot;&gt;\n    select * from &#96;blog&#96; where 1&#x3D;1\n    &lt;if test&#x3D;&quot;title!&#x3D;null&quot;&gt;\n        and title like #&#123;title&#125;\n    &lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;author!&#x3D;null &quot;&gt;\n        and author like #&#123;author&#125;\n    &lt;&#x2F;if&gt;\n&lt;&#x2F;select&gt;\n\nWHERE*where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，*where 元素也会将它们去除。**\n&lt;!--    where标签--&gt;\n    &lt;select id&#x3D;&quot;getBlogByWhere&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;blog&quot;&gt;\n        select * from &#96;blog&#96;\n        &lt;where&gt;\n            &lt;if test&#x3D;&quot;title!&#x3D;null&quot;&gt;\n                title &#x3D;#&#123;title&#125;\n            &lt;&#x2F;if&gt;\n            &lt;if test&#x3D;&quot;author!&#x3D;null&quot;&gt;\n                and author&#x3D;#&#123;author&#125;\n            &lt;&#x2F;if&gt;\n        &lt;&#x2F;where&gt;\n    &lt;&#x2F;select&gt;\n\n\n\nSETset 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。\n&lt;!--    set标签--&gt;\n    &lt;update id&#x3D;&quot;updateBlogBySet&quot; parameterType&#x3D;&quot;map&quot;&gt;\n        update &#96;blog&#96;\n        &lt;set&gt;\n            &lt;if test&#x3D;&quot;title!&#x3D;null&quot;&gt;\n                title&#x3D;#&#123;title&#125;,\n            &lt;&#x2F;if&gt;\n            &lt;if test&#x3D;&quot;author!&#x3D;null&quot;&gt;\n                author&#x3D;#&#123;author&#125;,\n            &lt;&#x2F;if&gt;\n        &lt;&#x2F;set&gt;\n        where id&#x3D;#&#123;id&#125;\n    &lt;&#x2F;update&gt;\n\n\n\nchoose、when、otherwise有点像 Java 中的 switch 语句。\n&lt;!--    choose when otherwise标签--&gt;\n    &lt;select id&#x3D;&quot;getBlogByChoose&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;blog&quot;&gt;\n        select * from &#96;blog&#96;\n        &lt;where&gt;\n            &lt;choose&gt;\n                &lt;when test&#x3D;&quot;title!&#x3D;null&quot;&gt;\n                    title &#x3D;#&#123;title&#125;\n                &lt;&#x2F;when&gt;\n                &lt;when test&#x3D;&quot;author!&#x3D;null&quot;&gt;\n                    and author &#x3D;#&#123;author&#125;\n                &lt;&#x2F;when&gt;\n                &lt;otherwise&gt;\n                    and view &#x3D;#&#123;view&#125;\n                &lt;&#x2F;otherwise&gt;\n            &lt;&#x2F;choose&gt;\n        &lt;&#x2F;where&gt;\n    &lt;&#x2F;select&gt;\n\nSQL片段\n使用SQL标签抽取公共部分\n\n&lt;sql id&#x3D;&quot;if-where&quot;&gt;\n    &lt;where&gt;\n        &lt;if test&#x3D;&quot;title!&#x3D;null&quot;&gt;\n            title &#x3D;#&#123;title&#125;\n        &lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;author!&#x3D;null&quot;&gt;\n            and author&#x3D;#&#123;author&#125;\n        &lt;&#x2F;if&gt;\n    &lt;&#x2F;where&gt;\n&lt;&#x2F;sql&gt;\n\n\n\n\n使用include标签引用即可\n\n&lt;include refid&#x3D;&quot;if-where&quot;&gt;&lt;&#x2F;include&gt;\n\n\n\n注意事项：\n最好基于单表来定义SQL片段\n\nforEachforeach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！\n使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。\n&lt;select id&#x3D;&quot;getBlogByForEach&quot; resultType&#x3D;&quot;blog&quot; parameterType&#x3D;&quot;map&quot;&gt;\n    select * from &#96;blog&#96;\n    &lt;where&gt;\n        &lt;foreach collection&#x3D;&quot;ids&quot; item&#x3D;&quot;id&quot; open&#x3D;&quot;and (&quot; close&#x3D;&quot;)&quot; separator&#x3D;&quot;and&quot;&gt;\n            id&#x3D;#&#123;id&#125;\n        &lt;&#x2F;foreach&gt;\n    &lt;&#x2F;where&gt;\n&lt;&#x2F;select&gt;\n\n\n12、缓存12.1、简介查询  ：  连接数据库 ，耗资源！\n\t一次查询的结果，给他暂存在一个可以直接取到的地方！--&gt; 内存 ： 缓存\n\t\n我们再次查询相同数据的时候，直接走缓存，就不用走数据库了\n\n\n\n\n什么是缓存 [ Cache ]？\n\n存在内存中的临时数据。\n将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。\n\n\n为什么使用缓存？\n\n减少和数据库的交互次数，减少系统开销，提高系统效率。\n\n\n什么样的数据能使用缓存？\n\n经常查询并且不经常改变的数据。【可以使用缓存】\n\n\n\n12.2、Mybatis缓存\nMybatis包含一个非常强大的查询缓存特性，它可以非常方便地订制和配置缓存。缓存可以极大的提升查询效率\nMybatis系统中默认定义了两级缓存：一级缓存和*二级缓存\n默认情况下，只有一级缓存开启。(SqlSession级别地缓存，也称为本地缓存)\n二级缓存需要手动开启和配置，他是基于namespace级别的缓存。\n为了提高扩展性，Mybatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存。\n\n\n\n12.3、一级缓存\n一级缓存也叫本地缓存：SqlSession\n与数据库同义词会话期间查询到地数据会放在本地缓存中。\n以后如果需要相同地数据，直接从缓存中拿，不用再去查询数据库。\n\n\n\n测试步骤：\n\n开启日志\n测试在一个Session中查询两次相同的日志\n查看输出日志\n\n\n缓存失效的情况：\n\n查询不同的东西\n\n增删改操作，可能会改变原来的数据，所以必定会刷新缓存！\n@org.junit.Test\n   public void test() &#123;\n       SqlSession sqlSession &#x3D; MybatisUtil.getSqlSession();\n       UserMapper mapper &#x3D; sqlSession.getMapper(UserMapper.class);\n   \n       User user &#x3D; mapper.getUserById(1);\n       System.out.println(user);\n   \n       mapper.updateUser(new User(1,&quot;ajklad&quot;,&quot;adalskdjfkal&quot;));\n       sqlSession.commit();\n   \n       System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n   \n       User user1 &#x3D; mapper.getUserById(1);\n       System.out.println(user1);\n       sqlSession.close();\n   &#125;\n\n\n\n查询不同Mapper.xml\n\n手动清理缓存\n\n\nSqlSession.clearCache();\n\n\n\n\n小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是从拿到连接到关闭连接这个区间段！\n一级缓存就是一个Map。\n12.4、二级缓存\n二级缓存也叫全局缓存，一级缓存作用于太低，所以诞生了二级缓存\n基于namespace级别的缓存，一个名称空间，对应一个二级缓存\n工作机制\n一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；\n如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；\n新的会话查询信息，就可以从二级缓存中获取内容；\n不同mapper查出的数据会放在自己对应的缓存中；\n\n\n\n步骤：\n\n开启全局缓存(显式开启)\n\n&lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n\n\n在要使用的二级缓存的Mapper中开启\n\n&lt;cache&#x2F;&gt;\n\n​    也可以自定义参数\n&lt;cache\n  eviction&#x3D;&quot;FIFO&quot;\n  flushInterval&#x3D;&quot;60000&quot;\n  size&#x3D;&quot;512&quot;\n  readOnly&#x3D;&quot;true&quot;&#x2F;&gt;\n\n\n测试\n\n\n需要将类序列化，否则在readOnly&#x3D;”false“时会报错。\n\nCaused by: java.io.NotSerializableException: com.kuang.pojo.User\n\n小结：\n\n只要开启了二级缓存，在同一个Mapper下就有效\n所有的数据都会先放在一级缓存中\n只有当会话提交，或者关闭时，才会提交到二级缓存中。\n\n12.5、缓存原理\n12.6、自定义缓存-ehcache","slug":"MyBatis","date":"2022-02-10T17:38:23.826Z","categories_index":"","tags_index":"","author_index":"Xoc001"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"JavaWeb1、Servlet1.1、ServletContext应用1、获取初始化参数&lt;!-- 配置一些web应用初始化参数--&gt;\n&lt;context-param&gt;\n    &lt;param-name&gt;url&lt;&#x2F;param-name&gt;\n    &lt;param-value&gt;jdbc::mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis&lt;&#x2F;param-value&gt;\n&lt;&#x2F;context-param&gt;\n\n\n\nprotected void do Get(HttpServletRequest req,HttpServeltResponse resp)\n&#123;\n    SetvletContext context &#x3D; this.getServletContext();\n    String url &#x3D; context.getInitParamer(&quot;url&quot;);\n    resp.getWriter().write(url);\n&#125;\n\n\n\n\n\n2、请求转发public class DemoServlet03 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        ServletContext context &#x3D; this.getServletContext();\n        context.getRequestDispatcher(&quot;&#x2F;hello&quot;).forward(req,resp);       &#x2F;&#x2F;请求转发\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        doGet(req, resp);\n    &#125;\n&#125;\n\n\n\n3、读取资源文件在java目录下新建properties在resources目录下新建properties都被打包到同一个路径下：classes，我们俗称这个路径为classpath\n思路：需要一个文件流\npublic class DemoServlet04 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        InputStream input &#x3D; this.getServletContext().getResourceAsStream(&quot;&#x2F;WEB-INF&#x2F;classes&#x2F;db.properties&quot;);\n        Properties prop &#x3D; new Properties();\n        prop.load(input);\n        String username &#x3D; prop.getProperty(&quot;username&quot;);\n        String password &#x3D; prop.getProperty(&quot;password&quot;);\n        resp.getWriter().print(&quot;username &#x3D;&quot; + username);\n        resp.getWriter().print(&quot;password &#x3D;&quot;+ password);\n\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        doGet(req, resp);\n    &#125;\n&#125;\n\n\n\n&lt;!--  在build中配置resources ，来防止资源导出时出现的问题--&gt;\n&lt;build&gt;\n    &lt;resources&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;\n            &lt;includes&gt;\n                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;\n                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;\n            &lt;&#x2F;includes&gt;\n            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;\n        &lt;&#x2F;resource&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;\n            &lt;includes&gt;\n                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;\n                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;\n            &lt;&#x2F;includes&gt;\n            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;\n        &lt;&#x2F;resource&gt;\n    &lt;&#x2F;resources&gt;\n&lt;&#x2F;build&gt;\n\n\n\n1.2、HttpServletResponseweb服务器接收到客户端http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse;\n\n如果要获取客户端请求过来的参数:找HttpServletRequest\n如果要给客户端响应一些信息：找HttpServletResponse;\n\n1、简单分类负责向浏览器发送数据的方法ServletOutputStream getOutputStream() throws IOException;\nPrinter getWriter() throws IOException;\t\n\n负责向浏览器发送相应头的方法void setCharacterEncoding(String var1);\n\n   void setContentLength(int var1);\n\n   void setContentLengthLong(long var1);\n\n   void setContentType(String var1);\n\n   void setBufferSize(int var1);\n\n\n\n2、常见应用1、向浏览器输出消息2、下载文件​        1.要获取下载文件的路径\n​        2.下载的文件名\n​        3.让浏览器能够支持下载指定的东西\n​        4.获取下载文件的输入流\n​        5.创建缓冲区\n​        6.获取OutputStream对象\n​        7.将FileOutputStream流写入到buffer缓冲区\n​        8.使用OutputStream将缓冲区的数据输出到客户端\n@WebServlet(&quot;&#x2F;file&quot;)\npublic class FileServlet extends HttpServlet &#123;\n        @Override\n        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n            &#x2F;&#x2F;获取下载文件的路径\n            String realPath &#x3D; &quot;D:\\\\IDEAProject\\\\JavaWebStudy\\\\Study03\\\\target\\\\Study03\\\\WEB-INF\\\\classes\\\\0.jpg&quot;;\n\n            System.out.println(&quot;文件名 :&quot; + realPath);\n\n            &#x2F;&#x2F;下载的文件名\n            String fileName &#x3D; realPath.substring(realPath.lastIndexOf(&quot;\\\\&quot;)+1);\n            &#x2F;&#x2F;设置文件头\n            resp.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename&#x3D;&quot;+ fileName);\n            &#x2F;&#x2F;获取下载文件的输入流\n            FileInputStream input &#x3D; new FileInputStream(realPath);\n            &#x2F;&#x2F;创建缓冲区\n            int length&#x3D;0;\n            byte[] buffer &#x3D; new byte[4096];\n            &#x2F;&#x2F;获取OutputStream对象\n            ServletOutputStream output &#x3D; resp.getOutputStream();\n            &#x2F;&#x2F;将FileOutputStream流写入到buffer 缓冲区\n            while((length&#x3D;input.read(buffer))&gt;0)\n            &#123;\n                output.write(buffer,0,length);\n            &#125;\n            input.close();\n            output.close();\n        &#125;\n\n3、实现重定向\nB一个web资源收到客户端A请求后，B他会通知A客户端去访问另外一个web资源C，这个过程叫做重定向。\n常见场景：\n\n用户登录\nvoid sendRedirect(String var1) throws IOException;\n\n测试\n@WebServlet(&quot;&#x2F;send&quot;)\npublic class SendRedirectServlet extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\n        &#x2F;*\n            resp.setHeader(&quot;Location&quot;,&quot;&#x2F;Study03_war&#x2F;image&quot;);\n            resp.setStatus(302);\n         *&#x2F;\n       resp.sendRedirect(&quot;&#x2F;Study03_war&#x2F;image&quot;);\n    &#125;\n&#125;\n\n重定向和转发的区别相同点\n\n页面都会实现跳转\n\n不同点\n\n请求转发时 url不会产生变化\n重定向时 url地址栏会产生变化。\n\n1.3、HttpServeltRequestHttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest,通过这个HttpServletRequset方法，获得客户端的所有信息。\n2、Cookie、Session保存会话的两种技术\ncookie\n\n客户端技术\n\nsession \n\n服务器技术，利用这个技术，可以保存用户的会话信息，我们可以把信息放在session中。\n\n2.1、Cookie​    1.请求中获取Cookie信息\n​    2.服务器响应给客户端cookie\nCookie [] cookies &#x3D; req.getCookies(); \t&#x2F;&#x2F;获得Cookie\ncookie.getName();\t&#x2F;&#x2F;获得cookie中的name\ncookie.getValue();\t&#x2F;&#x2F;获得cookie中的Value\nnew Cookie(&quot;lastLoginTime&quot;,System.currentTileMillis()+&quot;&quot;);\t&#x2F;&#x2F;新建一个cookie\ncookie.setMaxAge(24*3600)\t&#x2F;&#x2F;设置cookie的有效期\n\n\n​    3.编码解码\nURLEncoder.encode(&quot;百度&quot;,&quot;UTF-8&quot;);\nURLDecoder.decode(cookie.getValue(),&quot;UTF-8&quot;);\n\n\n\n3、JSP3.1、什么是JSPjava Server pages：Java 服务器端页面，也和Servlet一样，用于动态的Web技术！\n特点：\n\n写JSP就像在HTML\n区别：\nHTML只给用户提供静态数据\nJSP页面中可以嵌入JAVA代码，为用户提供动态数据；\n\n\n\n3.2、JSP语法JSP表达式&lt;%&#x3D; 变量或者表达式%&gt;\n&lt;%&#x3D; new java.util.Date()%&gt;\n\n\n\nJSP脚本片段&lt;%\n \tint sum &#x3D;0;\n\tfor(int i&#x3D;1;i&lt;&#x3D;100;i++)\n    &#123;\n        sum+&#x3D;i;\n    &#125;\n\tout.println(&quot;&lt;h1&gt;Sum&#x3D;&quot;+sum +&quot;&#x2F;h1&gt;&quot;);\n %&gt;\n\nJSP声明&lt;%!\n   static &#123;\n     System.out.println(&quot;Loading Servlet&quot;);\n   &#125;\n   private int globalVar &#x3D;0;\n   public void test()&#123;\n     System.out.println(&quot;进入了Test 方法&quot;);\n   &#125;\n %&gt;\n\nJSP声明：会被编译到JSP生成的Java的类中。其他的，会被生成到_jspService中！\n在JSP，嵌入Java代码即可！\n&lt;%%&gt;\n&lt;%&#x3D;%&gt;\n&lt;%!%&gt;\n&lt;%--注释--%&gt;\n\n&lt;!--HTML注释--&gt;\n&lt;%-- jsp注释 --&gt;\n\nJSP的注释，不会在页面显示，HTML的会显示。\n3.3、JSP指令&lt;%!-- @include会将两个页面合二为一 --&gt;\n&lt;%@include file&#x3D;&quot;&quot;%&gt;\n&lt;hr&gt;\n\n&lt;%!-- jsp:include：拼接页面，本质还是三个--&gt;\n&lt;jsp:include page&#x3D;&quot;&quot;&#x2F;&gt;\n\n\n\n3.4、9大内置对象\nPageContext\nRequest\nResponse\nSession\nApplication  【ServletContext】\nconfig  【ServletConfig】\npage\nexception\n\npageContext.setAttribute(&quot;name1&quot;,&quot;蟑螂恶霸&quot;);           &#x2F;&#x2F;保存的数据只在一个页面中有效\n   request.setAttribute(&quot;name2&quot;,&quot;蜻蜓队长&quot;);               &#x2F;&#x2F;保存的数据只在一次请求中有效，请求转发会携带这个数据\n   session.setAttribute(&quot;name3&quot;,&quot;车轮滚滚&quot;);               &#x2F;&#x2F;保存的数据在一次会话中有效，从打开浏览器到关闭浏览器\n   application.setAttribute(&quot;name4&quot;,&quot;蝎子莱莱&quot;);           &#x2F;&#x2F;保存的数据在服务器中有效，从打开服务器到关闭\n\nrequest:客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的。\nsession: 客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车\napplication：客户端向服务器发送请求，产生的数据，一个用户用完了，其他的用户还可以使用，比如：聊天数据。\n3.5、JSP标签、JSTL标签EL表达式：\n\n获取数据\n执行运算\n获取web开发的常用对象\n\njsp标签\n&lt;%--jsp:include--&gt;\n &lt;%-- http:&#x2F;&#x2F;localhost:8080&#x2F;jsptag.jsp?name&#x3D;abc&amp;age&#x3D;12--&gt;\n\n&lt;jsp:forward page&#x3D;&#39;&#x2F;jsptag2.jsp&#39;&gt;\n    &lt;jsp:param name&#x3D;&quot;name&quot; value&#x3D;&quot;kuangshen&quot;&gt;&lt;&#x2F;jsp:param&gt;\n    &lt;jsp:param name&#x3D;&quot;age&quot; value&#x3D;&quot;12&quot;&gt;&lt;&#x2F;jsp:param&gt;\n&lt;&#x2F;jsp:forward&gt;\n\n\n\n**JSTL **\nJSTL标签库的使用就是为了弥补HTML标签的不足；它自定义许多标签，可以供我们使用，标签的功能和Java代码一样！\n4、JavaBean实体类\nJavaBean有特定的写法：\n\n必须要有一个无参构造\n属性必须私有化\n必须有对应的get&#x2F;set方法\n\n一般用来和数据库的字段做映射 ORM;\nORM:对象映射关系\n\n表—&gt;类\n字段—&gt;属性\n行记录—&gt;对象\n\n\n\n\nid\nname\nage\nphone\n\n\n\n1\na\n8\n13800012345\n\n\n2\nb\n10\n13800012344\n\n\n3\nc\n18\n13900077771\n\n\nclass people&#123;\n    private int id;\n    private String name;\n    private int age;\n    private String phone;\n&#125;\n\n\n\n\n5、MVC三层架构5.1、MVC三层架构 \nModel\n\n业务处理：业务逻辑   (Service)\n数据持久层：CRUD (Dao)\n\nView\n\n展示数据\n提供连接发起Servlet请求\n\nController\n\n接收用户的请求：（req：请求参数、session 会话请求…）\n交给业务层处理对应的代码\n控制视图的跳转\n\n登录----&gt;接收用户的登录请求---&gt;处理用户的请求(获取用户登录的参数，username，password)----&gt;交给业务层处理登录业务(判断用户名密码是否正确) ---&gt;Dao层查询用户名和密码是否正确----&gt;数据库\n\n6、FilterFilter：过滤器，用来过滤网站\n\n处理中文乱码\n登陆验证..\n\n\n2\n&#x2F;&#x2F;Filter过滤\n\n@WebFilter(&quot;&#x2F;servlet&#x2F;test1&quot;)\npublic class CharaterEncodingFilter implements Filter &#123;\n    \n    &#x2F;&#x2F;初始化:Web服务器启动，就已经初始化了，随时等待过滤对象的出现！\n    public void init(FilterConfig filterConfig) throws ServletException &#123;\n\n    &#125;\n\n    &#x2F;&#x2F;Chain:链\n    &#x2F;&#x2F;1.过滤中的所有代码，在过滤特定请求的时候都会执行\n    &#x2F;&#x2F;2.必须要让过滤器继续执行\n    &#x2F;&#x2F;chain.Filter(request,response);\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;\n        request.setCharacterEncoding(&quot;utf-8&quot;);\n        response.setCharacterEncoding(&quot;utf-8&quot;);\n        response.setContentType(&quot;text&#x2F;plain&quot;);\n\n        System.out.println(&quot;进去Filter过滤器前***&quot;);\n        chain.doFilter(request,response);\n        System.out.println(&quot;进入Filter过滤器后***&quot;);\n\n    &#125;\n\t&#x2F;&#x2F;销毁:web服务器关闭的时候，过滤会销毁。\n    public void destroy() &#123;\n\n    &#125;\n&#125;\n\n\n3.web.xml 配置\n&lt;filter&gt;\n    &lt;filter-name&gt;CharaterEncodingFilter&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;my.CharaterEncodingFilter&lt;&#x2F;filter-class&gt;\n&lt;&#x2F;filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;CharaterEncodingFilter&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;servlet&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;\n\n7、监听器实现一个监听器的接口\n​    1.编写一个监听器接口，实现监听器的接口\npublic class OnlineCountListener implements HttpSessionListener &#123;\n    public void sessionCreated(HttpSessionEvent httpSessionEvent) &#123;\n        ServletContext servletContext &#x3D; httpSessionEvent.getSession().getServletContext();\n        System.out.println(httpSessionEvent.getSession().getId());\n        Integer onlineCount &#x3D; (Integer) servletContext.getAttribute(&quot;OnlineCount&quot;);\n        if (onlineCount &#x3D;&#x3D; null) &#123;\n            onlineCount &#x3D; new Integer(1);\n        &#125; else &#123;\n            System.out.println(servletContext);\n            onlineCount +&#x3D; 1;\n        &#125;\n        servletContext.setAttribute(&quot;OnlineCount&quot;, onlineCount);\n    &#125;\n\n    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) &#123;\n        ServletContext servletContext &#x3D; httpSessionEvent.getSession().getServletContext();\n        Integer onlineCount &#x3D; (Integer) servletContext.getAttribute(&quot;OnlineCount&quot;);\n        if (onlineCount &#x3D;&#x3D; null) &#123;\n            onlineCount &#x3D; new Integer(0);\n        &#125; else &#123;\n            onlineCount -&#x3D;1;\n        &#125;\n        servletContext.setAttribute(&quot;OnlineCount&quot;, onlineCount);\n    &#125;\n&#125;\n\n\n\n​    2.web.xml中注册监听器\n&lt;listener&gt;\n    &lt;listener-class&gt;my.listener.OnlineCountListener&lt;&#x2F;listener-class&gt;\n&lt;&#x2F;listener&gt;\n\n\n\n8、过滤器、监听器常见应用 用户登陆之后才能进入主页！用户注销后就不能进入主页了！\n1.用户登陆之后，向Session中放入用户的数据\n2.进入主页的时候要判断用户是否已经登陆；要求：在过滤器中实现！\nHttpServletRequest req &#x3D; (HttpServletRequest) request;\nHttpServletResponse resp &#x3D; (HttpServletResponse) response;\nHttpSession session &#x3D; req.getSession();\nObject username &#x3D; session.getAttribute(&quot;username&quot;);\nif(username &#x3D;&#x3D; null)\n&#123;\n  \t resp.sendRedirect(&quot;&#x2F;login.jsp&quot;);\n&#125;\n\nchain.doFilter(request,response);\n\n\n\n9、JDBCJDBC固定步骤：1.加载驱动\n2.连接数据库，代表数据库\n3.向数据库发送SQL的对象Statement：CRUD\n4.编写SQL （编写业务，不同的SQL）\n5.执行SQL\n6.关闭连接\n&#x2F;&#x2F;配置信息\n     String url &#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jdbc?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&quot;;\n     String username&#x3D;&quot;root&quot;;\n     String password&#x3D;&quot;&quot;;\n\n     &#x2F;&#x2F;1.加载驱动\n     Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n\n     &#x2F;&#x2F;2.连接数据库\n     Connection connection &#x3D; DriverManager.getConnection(url,username,password);\n\n     &#x2F;&#x2F;向数据库发送SQL的对象Statement ：CRUD;\n     Statement statement &#x3D; connection.createStatement();\n     \n     &#x2F;&#x2F;编写SQL\n     String sql&#x3D;&quot;select * from people&quot;;\n\n     &#x2F;&#x2F;执行查询SQL,返回一个结果集\n     ResultSet rs &#x3D; statement.executeQuery(sql);\n     while (rs.next())\n     &#123;\n         System.out.println(&quot;id&#x3D;&quot;+ rs.getObject(&quot;id&quot;));\n         System.out.println(&quot;name&#x3D;&quot;+ rs.getObject(&quot;name&quot;));\n         System.out.println(&quot;age&#x3D;&quot;+ rs.getObject(&quot;age&quot;));\n         System.out.println(&quot;phone&#x3D;&quot;+ rs.getObject(&quot;phone&quot;));\n         System.out.println(&quot;&quot;);\n     &#125;\n\n     &#x2F;&#x2F;关闭\n     rs.close();\n     statement.close();\n     connection.close();\n \n\n\n\n预编译SQL处理&#x2F;&#x2F;配置信息\n     String url &#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jdbc?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&quot;;\n     String username&#x3D;&quot;root&quot;;\n     String password&#x3D;&quot;&quot;;\n\n     &#x2F;&#x2F;1.加载驱动\n     Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n\n     &#x2F;&#x2F;2.连接驱动\n     Connection connection &#x3D; DriverManager.getConnection(url,username,password);\n\n     &#x2F;&#x2F;3.SQL语句\n     String sql&#x3D;&quot;insert into people (id, name, age, phone)values (?,?,?,?);&quot;;\n\n     &#x2F;&#x2F;编译预处理\n     PreparedStatement preparedStatement &#x3D; connection.prepareStatement(sql);\n     preparedStatement.setInt(1,4);\n     preparedStatement.setString(2,&quot;hello&quot;);\n     preparedStatement.setInt(3,13);\n     preparedStatement.setString(4,&quot;13800012312&quot;);\n\n     &#x2F;&#x2F;5.执行sql\n     int i &#x3D; preparedStatement.executeUpdate();\n     if(i&gt;0)\n     &#123;\n         System.out.println(&quot;插入成功** &quot;);\n     &#125;\n\n     &#x2F;&#x2F;关闭连接\n     preparedStatement.close();\n     connection.close();\n\n\n\n事务要么都成功，要么都失败！\nACID原则：保证数据安全\n开启事务\n事务提交\tcommit();\n事务回滚\trollback();\n关闭事务\n    \n转账:\nA:1000\nB:1000\nA(900) --100--&gt; B(1000)\n\n\n\n\njunit\n&lt;dependency&gt;\n    &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;junit-dep&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;4.11&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;a\n\n使用@Test注解进行单元测试\n\n\n错误提示\n\n事务操作\n@Test\npublic void test() throws ClassNotFoundException, SQLException &#123;\n    &#x2F;&#x2F;配置信息\n    String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jdbc?useUniode&#x3D;true&amp;characterEncoding&#x3D;utf-8&quot;;\n    String username &#x3D; &quot;root&quot;;\n    String password &#x3D; &quot;&quot;;\n\n    Connection connection &#x3D; null;\n    &#x2F;&#x2F;1.加载驱动\n    try &#123;\n        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n\n        &#x2F;&#x2F;2.连接驱动\n        connection &#x3D; DriverManager.getConnection(url, username, password);\n\n        &#x2F;&#x2F;3.通知数据库开启事务\n        connection.setAutoCommit(false);    &#x2F;&#x2F;false 开启事务，true关闭事务\n\n        String sql &#x3D; &quot;update account set money &#x3D; money-100 where name &#x3D; &#39;A&#39;&quot;;\n        connection.prepareStatement(sql).executeUpdate();\n        int i &#x3D;1&#x2F;0;\n\n        String sql1 &#x3D; &quot;update account set money &#x3D; money+100 where name &#x3D; &#39;B&#39;&quot;;\n        connection.prepareStatement(sql1).executeUpdate();\n        connection.commit();\n        System.out.println(&quot;提交成功 **** &quot;);\n    &#125; catch (Exception e) &#123;\n        try&#123;\n            &#x2F;&#x2F;出现异常 就进行数据库回滚事务\n            connection.rollback();\n        &#125;catch(Exception e1)&#123;\n            e1.printStackTrace();\n        &#125;\n\n        e.printStackTrace();\n    &#125;\n\n&#125;\n\n\n\n\n\n10、邮件发送1、smtp服务器地址：一般是smtp.xxx.com，163: smtp.163.com   qq:  smtp.qq.com\nSMTP协议发送邮件：我们通常把处理用户smtp请求(邮件发送请求)的服务器称之为smtp服务器(邮件发送服务器)。\nPOP3协议接收邮件：我们通常把处理用户pop3请求(邮件接收请求)的服务器称之为POP3服务器(邮件接收服务器)\n邮件收发原理\nJava 发送邮件概述使用Java发送E-mail 需要依赖JavaMail API 和 Java Activation Framework。\n两个jar 包\n\nmail.jar\nactivation.jar\n\n发送邮件只需调用JavaMail开发包中的相应API类 即可。\n尝试发送一封简单的邮件，确保电脑可以连接网络。\n\n创建包含邮件服务器的网络连接信息的Session对象\n创建代表邮件内容的Message对象\n创建Transport对象，连接服务器，发送Message，关闭连接\n\n主要有四个核心类，在编写程序时，记住四个核心类，可以编写出Java邮件处理程序。\n\n发送纯文本邮件package my;\n\nimport com.sun.mail.util.MailSSLSocketFactory;\n\nimport javax.mail.*;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.security.GeneralSecurityException;\nimport java.util.Properties;\n\npublic class Test &#123;\n    public static void main(String[]args) throws Exception &#123;\n        Properties prop &#x3D; new Properties();\n        prop.setProperty(&quot;mail.host&quot;,&quot;smtp.qq.com&quot;);        &#x2F;&#x2F;设置QQ邮件服务器\n        prop.setProperty(&quot;mail.transport.protocol&quot;,&quot;smtp&quot;);     &#x2F;&#x2F;邮件发送协议\n        prop.setProperty(&quot;mail.smtp.auth&quot;,&quot;true&quot;);\n\n        &#x2F;&#x2F;关于QQ邮箱,还要设置SSL加密，加上以下代码\n        MailSSLSocketFactory sf &#x3D; new MailSSLSocketFactory();\n        sf.setTrustAllHosts(true);\n        prop.put(&quot;mail.smtp.ssl.enable&quot;,&quot;true&quot;);\n        prop.put(&quot;mail.smtp.ssl.socketFactory&quot;,sf);\n\n        &#x2F;&#x2F;使用Java 发送邮件的5个步骤\n\n        &#x2F;&#x2F;创建定义整个应用程序所需的环境信息的Session 对象\n        Session session &#x3D; Session.getDefaultInstance(prop, new Authenticator() &#123;\n            @Override\n            protected PasswordAuthentication getPasswordAuthentication() &#123;\n                &#x2F;&#x2F;发件人邮件用户名，授权码\n                return new PasswordAuthentication(&quot;邮箱用户名”，“授权码&quot;);\n            &#125;\n        &#125;);\n\n        &#x2F;&#x2F;开启Session Debug 模式，这样就可以查看邮件发送状态\n        session.setDebug(true);\n\n        &#x2F;&#x2F;2、通过session 得到transport对象\n        Transport ts &#x3D; session.getTransport();\n\n        &#x2F;&#x2F;使用邮箱的用户名和授权码连上邮件服务器\n        ts.connect(&quot;邮箱用户名&quot;,&quot;授权码&quot;);\n\n        &#x2F;&#x2F;创建邮件对象\n        MimeMessage message &#x3D; new MimeMessage(session);\n        &#x2F;&#x2F;指明邮件发件人\n        message.setFrom(new InternetAddress(&quot;发件人邮箱地址&quot;));\n\n        &#x2F;&#x2F;指明邮件收件人\n        message.setRecipient(Message.RecipientType.TO,new InternetAddress(&quot;收件人邮箱&quot;));\n\n        &#x2F;&#x2F;邮件的标题\n        message.setSubject(&quot;Java发送邮件测试&quot;);\n\n        &#x2F;&#x2F;邮件文本的内容\n        message.setContent(&quot;&lt;h1 style&#x3D;&#39;color:blue&#39;&gt;你好啊，阿巴阿巴阿巴阿巴阿巴阿巴&lt;&#x2F;h1&gt;&quot;,&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);\n\n        &#x2F;&#x2F;发送邮件\n        ts.sendMessage(message,message.getAllRecipients());\n\n        &#x2F;&#x2F;关闭\n        ts.close();\n    &#125;\n&#125;\n\n\n\n\n带图片和附件的邮件\npackage my;\n\nimport com.sun.mail.util.MailSSLSocketFactory;\n\nimport javax.activation.DataHandler;\nimport javax.activation.FileDataSource;\nimport javax.mail.*;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeBodyPart;\nimport javax.mail.internet.MimeMessage;\nimport javax.mail.internet.MimeMultipart;\nimport java.security.GeneralSecurityException;\nimport java.util.Properties;\n\npublic class Test &#123;\n    public static void main(String[] args) throws Exception &#123;\n        Properties prop &#x3D; new Properties();\n        prop.setProperty(&quot;mail.host&quot;, &quot;smtp.qq.com&quot;);        &#x2F;&#x2F;设置QQ邮件服务器\n        prop.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;);     &#x2F;&#x2F;邮件发送协议\n        prop.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;);\n\n        &#x2F;&#x2F;关于QQ邮箱,还要设置SSL加密，加上以下代码\n        MailSSLSocketFactory sf &#x3D; new MailSSLSocketFactory();\n        sf.setTrustAllHosts(true);\n        prop.put(&quot;mail.smtp.ssl.enable&quot;, &quot;true&quot;);\n        prop.put(&quot;mail.smtp.ssl.socketFactory&quot;, sf);\n\n        &#x2F;&#x2F;使用Java 发送邮件的5个步骤\n\n        &#x2F;&#x2F;创建定义整个应用程序所需的环境信息的Session 对象\n        Session session &#x3D; Session.getDefaultInstance(prop, new Authenticator() &#123;\n            @Override\n            protected PasswordAuthentication getPasswordAuthentication() &#123;\n                &#x2F;&#x2F;发件人邮件用户名，授权码\n                return new PasswordAuthentication(&quot;635996171@qq.com&quot;, &quot;cwocrxkrtpcwbbdd&quot;);\n            &#125;\n        &#125;);\n\n        &#x2F;&#x2F;开启Session Debug 模式，这样就可以查看邮件发送状态\n        session.setDebug(true);\n\n        &#x2F;&#x2F;2、通过session 得到transport对象\n        Transport ts &#x3D; session.getTransport();\n\n        &#x2F;&#x2F;使用邮箱的用户名和授权码连上邮件服务器\n        ts.connect(&quot;635996171@qq.com&quot;, &quot;cwocrxkrtpcwbbdd&quot;);\n\n        &#x2F;&#x2F;创建邮件对象\n        MimeMessage message &#x3D; new MimeMessage(session);\n        &#x2F;&#x2F;指明邮件发件人\n        message.setFrom(new InternetAddress(&quot;635996171@qq.com&quot;));\n\n        &#x2F;&#x2F;指明邮件收件人\n        message.setRecipient(Message.RecipientType.TO, new InternetAddress(&quot;965166503@qq.com&quot;));\n\n        &#x2F;&#x2F;邮件的标题\n        message.setSubject(&quot;带图片邮件测试&quot;);\n\n&#x2F;&#x2F;        &#x2F;&#x2F;邮件文本的内容\n&#x2F;&#x2F;        message.setContent(&quot;&quot;, &quot;text&#x2F;html;charset&#x3D;utf-8&quot;);\n\n        &#x2F;&#x2F;准备图片数据\n        MimeBodyPart image &#x3D; new MimeBodyPart();\n        &#x2F;&#x2F;图片需要经过数据处理。。。\n        DataHandler dh &#x3D; new DataHandler(new FileDataSource(&quot;D:\\\\IDEAProject\\\\JavaWebStudy\\\\EmailStudy\\\\src\\\\0.jpg&quot;));\n        image.setDataHandler(dh);\n        image.setContentID(&quot;0.jpg&quot;);\n\n        &#x2F;&#x2F;准备正文数据\n        MimeBodyPart text &#x3D; new MimeBodyPart();\n        text.setContent(&quot;这是一封带图片的邮件&lt;img src&#x3D;&#39;cid:0.jpg&#39;&#x2F;&gt;&quot;,&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);\n\n        &#x2F;&#x2F;描述数据关系\n        MimeMultipart mm &#x3D; new MimeMultipart();\n        mm.addBodyPart(image);\n        mm.addBodyPart(text);\n        mm.setSubType(&quot;related&quot;);\n\n        &#x2F;&#x2F;设置到消息中，保存修改\n        message.setContent(mm);\n        message.saveChanges();\n\n        &#x2F;&#x2F;发送邮件\n        ts.sendMessage(message, message.getAllRecipients());\n\n\n        &#x2F;&#x2F;关闭\n        ts.close();\n    &#125;\n&#125;\n\n\n\n\n网站注册发送邮件实现什么是序列化？\n序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。\n编写Servletpackage my;\n\nimport my.pojo.User;\nimport my.utils.SendMail;\n\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class RegisterServlet extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        doPost(req, resp);\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        String username &#x3D; req.getParameter(&quot;username&quot;);\n        String password &#x3D; req.getParameter(&quot;password&quot;);\n        String email &#x3D; req.getParameter(&quot;email&quot;);\n\n        User user &#x3D; new User(username, password, email);\n\n        &#x2F;&#x2F;用户注册成功后，给用户发送一封邮件\n        &#x2F;&#x2F;使用线程来发送邮件，防止出现耗时，和网站注册人数过多的情况\n        SendMail sendMail &#x3D; new SendMail(user);\n        &#x2F;&#x2F;启动线程，线程启动后就会执行run方法来发送邮件。\n        sendMail.start();\n\n        &#x2F;&#x2F;注册用户\n        req.setAttribute(&quot;message&quot;,&quot;注册成功，我们已发送一封邮件到您的邮箱，请注意查收。&quot;);\n        req.getRequestDispatcher(&quot;info.jsp&quot;).forward(req,resp);\n\n    &#125;\n&#125;\n\n\n\n\n编写发送邮件工具类(使用线程，防止出现耗时，或注册人数过多的情况。减少用户在界面的等待)\npackage my.utils;\n\nimport com.sun.mail.util.MailSSLSocketFactory;\nimport my.pojo.User;\n\nimport javax.mail.*;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.util.Properties;\n\npublic class SendMail extends Thread &#123;\n    &#x2F;&#x2F;用于给用户发送邮件的邮箱\n    private String from &#x3D; &quot;635996171@qq.com&quot;;\n    &#x2F;&#x2F;邮箱的用户名\n    private String username &#x3D; &quot;635996171@qq.com&quot;;\n    &#x2F;&#x2F;邮箱的密码\n    private String password &#x3D; &quot;cwocrxkrtpcwbbdd&quot;;\n    &#x2F;&#x2F;发送邮件的服务器地址\n    private String port &#x3D; &quot;smtp.qq.com&quot;;\n\n    private User user;\n\n    public SendMail(User user) &#123;\n        this.user &#x3D; user;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        try &#123;\n            Properties prop &#x3D; new Properties();\n            prop.setProperty(&quot;mail.port&quot;, port);\n            prop.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;); &#x2F;&#x2F;邮件发送协议\n            prop.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;);\n\n            &#x2F;&#x2F;QQ邮箱设置SSL加密\n\n            MailSSLSocketFactory sf &#x3D; new MailSSLSocketFactory();\n            sf.setTrustAllHosts(true);\n            prop.put(&quot;mail.smtp.ssl.enable&quot;, &quot;true&quot;);\n            prop.put(&quot;mail.smtp.ssl.socketFactory&quot;, sf);\n\n            &#x2F;&#x2F;发送邮件\n            &#x2F;&#x2F;创建定义整个应用程序的环境信息的Session对象\n            Session session &#x3D; Session.getDefaultInstance(prop, new Authenticator() &#123;\n                @Override\n                protected PasswordAuthentication getPasswordAuthentication() &#123;\n                    &#x2F;&#x2F;发件人用户名和授权码\n                    return new PasswordAuthentication(username, password);\n                &#125;\n            &#125;);\n\n            &#x2F;&#x2F;开启Debug\n            session.setDebug(true);\n\n            &#x2F;&#x2F;2、通过Session得到Transport对象\n            Transport ts &#x3D; session.getTransport();\n\n            &#x2F;&#x2F;使用邮箱的用户名和授权码登录服务器\n            ts.connect(port, username, password);\n\n            &#x2F;&#x2F;创建邮箱对象\n            MimeMessage message &#x3D; new MimeMessage(session);\n\n            &#x2F;&#x2F;指明邮件发送人\n            message.setFrom(new InternetAddress(from));\n\n            &#x2F;&#x2F;指明邮件接收人\n            message.setRecipient(Message.RecipientType.TO, new InternetAddress(user.getEmail()));\n\n            &#x2F;&#x2F;邮件的标题\n            message.setSubject(&quot;网站注册用户消息提示&quot;);\n            &#x2F;&#x2F;邮件内容\n            String info &#x3D; &quot;恭喜您注册成功，您的用户名：&quot; + user.getUsername() + &quot;您的密码：&quot; + user.getPassword() + &quot;,请妥善保管，如有问题，请联系我们&quot;;\n            message.setContent(info, &quot;text&#x2F;html;charset&#x3D;utf-8&quot;);\n            message.saveChanges();\n\n            ts.sendMessage(message, message.getAllRecipients());\n            ts.close();\n\n        &#125; catch (Exception e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n\n    &#125;\n&#125;\n\n\n\n\n11、Mavenmaven由于他的约定大于配置，我们之后可以能遇到我们写的配置文件，无法被导出或者生效的问题，解决方案：\n&lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt;\n&lt;build&gt;\n    &lt;resources&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;\n            &lt;includes&gt;\n                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;\n                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;\n            &lt;&#x2F;includes&gt;\n            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;\n        &lt;&#x2F;resource&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;\n            &lt;includes&gt;\n                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;\n                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;\n            &lt;&#x2F;includes&gt;\n            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;\n        &lt;&#x2F;resource&gt;\n    &lt;&#x2F;resources&gt;\n&lt;&#x2F;build&gt;\n\n","slug":"JavaWeb","date":"2022-02-10T17:38:23.820Z","categories_index":"","tags_index":"","author_index":"Xoc001"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-02-10T17:11:31.322Z","categories_index":"","tags_index":"","author_index":"Xoc001"}]